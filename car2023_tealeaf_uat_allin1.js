/* Aurocore Tealeaf SDK (Library 6.4.8) - TMNEWA - for new Car 2023 - All-in-one (2023-07-21) */
/* AppKey: TMNEWA UAT */

/*! pako deflate 1.0.11 */
!(function (t) { if (typeof exports === 'object' && typeof module !== 'undefined')module.exports = t(); else if (typeof define === 'function' && define.amd)define([], t); else { (typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : this).pako = t() } }(function () { return (function i (s, h, l) { function o (e, t) { if (!h[e]) { if (!s[e]) { const a = typeof require === 'function' && require; if (!t && a) return a(e, !0); if (_) return _(e, !0); const n = new Error("Cannot find module '" + e + "'"); throw n.code = 'MODULE_NOT_FOUND', n } const r = h[e] = { exports: {} }; s[e][0].call(r.exports, function (t) { return o(s[e][1][t] || t) }, r, r.exports, i, s, h, l) } return h[e].exports } for (var _ = typeof require === 'function' && require, t = 0; t < l.length; t++)o(l[t]); return o }({ 1: [function (t, e, a) { 'use strict'; const n = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined'; a.assign = function (t) { for (var e, a, n = Array.prototype.slice.call(arguments, 1); n.length;) { const r = n.shift(); if (r) { if (typeof r !== 'object') throw new TypeError(r + 'must be non-object'); for (const i in r)e = r, a = i, Object.prototype.hasOwnProperty.call(e, a) && (t[i] = r[i]) } } return t }, a.shrinkBuf = function (t, e) { return t.length === e ? t : t.subarray ? t.subarray(0, e) : (t.length = e, t) }; const r = { arraySet: function (t, e, a, n, r) { if (e.subarray && t.subarray)t.set(e.subarray(a, a + n), r); else for (let i = 0; i < n; i++)t[r + i] = e[a + i] }, flattenChunks: function (t) { let e, a, n, r, i, s; for (e = n = 0, a = t.length; e < a; e++)n += t[e].length; for (s = new Uint8Array(n), e = r = 0, a = t.length; e < a; e++)i = t[e], s.set(i, r), r += i.length; return s } }; const i = { arraySet: function (t, e, a, n, r) { for (let i = 0; i < n; i++)t[r + i] = e[a + i] }, flattenChunks: function (t) { return [].concat.apply([], t) } }; a.setTyped = function (t) { t ? (a.Buf8 = Uint8Array, a.Buf16 = Uint16Array, a.Buf32 = Int32Array, a.assign(a, r)) : (a.Buf8 = Array, a.Buf16 = Array, a.Buf32 = Array, a.assign(a, i)) }, a.setTyped(n) }, {}], 2: [function (t, e, a) { 'use strict'; const l = t('./common'); let r = !0; let i = !0; try { String.fromCharCode.apply(null, [0]) } catch (t) { r = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { i = !1 } for (var o = new l.Buf8(256), n = 0; n < 256; n++)o[n] = n >= 252 ? 6 : n >= 248 ? 5 : n >= 240 ? 4 : n >= 224 ? 3 : n >= 192 ? 2 : 1; function _ (t, e) { if (e < 65534 && (t.subarray && i || !t.subarray && r)) return String.fromCharCode.apply(null, l.shrinkBuf(t, e)); for (var a = '', n = 0; n < e; n++)a += String.fromCharCode(t[n]); return a }o[254] = o[254] = 1, a.string2buf = function (t) { let e; let a; let n; let r; let i; const s = t.length; let h = 0; for (r = 0; r < s; r++)(64512 & (a = t.charCodeAt(r))) == 55296 && r + 1 < s && (64512 & (n = t.charCodeAt(r + 1))) == 56320 && (a = 65536 + (a - 55296 << 10) + (n - 56320), r++), h += a < 128 ? 1 : a < 2048 ? 2 : a < 65536 ? 3 : 4; for (e = new l.Buf8(h), r = i = 0; i < h; r++)(64512 & (a = t.charCodeAt(r))) == 55296 && r + 1 < s && (64512 & (n = t.charCodeAt(r + 1))) == 56320 && (a = 65536 + (a - 55296 << 10) + (n - 56320), r++), a < 128 ? e[i++] = a : (a < 2048 ? e[i++] = 192 | a >>> 6 : (a < 65536 ? e[i++] = 224 | a >>> 12 : (e[i++] = 240 | a >>> 18, e[i++] = 128 | a >>> 12 & 63), e[i++] = 128 | a >>> 6 & 63), e[i++] = 128 | 63 & a); return e }, a.buf2binstring = function (t) { return _(t, t.length) }, a.binstring2buf = function (t) { for (var e = new l.Buf8(t.length), a = 0, n = e.length; a < n; a++)e[a] = t.charCodeAt(a); return e }, a.buf2string = function (t, e) { let a; let n; let r; let i; const s = e || t.length; const h = new Array(2 * s); for (a = n = 0; a < s;) if ((r = t[a++]) < 128)h[n++] = r; else if ((i = o[r]) > 4)h[n++] = 65533, a += i - 1; else { for (r &= i === 2 ? 31 : i === 3 ? 15 : 7; i > 1 && a < s;)r = r << 6 | 63 & t[a++], i--; i > 1 ? h[n++] = 65533 : r < 65536 ? h[n++] = r : (r -= 65536, h[n++] = 55296 | r >> 10 & 1023, h[n++] = 56320 | 1023 & r) } return _(h, n) }, a.utf8border = function (t, e) { let a; for ((e = e || t.length) > t.length && (e = t.length), a = e - 1; a >= 0 && (192 & t[a]) == 128;)a--; return a < 0 ? e : a === 0 ? e : a + o[t[a]] > e ? a : e } }, { './common': 1 }], 3: [function (t, e, a) { 'use strict'; e.exports = function (t, e, a, n) { for (var r = 65535 & t | 0, i = t >>> 16 & 65535 | 0, s = 0; a !== 0;) { for (a -= s = a > 2e3 ? 2e3 : a; i = i + (r = r + e[n++] | 0) | 0, --s;);r %= 65521, i %= 65521 } return r | i << 16 | 0 } }, {}], 4: [function (t, e, a) { 'use strict'; const h = (function () { for (var t, e = [], a = 0; a < 256; a++) { t = a; for (let n = 0; n < 8; n++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[a] = t } return e }()); e.exports = function (t, e, a, n) { const r = h; const i = n + a; t ^= -1; for (let s = n; s < i; s++)t = t >>> 8 ^ r[255 & (t ^ e[s])]; return -1 ^ t } }, {}], 5: [function (t, e, a) { 'use strict'; let l; const u = t('../utils/common'); const o = t('./trees'); const f = t('./adler32'); const c = t('./crc32'); const n = t('./messages'); const _ = 0; const d = 4; const p = 0; const g = -2; const m = -1; const b = 4; const r = 2; const v = 8; const w = 9; const i = 286; const s = 30; const h = 19; const y = 2 * i + 1; const k = 15; const z = 3; const x = 258; const B = x + z + 1; const A = 42; const C = 113; const S = 1; const j = 2; const E = 3; const U = 4; function D (t, e) { return t.msg = n[e], e } function I (t) { return (t << 1) - (t > 4 ? 9 : 0) } function O (t) { for (let e = t.length; --e >= 0;)t[e] = 0 } function q (t) { const e = t.state; let a = e.pending; a > t.avail_out && (a = t.avail_out), a !== 0 && (u.arraySet(t.output, e.pending_buf, e.pending_out, a, t.next_out), t.next_out += a, e.pending_out += a, t.total_out += a, t.avail_out -= a, e.pending -= a, e.pending === 0 && (e.pending_out = 0)) } function T (t, e) { o._tr_flush_block(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, q(t.strm) } function L (t, e) { t.pending_buf[t.pending++] = e } function N (t, e) { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e } function R (t, e) { let a; let n; let r = t.max_chain_length; let i = t.strstart; let s = t.prev_length; let h = t.nice_match; const l = t.strstart > t.w_size - B ? t.strstart - (t.w_size - B) : 0; const o = t.window; const _ = t.w_mask; const d = t.prev; const u = t.strstart + x; let f = o[i + s - 1]; let c = o[i + s]; t.prev_length >= t.good_match && (r >>= 2), h > t.lookahead && (h = t.lookahead); do { if (o[(a = e) + s] === c && o[a + s - 1] === f && o[a] === o[i] && o[++a] === o[i + 1]) { i += 2, a++; do {} while (o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && o[++i] === o[++a] && i < u); if (n = x - (u - i), i = u - x, s < n) { if (t.match_start = e, h <= (s = n)) break; f = o[i + s - 1], c = o[i + s] } } } while ((e = d[e & _]) > l && --r != 0); return s <= t.lookahead ? s : t.lookahead } function H (t) { let e; let a; let n; let r; let i; let s; let h; let l; let o; let _; const d = t.w_size; do { if (r = t.window_size - t.lookahead - t.strstart, t.strstart >= d + (d - B)) { for (u.arraySet(t.window, t.window, d, d, 0), t.match_start -= d, t.strstart -= d, t.block_start -= d, e = a = t.hash_size; n = t.head[--e], t.head[e] = d <= n ? n - d : 0, --a;);for (e = a = d; n = t.prev[--e], t.prev[e] = d <= n ? n - d : 0, --a;);r += d } if (t.strm.avail_in === 0) break; if (s = t.strm, h = t.window, l = t.strstart + t.lookahead, o = r, _ = void 0, _ = s.avail_in, o < _ && (_ = o), a = _ === 0 ? 0 : (s.avail_in -= _, u.arraySet(h, s.input, s.next_in, _, l), s.state.wrap === 1 ? s.adler = f(s.adler, h, _, l) : s.state.wrap === 2 && (s.adler = c(s.adler, h, _, l)), s.next_in += _, s.total_in += _, _), t.lookahead += a, t.lookahead + t.insert >= z) for (i = t.strstart - t.insert, t.ins_h = t.window[i], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[i + 1]) & t.hash_mask; t.insert && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[i + z - 1]) & t.hash_mask, t.prev[i & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = i, i++, t.insert--, !(t.lookahead + t.insert < z));); } while (t.lookahead < B && t.strm.avail_in !== 0) } function F (t, e) { for (var a, n; ;) { if (t.lookahead < B) { if (H(t), t.lookahead < B && e === _) return S; if (t.lookahead === 0) break } if (a = 0, t.lookahead >= z && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + z - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), a !== 0 && t.strstart - a <= t.w_size - B && (t.match_length = R(t, a)), t.match_length >= z) if (n = o._tr_tally(t, t.strstart - t.match_start, t.match_length - z), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= z) { for (t.match_length--; t.strstart++, t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + z - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart, --t.match_length != 0;);t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + 1]) & t.hash_mask; else n = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (n && (T(t, !1), t.strm.avail_out === 0)) return S } return t.insert = t.strstart < z - 1 ? t.strstart : z - 1, e === d ? (T(t, !0), t.strm.avail_out === 0 ? E : U) : t.last_lit && (T(t, !1), t.strm.avail_out === 0) ? S : j } function K (t, e) { for (var a, n, r; ;) { if (t.lookahead < B) { if (H(t), t.lookahead < B && e === _) return S; if (t.lookahead === 0) break } if (a = 0, t.lookahead >= z && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + z - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = z - 1, a !== 0 && t.prev_length < t.max_lazy_match && t.strstart - a <= t.w_size - B && (t.match_length = R(t, a), t.match_length <= 5 && (t.strategy === 1 || t.match_length === z && t.strstart - t.match_start > 4096) && (t.match_length = z - 1)), t.prev_length >= z && t.match_length <= t.prev_length) { for (r = t.strstart + t.lookahead - z, n = o._tr_tally(t, t.strstart - 1 - t.prev_match, t.prev_length - z), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; ++t.strstart <= r && (t.ins_h = (t.ins_h << t.hash_shift ^ t.window[t.strstart + z - 1]) & t.hash_mask, a = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), --t.prev_length != 0;);if (t.match_available = 0, t.match_length = z - 1, t.strstart++, n && (T(t, !1), t.strm.avail_out === 0)) return S } else if (t.match_available) { if ((n = o._tr_tally(t, 0, t.window[t.strstart - 1])) && T(t, !1), t.strstart++, t.lookahead--, t.strm.avail_out === 0) return S } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (n = o._tr_tally(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < z - 1 ? t.strstart : z - 1, e === d ? (T(t, !0), t.strm.avail_out === 0 ? E : U) : t.last_lit && (T(t, !1), t.strm.avail_out === 0) ? S : j } function M (t, e, a, n, r) { this.good_length = t, this.max_lazy = e, this.nice_length = a, this.max_chain = n, this.func = r } function P () { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = v, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new u.Buf16(2 * y), this.dyn_dtree = new u.Buf16(2 * (2 * s + 1)), this.bl_tree = new u.Buf16(2 * (2 * h + 1)), O(this.dyn_ltree), O(this.dyn_dtree), O(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new u.Buf16(k + 1), this.heap = new u.Buf16(2 * i + 1), O(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new u.Buf16(2 * i + 1), O(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function G (t) { let e; return t && t.state ? (t.total_in = t.total_out = 0, t.data_type = r, (e = t.state).pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = e.wrap ? A : C, t.adler = e.wrap === 2 ? 0 : 1, e.last_flush = _, o._tr_init(e), p) : D(t, g) } function J (t) { let e; const a = G(t); return a === p && ((e = t.state).window_size = 2 * e.w_size, O(e.head), e.max_lazy_match = l[e.level].max_lazy, e.good_match = l[e.level].good_length, e.nice_match = l[e.level].nice_length, e.max_chain_length = l[e.level].max_chain, e.strstart = 0, e.block_start = 0, e.lookahead = 0, e.insert = 0, e.match_length = e.prev_length = z - 1, e.match_available = 0, e.ins_h = 0), a } function Q (t, e, a, n, r, i) { if (!t) return g; let s = 1; if (e === m && (e = 6), n < 0 ? (s = 0, n = -n) : n > 15 && (s = 2, n -= 16), r < 1 || w < r || a !== v || n < 8 || n > 15 || e < 0 || e > 9 || i < 0 || b < i) return D(t, g); n === 8 && (n = 9); const h = new P(); return (t.state = h).strm = t, h.wrap = s, h.gzhead = null, h.w_bits = n, h.w_size = 1 << h.w_bits, h.w_mask = h.w_size - 1, h.hash_bits = r + 7, h.hash_size = 1 << h.hash_bits, h.hash_mask = h.hash_size - 1, h.hash_shift = ~~((h.hash_bits + z - 1) / z), h.window = new u.Buf8(2 * h.w_size), h.head = new u.Buf16(h.hash_size), h.prev = new u.Buf16(h.w_size), h.lit_bufsize = 1 << r + 6, h.pending_buf_size = 4 * h.lit_bufsize, h.pending_buf = new u.Buf8(h.pending_buf_size), h.d_buf = 1 * h.lit_bufsize, h.l_buf = 3 * h.lit_bufsize, h.level = e, h.strategy = i, h.method = a, J(t) }l = [new M(0, 0, 0, 0, function (t, e) { let a = 65535; for (a > t.pending_buf_size - 5 && (a = t.pending_buf_size - 5); ;) { if (t.lookahead <= 1) { if (H(t), t.lookahead === 0 && e === _) return S; if (t.lookahead === 0) break }t.strstart += t.lookahead, t.lookahead = 0; const n = t.block_start + a; if ((t.strstart === 0 || t.strstart >= n) && (t.lookahead = t.strstart - n, t.strstart = n, T(t, !1), t.strm.avail_out === 0)) return S; if (t.strstart - t.block_start >= t.w_size - B && (T(t, !1), t.strm.avail_out === 0)) return S } return t.insert = 0, e === d ? (T(t, !0), t.strm.avail_out === 0 ? E : U) : (t.strstart > t.block_start && (T(t, !1), t.strm.avail_out), S) }), new M(4, 4, 8, 4, F), new M(4, 5, 16, 8, F), new M(4, 6, 32, 32, F), new M(4, 4, 16, 16, K), new M(8, 16, 32, 32, K), new M(8, 16, 128, 128, K), new M(8, 32, 128, 256, K), new M(32, 128, 258, 1024, K), new M(32, 258, 258, 4096, K)], a.deflateInit = function (t, e) { return Q(t, e, v, 15, 8, 0) }, a.deflateInit2 = Q, a.deflateReset = J, a.deflateResetKeep = G, a.deflateSetHeader = function (t, e) { return t && t.state ? t.state.wrap !== 2 ? g : (t.state.gzhead = e, p) : g }, a.deflate = function (t, e) { let a, n, r, i; if (!t || !t.state || e > 5 || e < 0) return t ? D(t, g) : g; if (n = t.state, !t.output || !t.input && t.avail_in !== 0 || n.status === 666 && e !== d) return D(t, t.avail_out === 0 ? -5 : g); if (n.strm = t, a = n.last_flush, n.last_flush = e, n.status === A) if (n.wrap === 2)t.adler = 0, L(n, 31), L(n, 139), L(n, 8), n.gzhead ? (L(n, (n.gzhead.text ? 1 : 0) + (n.gzhead.hcrc ? 2 : 0) + (n.gzhead.extra ? 4 : 0) + (n.gzhead.name ? 8 : 0) + (n.gzhead.comment ? 16 : 0)), L(n, 255 & n.gzhead.time), L(n, n.gzhead.time >> 8 & 255), L(n, n.gzhead.time >> 16 & 255), L(n, n.gzhead.time >> 24 & 255), L(n, n.level === 9 ? 2 : n.strategy >= 2 || n.level < 2 ? 4 : 0), L(n, 255 & n.gzhead.os), n.gzhead.extra && n.gzhead.extra.length && (L(n, 255 & n.gzhead.extra.length), L(n, n.gzhead.extra.length >> 8 & 255)), n.gzhead.hcrc && (t.adler = c(t.adler, n.pending_buf, n.pending, 0)), n.gzindex = 0, n.status = 69) : (L(n, 0), L(n, 0), L(n, 0), L(n, 0), L(n, 0), L(n, n.level === 9 ? 2 : n.strategy >= 2 || n.level < 2 ? 4 : 0), L(n, 3), n.status = C); else { let s = v + (n.w_bits - 8 << 4) << 8; s |= (n.strategy >= 2 || n.level < 2 ? 0 : n.level < 6 ? 1 : n.level === 6 ? 2 : 3) << 6, n.strstart !== 0 && (s |= 32), s += 31 - s % 31, n.status = C, N(n, s), n.strstart !== 0 && (N(n, t.adler >>> 16), N(n, 65535 & t.adler)), t.adler = 1 } if (n.status === 69) if (n.gzhead.extra) { for (r = n.pending; n.gzindex < (65535 & n.gzhead.extra.length) && (n.pending !== n.pending_buf_size || (n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), q(t), r = n.pending, n.pending !== n.pending_buf_size));)L(n, 255 & n.gzhead.extra[n.gzindex]), n.gzindex++; n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), n.gzindex === n.gzhead.extra.length && (n.gzindex = 0, n.status = 73) } else n.status = 73; if (n.status === 73) if (n.gzhead.name) { r = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), q(t), r = n.pending, n.pending === n.pending_buf_size)) { i = 1; break }L(n, i = n.gzindex < n.gzhead.name.length ? 255 & n.gzhead.name.charCodeAt(n.gzindex++) : 0) } while (i !== 0); n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), i === 0 && (n.gzindex = 0, n.status = 91) } else n.status = 91; if (n.status === 91) if (n.gzhead.comment) { r = n.pending; do { if (n.pending === n.pending_buf_size && (n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), q(t), r = n.pending, n.pending === n.pending_buf_size)) { i = 1; break }L(n, i = n.gzindex < n.gzhead.comment.length ? 255 & n.gzhead.comment.charCodeAt(n.gzindex++) : 0) } while (i !== 0); n.gzhead.hcrc && n.pending > r && (t.adler = c(t.adler, n.pending_buf, n.pending - r, r)), i === 0 && (n.status = 103) } else n.status = 103; if (n.status === 103 && (n.gzhead.hcrc ? (n.pending + 2 > n.pending_buf_size && q(t), n.pending + 2 <= n.pending_buf_size && (L(n, 255 & t.adler), L(n, t.adler >> 8 & 255), t.adler = 0, n.status = C)) : n.status = C), n.pending !== 0) { if (q(t), t.avail_out === 0) return n.last_flush = -1, p } else if (t.avail_in === 0 && I(e) <= I(a) && e !== d) return D(t, -5); if (n.status === 666 && t.avail_in !== 0) return D(t, -5); if (t.avail_in !== 0 || n.lookahead !== 0 || e !== _ && n.status !== 666) { const h = n.strategy === 2 ? (function (t, e) { for (var a; ;) { if (t.lookahead === 0 && (H(t), t.lookahead === 0)) { if (e === _) return S; break } if (t.match_length = 0, a = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, a && (T(t, !1), t.strm.avail_out === 0)) return S } return t.insert = 0, e === d ? (T(t, !0), t.strm.avail_out === 0 ? E : U) : t.last_lit && (T(t, !1), t.strm.avail_out === 0) ? S : j }(n, e)) : n.strategy === 3 ? (function (t, e) { for (var a, n, r, i, s = t.window; ;) { if (t.lookahead <= x) { if (H(t), t.lookahead <= x && e === _) return S; if (t.lookahead === 0) break } if (t.match_length = 0, t.lookahead >= z && t.strstart > 0 && (n = s[r = t.strstart - 1]) === s[++r] && n === s[++r] && n === s[++r]) { i = t.strstart + x; do {} while (n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && n === s[++r] && r < i); t.match_length = x - (i - r), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= z ? (a = o._tr_tally(t, 1, t.match_length - z), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (a = o._tr_tally(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), a && (T(t, !1), t.strm.avail_out === 0)) return S } return t.insert = 0, e === d ? (T(t, !0), t.strm.avail_out === 0 ? E : U) : t.last_lit && (T(t, !1), t.strm.avail_out === 0) ? S : j }(n, e)) : l[n.level].func(n, e); if (h !== E && h !== U || (n.status = 666), h === S || h === E) return t.avail_out === 0 && (n.last_flush = -1), p; if (h === j && (e === 1 ? o._tr_align(n) : e !== 5 && (o._tr_stored_block(n, 0, 0, !1), e === 3 && (O(n.head), n.lookahead === 0 && (n.strstart = 0, n.block_start = 0, n.insert = 0))), q(t), t.avail_out === 0)) return n.last_flush = -1, p } return e !== d ? p : n.wrap <= 0 ? 1 : (n.wrap === 2 ? (L(n, 255 & t.adler), L(n, t.adler >> 8 & 255), L(n, t.adler >> 16 & 255), L(n, t.adler >> 24 & 255), L(n, 255 & t.total_in), L(n, t.total_in >> 8 & 255), L(n, t.total_in >> 16 & 255), L(n, t.total_in >> 24 & 255)) : (N(n, t.adler >>> 16), N(n, 65535 & t.adler)), q(t), n.wrap > 0 && (n.wrap = -n.wrap), n.pending !== 0 ? p : 1) }, a.deflateEnd = function (t) { let e; return t && t.state ? (e = t.state.status) !== A && e !== 69 && e !== 73 && e !== 91 && e !== 103 && e !== C && e !== 666 ? D(t, g) : (t.state = null, e === C ? D(t, -3) : p) : g }, a.deflateSetDictionary = function (t, e) { let a; let n; let r; let i; let s; let h; let l; let o; let _ = e.length; if (!t || !t.state) return g; if ((i = (a = t.state).wrap) === 2 || i === 1 && a.status !== A || a.lookahead) return g; for (i === 1 && (t.adler = f(t.adler, e, _, 0)), a.wrap = 0, _ >= a.w_size && (i === 0 && (O(a.head), a.strstart = 0, a.block_start = 0, a.insert = 0), o = new u.Buf8(a.w_size), u.arraySet(o, e, _ - a.w_size, a.w_size, 0), e = o, _ = a.w_size), s = t.avail_in, h = t.next_in, l = t.input, t.avail_in = _, t.next_in = 0, t.input = e, H(a); a.lookahead >= z;) { for (n = a.strstart, r = a.lookahead - (z - 1); a.ins_h = (a.ins_h << a.hash_shift ^ a.window[n + z - 1]) & a.hash_mask, a.prev[n & a.w_mask] = a.head[a.ins_h], a.head[a.ins_h] = n, n++, --r;);a.strstart = n, a.lookahead = z - 1, H(a) } return a.strstart += a.lookahead, a.block_start = a.strstart, a.insert = a.lookahead, a.lookahead = 0, a.match_length = a.prev_length = z - 1, a.match_available = 0, t.next_in = h, t.input = l, t.avail_in = s, a.wrap = i, p }, a.deflateInfo = 'pako deflate (from Nodeca project)' }, { '../utils/common': 1, './adler32': 3, './crc32': 4, './messages': 6, './trees': 7 }], 6: [function (t, e, a) { 'use strict'; e.exports = { 2: 'need dictionary', 1: 'stream end', 0: '', '-1': 'file error', '-2': 'stream error', '-3': 'data error', '-4': 'insufficient memory', '-5': 'buffer error', '-6': 'incompatible version' } }, {}], 7: [function (t, e, a) { 'use strict'; const l = t('../utils/common'); const h = 0; const o = 1; function n (t) { for (let e = t.length; --e >= 0;)t[e] = 0 } const _ = 0; const s = 29; const d = 256; const u = d + 1 + s; const f = 30; const c = 19; const g = 2 * u + 1; const m = 15; const r = 16; const p = 7; const b = 256; const v = 16; const w = 17; const y = 18; const k = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; const z = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; const x = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]; const B = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; const A = new Array(2 * (u + 2)); n(A); const C = new Array(2 * f); n(C); const S = new Array(512); n(S); const j = new Array(256); n(j); const E = new Array(s); n(E); let U; let D; let I; const O = new Array(f); function q (t, e, a, n, r) { this.static_tree = t, this.extra_bits = e, this.extra_base = a, this.elems = n, this.max_length = r, this.has_stree = t && t.length } function i (t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } function T (t) { return t < 256 ? S[t] : S[256 + (t >>> 7)] } function L (t, e) { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 } function N (t, e, a) { t.bi_valid > r - a ? (t.bi_buf |= e << t.bi_valid & 65535, L(t, t.bi_buf), t.bi_buf = e >> r - t.bi_valid, t.bi_valid += a - r) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += a) } function R (t, e, a) { N(t, a[2 * e], a[2 * e + 1]) } function H (t, e) { for (var a = 0; a |= 1 & t, t >>>= 1, a <<= 1, --e > 0;);return a >>> 1 } function F (t, e, a) { let n; let r; const i = new Array(m + 1); let s = 0; for (n = 1; n <= m; n++)i[n] = s = s + a[n - 1] << 1; for (r = 0; r <= e; r++) { const h = t[2 * r + 1]; h !== 0 && (t[2 * r] = H(i[h]++, h)) } } function K (t) { let e; for (e = 0; e < u; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < f; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < c; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[2 * b] = 1, t.opt_len = t.static_len = 0, t.last_lit = t.matches = 0 } function M (t) { t.bi_valid > 8 ? L(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 } function P (t, e, a, n) { const r = 2 * e; const i = 2 * a; return t[r] < t[i] || t[r] === t[i] && n[e] <= n[a] } function G (t, e, a) { for (var n = t.heap[a], r = a << 1; r <= t.heap_len && (r < t.heap_len && P(e, t.heap[r + 1], t.heap[r], t.depth) && r++, !P(e, n, t.heap[r], t.depth));)t.heap[a] = t.heap[r], a = r, r <<= 1; t.heap[a] = n } function J (t, e, a) { let n; let r; let i; let s; let h = 0; if (t.last_lit !== 0) for (;n = t.pending_buf[t.d_buf + 2 * h] << 8 | t.pending_buf[t.d_buf + 2 * h + 1], r = t.pending_buf[t.l_buf + h], h++, n === 0 ? R(t, r, e) : (R(t, (i = j[r]) + d + 1, e), (s = k[i]) !== 0 && N(t, r -= E[i], s), R(t, i = T(--n), a), (s = z[i]) !== 0 && N(t, n -= O[i], s)), h < t.last_lit;);R(t, b, e) } function Q (t, e) { let a; let n; let r; const i = e.dyn_tree; const s = e.stat_desc.static_tree; const h = e.stat_desc.has_stree; const l = e.stat_desc.elems; let o = -1; for (t.heap_len = 0, t.heap_max = g, a = 0; a < l; a++)i[2 * a] !== 0 ? (t.heap[++t.heap_len] = o = a, t.depth[a] = 0) : i[2 * a + 1] = 0; for (;t.heap_len < 2;)i[2 * (r = t.heap[++t.heap_len] = o < 2 ? ++o : 0)] = 1, t.depth[r] = 0, t.opt_len--, h && (t.static_len -= s[2 * r + 1]); for (e.max_code = o, a = t.heap_len >> 1; a >= 1; a--)G(t, i, a); for (r = l; a = t.heap[1], t.heap[1] = t.heap[t.heap_len--], G(t, i, 1), n = t.heap[1], t.heap[--t.heap_max] = a, t.heap[--t.heap_max] = n, i[2 * r] = i[2 * a] + i[2 * n], t.depth[r] = (t.depth[a] >= t.depth[n] ? t.depth[a] : t.depth[n]) + 1, i[2 * a + 1] = i[2 * n + 1] = r, t.heap[1] = r++, G(t, i, 1), t.heap_len >= 2;);t.heap[--t.heap_max] = t.heap[1], (function (t, e) { let a; let n; let r; let i; let s; let h; const l = e.dyn_tree; const o = e.max_code; const _ = e.stat_desc.static_tree; const d = e.stat_desc.has_stree; const u = e.stat_desc.extra_bits; const f = e.stat_desc.extra_base; const c = e.stat_desc.max_length; let p = 0; for (i = 0; i <= m; i++)t.bl_count[i] = 0; for (l[2 * t.heap[t.heap_max] + 1] = 0, a = t.heap_max + 1; a < g; a++)c < (i = l[2 * l[2 * (n = t.heap[a]) + 1] + 1] + 1) && (i = c, p++), l[2 * n + 1] = i, o < n || (t.bl_count[i]++, s = 0, f <= n && (s = u[n - f]), h = l[2 * n], t.opt_len += h * (i + s), d && (t.static_len += h * (_[2 * n + 1] + s))); if (p !== 0) { do { for (i = c - 1; t.bl_count[i] === 0;)i--; t.bl_count[i]--, t.bl_count[i + 1] += 2, t.bl_count[c]--, p -= 2 } while (p > 0); for (i = c; i !== 0; i--) for (n = t.bl_count[i]; n !== 0;)o < (r = t.heap[--a]) || (l[2 * r + 1] !== i && (t.opt_len += (i - l[2 * r + 1]) * l[2 * r], l[2 * r + 1] = i), n--) } }(t, e)), F(i, o, t.bl_count) } function V (t, e, a) { let n; let r; let i = -1; let s = e[1]; let h = 0; let l = 7; let o = 4; for (s === 0 && (l = 138, o = 3), e[2 * (a + 1) + 1] = 65535, n = 0; n <= a; n++)r = s, s = e[2 * (n + 1) + 1], ++h < l && r === s || (h < o ? t.bl_tree[2 * r] += h : r !== 0 ? (r !== i && t.bl_tree[2 * r]++, t.bl_tree[2 * v]++) : h <= 10 ? t.bl_tree[2 * w]++ : t.bl_tree[2 * y]++, i = r, (h = 0) === s ? (l = 138, o = 3) : r === s ? (l = 6, o = 3) : (l = 7, o = 4)) } function W (t, e, a) { let n; let r; let i = -1; let s = e[1]; let h = 0; let l = 7; let o = 4; for (s === 0 && (l = 138, o = 3), n = 0; n <= a; n++) if (r = s, s = e[2 * (n + 1) + 1], !(++h < l && r === s)) { if (h < o) for (;R(t, r, t.bl_tree), --h != 0;);else r !== 0 ? (r !== i && (R(t, r, t.bl_tree), h--), R(t, v, t.bl_tree), N(t, h - 3, 2)) : h <= 10 ? (R(t, w, t.bl_tree), N(t, h - 3, 3)) : (R(t, y, t.bl_tree), N(t, h - 11, 7)); i = r, (h = 0) === s ? (l = 138, o = 3) : r === s ? (l = 6, o = 3) : (l = 7, o = 4) } }n(O); let X = !1; function Y (t, e, a, n) { let r, i, s, h; N(t, (_ << 1) + (n ? 1 : 0), 3), i = e, s = a, h = !0, M(r = t), h && (L(r, s), L(r, ~s)), l.arraySet(r.pending_buf, r.window, i, s, r.pending), r.pending += s }a._tr_init = function (t) { X || ((function () { let t; let e; let a; let n; let r; const i = new Array(m + 1); for (n = a = 0; n < s - 1; n++) for (E[n] = a, t = 0; t < 1 << k[n]; t++)j[a++] = n; for (j[a - 1] = n, n = r = 0; n < 16; n++) for (O[n] = r, t = 0; t < 1 << z[n]; t++)S[r++] = n; for (r >>= 7; n < f; n++) for (O[n] = r << 7, t = 0; t < 1 << z[n] - 7; t++)S[256 + r++] = n; for (e = 0; e <= m; e++)i[e] = 0; for (t = 0; t <= 143;)A[2 * t + 1] = 8, t++, i[8]++; for (;t <= 255;)A[2 * t + 1] = 9, t++, i[9]++; for (;t <= 279;)A[2 * t + 1] = 7, t++, i[7]++; for (;t <= 287;)A[2 * t + 1] = 8, t++, i[8]++; for (F(A, u + 1, i), t = 0; t < f; t++)C[2 * t + 1] = 5, C[2 * t] = H(t, 5); U = new q(A, k, d + 1, u, m), D = new q(C, z, 0, f, m), I = new q(new Array(0), x, 0, c, p) }()), X = !0), t.l_desc = new i(t.dyn_ltree, U), t.d_desc = new i(t.dyn_dtree, D), t.bl_desc = new i(t.bl_tree, I), t.bi_buf = 0, t.bi_valid = 0, K(t) }, a._tr_stored_block = Y, a._tr_flush_block = function (t, e, a, n) { let r; let i; let s = 0; t.level > 0 ? (t.strm.data_type === 2 && (t.strm.data_type = (function (t) { let e; let a = 4093624447; for (e = 0; e <= 31; e++, a >>>= 1) if (1 & a && t.dyn_ltree[2 * e] !== 0) return h; if (t.dyn_ltree[18] !== 0 || t.dyn_ltree[20] !== 0 || t.dyn_ltree[26] !== 0) return o; for (e = 32; e < d; e++) if (t.dyn_ltree[2 * e] !== 0) return o; return h }(t))), Q(t, t.l_desc), Q(t, t.d_desc), s = (function (t) { let e; for (V(t, t.dyn_ltree, t.l_desc.max_code), V(t, t.dyn_dtree, t.d_desc.max_code), Q(t, t.bl_desc), e = c - 1; e >= 3 && t.bl_tree[2 * B[e] + 1] === 0; e--);return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e }(t)), r = t.opt_len + 3 + 7 >>> 3, (i = t.static_len + 3 + 7 >>> 3) <= r && (r = i)) : r = i = a + 5, a + 4 <= r && e !== -1 ? Y(t, e, a, n) : t.strategy === 4 || i === r ? (N(t, 2 + (n ? 1 : 0), 3), J(t, A, C)) : (N(t, 4 + (n ? 1 : 0), 3), (function (t, e, a, n) { let r; for (N(t, e - 257, 5), N(t, a - 1, 5), N(t, n - 4, 4), r = 0; r < n; r++)N(t, t.bl_tree[2 * B[r] + 1], 3); W(t, t.dyn_ltree, e - 1), W(t, t.dyn_dtree, a - 1) }(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1)), J(t, t.dyn_ltree, t.dyn_dtree)), K(t), n && M(t) }, a._tr_tally = function (t, e, a) { return t.pending_buf[t.d_buf + 2 * t.last_lit] = e >>> 8 & 255, t.pending_buf[t.d_buf + 2 * t.last_lit + 1] = 255 & e, t.pending_buf[t.l_buf + t.last_lit] = 255 & a, t.last_lit++, e === 0 ? t.dyn_ltree[2 * a]++ : (t.matches++, e--, t.dyn_ltree[2 * (j[a] + d + 1)]++, t.dyn_dtree[2 * T(e)]++), t.last_lit === t.lit_bufsize - 1 }, a._tr_align = function (t) { let e; N(t, 2, 3), R(t, b, A), (e = t).bi_valid === 16 ? (L(e, e.bi_buf), e.bi_buf = 0, e.bi_valid = 0) : e.bi_valid >= 8 && (e.pending_buf[e.pending++] = 255 & e.bi_buf, e.bi_buf >>= 8, e.bi_valid -= 8) } }, { '../utils/common': 1 }], 8: [function (t, e, a) { 'use strict'; e.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = '', this.state = null, this.data_type = 2, this.adler = 0 } }, {}], '/lib/deflate.js': [function (t, e, a) { 'use strict'; const s = t('./zlib/deflate'); const h = t('./utils/common'); const l = t('./utils/strings'); const r = t('./zlib/messages'); const i = t('./zlib/zstream'); const o = Object.prototype.toString; const _ = 0; const d = -1; const u = 0; const f = 8; function c (t) { if (!(this instanceof c)) return new c(t); this.options = h.assign({ level: d, method: f, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: u, to: '' }, t || {}); const e = this.options; e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new i(), this.strm.avail_out = 0; let a = s.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (a !== _) throw new Error(r[a]); if (e.header && s.deflateSetHeader(this.strm, e.header), e.dictionary) { let n; if (n = typeof e.dictionary === 'string' ? l.string2buf(e.dictionary) : o.call(e.dictionary) === '[object ArrayBuffer]' ? new Uint8Array(e.dictionary) : e.dictionary, (a = s.deflateSetDictionary(this.strm, n)) !== _) throw new Error(r[a]); this._dict_set = !0 } } function n (t, e) { const a = new c(e); if (a.push(t, !0), a.err) throw a.msg || r[a.err]; return a.result }c.prototype.push = function (t, e) { let a; let n; const r = this.strm; const i = this.options.chunkSize; if (this.ended) return !1; n = e === ~~e ? e : !0 === e ? 4 : 0, typeof t === 'string' ? r.input = l.string2buf(t) : o.call(t) === '[object ArrayBuffer]' ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length; do { if (r.avail_out === 0 && (r.output = new h.Buf8(i), r.next_out = 0, r.avail_out = i), (a = s.deflate(r, n)) !== 1 && a !== _) return this.onEnd(a), !(this.ended = !0); r.avail_out !== 0 && (r.avail_in !== 0 || n !== 4 && n !== 2) || (this.options.to === 'string' ? this.onData(l.buf2binstring(h.shrinkBuf(r.output, r.next_out))) : this.onData(h.shrinkBuf(r.output, r.next_out))) } while ((r.avail_in > 0 || r.avail_out === 0) && a !== 1); return n === 4 ? (a = s.deflateEnd(this.strm), this.onEnd(a), this.ended = !0, a === _) : n !== 2 || (this.onEnd(_), !(r.avail_out = 0)) }, c.prototype.onData = function (t) { this.chunks.push(t) }, c.prototype.onEnd = function (t) { t === _ && (this.options.to === 'string' ? this.result = this.chunks.join('') : this.result = h.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }, a.Deflate = c, a.deflate = n, a.deflateRaw = function (t, e) { return (e = e || {}).raw = !0, n(t, e) }, a.gzip = function (t, e) { return (e = e || {}).gzip = !0, n(t, e) } }, { './utils/common': 1, './utils/strings': 2, './zlib/deflate': 5, './zlib/messages': 6, './zlib/zstream': 8 }] }, {}, []))('/lib/deflate.js') }))

/*!
 * Copyright (c) 2023 Acoustic, L.P. All rights reserved.
 *
 * NOTICE: This file contains material that is confidential and proprietary to
 * Acoustic, L.P. and/or other developers. No license is granted under any intellectual or
 * industrial property rights of Acoustic, L.P. except as may be provided in an agreement with
 * Acoustic, L.P. Any unauthorized copying or distribution of content from this file is
 * prohibited.
 *
 * @version 6.4.8 (mod_for_tmnewa_cookieList.length_limit)
 * @flags NDEBUG
 */
if (window.TLT) throw 'Attempting to recreate TLT. Library may be included more than once on the page.'; window.TLT = (function () { 'use strict'; let e; let t; let n; let r; let i; let a; let o; let s; let u; let l; let c; let d; let f; let h = !1; function p (e) { window.TLT && e.persisted && (TLT.terminationReason = '', TLT.init()) } function g (e, t, n, r) { let i = null; let o = null; const u = TLT.getModule('replay'); const l = TLT.getModule('TLCookie'); const c = TLT.getModule('performance'); let f = null; const h = d.getOriginAndPath(); t && typeof t === 'string' && (n && typeof n === 'string' || (n = ''), o = { type: 2, screenview: { type: e, name: t, originalUrl: h.path, url: TLT.normalizeUrl('', h.path, 2), host: h.origin, referrer: n, title: document.title, queryParams: h.queryParams } }, e === 'LOAD' ? f = { type: 'screenview_load', name: t } : e === 'UNLOAD' && (f = { type: 'screenview_unload', name: t }), f && u && (i = u.onevent(f)), i && (o.dcid = i), e !== 'LOAD' && e !== 'UNLOAD' || a.post('', o), f && l && l.onevent(f), f && c && c.onevent(f), f && s && s.onevent(f)) } let m; let v; let y; const w = (new Date()).getTime(); const b = {}; const T = {}; const S = {}; let _ = !1; let x = null; const E = (function () { let e; let t = []; function r (r) { return d.indexOf(t, r) < 0 && (function (r) { let i; let a; const o = u.framesBlacklist; if (e = e || [], r = r || null, void 0 !== o && o.length > 0) { for (a = 0; a < o.length; a += 1)(i = n.queryAll(o[a], r)) && i.length > 0 && (e = e.concat(i)); t = t.concat(n.queryAll('iframe', r)) } }(r.ownerDocument)), d.indexOf(e, r) > -1 } return r.clearCache = function () { e = null }, r }()); let C = null; const O = { config: ['getConfig', 'updateConfig', 'getCoreConfig', 'updateCoreConfig', 'getModuleConfig', 'updateModuleConfig', 'getServiceConfig', 'updateServiceConfig'], queue: ['post', 'setAutoFlush', 'flushAll', 'setXHRLog'], browserBase: ['getXPathFromNode', 'processDOMEvent'] }; const k = (y = {}, { normalizeModuleEvents: function (e, t, n, r) { const i = y[e]; let a = !1; let o = !1; n = n || H._getLocalTop(), i || (y[e] = { loadFired: !1, pageHideFired: !1 }, d.forEach(t, function (e) { switch (e.name) { case 'load':a = !0, t.push(d.mixin(d.mixin({}, e), { name: 'pageshow' })); break; case 'unload':o = !0, t.push(d.mixin(d.mixin({}, e), { name: 'pagehide' })), t.push(d.mixin(d.mixin({}, e), { name: 'beforeunload' })); break; case 'change':d.isLegacyIE && H.getFlavor() === 'w3c' && t.push(d.mixin(d.mixin({}, e), { name: 'propertychange' })) } }), a || o ? (y[e].silentLoad = !a, y[e].silentUnload = !o, a || t.push({ name: 'load', target: n }), o || t.push({ name: 'unload', target: n })) : delete y[e]) }, canPublish: function (e, t) { let n; if (!1 === y.hasOwnProperty(e)) return !0; switch (n = y[e], t.type) { case 'load':return n.pageHideFired = !1, n.loadFired = !0, !n.silentLoad; case 'pageshow':return n.pageHideFired = !1, t.type = 'load', !n.loadFired && !n.silentLoad; case 'pagehide':return t.type = 'unload', n.loadFired = !1, n.pageHideFired = !0, !n.silentUnload; case 'unload':case 'beforeunload':return t.type = 'unload', n.loadFired = !1, !n.pageHideFired && !n.silentUnload } return !0 }, isUnload: function (e) { return typeof e === 'object' && (e.type === 'unload' || e.type === 'beforeunload' || e.type === 'pagehide') } }); let L = {}; let M = {}; let D = {}; let I = []; let P = function () {}; let R = null; let A = !0; let N = function () {}; let z = !1; const V = (function () { const e = window.location; let t = e.pathname; let n = e.hash; let r = ''; return function () { const i = e.pathname; const a = e.hash; let o = r; i !== t ? o = TLT.normalizeUrl('', i + a, 2) : a !== n && (o = TLT.normalizeUrl('', a, 2)), o !== r && (r && g('UNLOAD', r), g('LOAD', o), r = o, t = i, n = a) } }()); let F = function (e, t) { let r; let i; let a; let o; let s; let l; let c = !1; const f = u.blockedElements; if (!f || !f.length) return F = function () { return !1 }, c; if (!e || !e.nodeType) return c; for (t = t || d.getDocument(e), r = 0, a = f.length; r < a && !c; r += 1) for (i = 0, l = (s = n.queryAll(f[r], t)).length; i < l && !c; i += 1)c = (o = s[i]).contains ? o.contains(e) : o === e; return c }; var H = { getTLTSessionCookieInfo: function () { return b }, _loadGlobalsForUnitTesting: function (l) { d = l.utils, e = l.getService('ajax'), t = l.getService('browserBase'), n = l.getService('browser'), r = l.getService('config'), i = l.getService('domCapture'), a = l.getService('queue'), o = l.getService('serializer'), s = l.getModule('dataLayer'), u = r ? r.getCoreConfig() : null }, getStartTime: function () { return w }, getPageId: function () { return m || '#' }, getTabId: function () { return v }, isMousemovementDetected: function () { return h }, setSessionCookieInfo: function (e, t, n) { b.tltCookieName = t, b.tltCookieValue = n }, getLibraryVersion: function () { return '6.4.8' }, getCurrentWebEvent: function () { return L }, normalizeUrl: function (e, t, n) { let r, i; if ((r = this.getCoreConfig()).normalization && r.normalization.urlFunction) { typeof (i = r.normalization.urlFunction) === 'string' && (i = d.access(i)); try { t = i(t, n) } catch (e) {} } return t }, getCurrentOffset: function () { return this.getService('message').getCurrentOffset() }, initLib: function (e, t) { let n; if (typeof pako === 'object' && void 0 !== pako ? console && console.info('Pako is already loaded.') : window.pako = (function e (t, n, r) { function i (o, s) { if (!n[o]) { if (!t[o]) { const u = typeof require === 'function' && require; if (!s && u) return u(o, !0); if (a) return a(o, !0); const l = new Error("Cannot find module '" + o + "'"); throw l.code = 'MODULE_NOT_FOUND', l } const c = n[o] = { exports: {} }; t[o][0].call(c.exports, function (e) { return i(t[o][1][e] || e) }, c, c.exports, e, t, n, r) } return n[o].exports } for (var a = typeof require === 'function' && require, o = 0; o < r.length; o++)i(r[o]); return i }({ 1: [function (e, t, n) { const r = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined'; n.assign = function (e) { for (var t, n, r = Array.prototype.slice.call(arguments, 1); r.length;) { const i = r.shift(); if (i) { if (typeof i !== 'object') throw new TypeError(i + 'must be non-object'); for (const a in i)t = i, n = a, Object.prototype.hasOwnProperty.call(t, n) && (e[a] = i[a]) } } return e }, n.shrinkBuf = function (e, t) { return e.length === t ? e : e.subarray ? e.subarray(0, t) : (e.length = t, e) }; const i = { arraySet: function (e, t, n, r, i) { if (t.subarray && e.subarray)e.set(t.subarray(n, n + r), i); else for (let a = 0; a < r; a++)e[i + a] = t[n + a] }, flattenChunks: function (e) { let t, n, r, i, a, o; for (t = r = 0, n = e.length; t < n; t++)r += e[t].length; for (o = new Uint8Array(r), t = i = 0, n = e.length; t < n; t++)a = e[t], o.set(a, i), i += a.length; return o } }; const a = { arraySet: function (e, t, n, r, i) { for (let a = 0; a < r; a++)e[i + a] = t[n + a] }, flattenChunks: function (e) { return [].concat.apply([], e) } }; n.setTyped = function (e) { e ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, i)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, a)) }, n.setTyped(r) }, {}], 2: [function (e, t, n) { const r = e('./common'); let i = !0; let a = !0; try { String.fromCharCode.apply(null, [0]) } catch (e) { i = !1 } try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (e) { a = !1 } for (var o = new r.Buf8(256), s = 0; s < 256; s++)o[s] = s >= 252 ? 6 : s >= 248 ? 5 : s >= 240 ? 4 : s >= 224 ? 3 : s >= 192 ? 2 : 1; function u (e, t) { if (t < 65534 && (e.subarray && a || !e.subarray && i)) return String.fromCharCode.apply(null, r.shrinkBuf(e, t)); for (var n = '', o = 0; o < t; o++)n += String.fromCharCode(e[o]); return n }o[254] = o[254] = 1, n.string2buf = function (e) { let t; let n; let i; let a; let o; const s = e.length; let u = 0; for (a = 0; a < s; a++)(64512 & (n = e.charCodeAt(a))) == 55296 && a + 1 < s && (64512 & (i = e.charCodeAt(a + 1))) == 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), u += n < 128 ? 1 : n < 2048 ? 2 : n < 65536 ? 3 : 4; for (t = new r.Buf8(u), a = o = 0; o < u; a++)(64512 & (n = e.charCodeAt(a))) == 55296 && a + 1 < s && (64512 & (i = e.charCodeAt(a + 1))) == 56320 && (n = 65536 + (n - 55296 << 10) + (i - 56320), a++), n < 128 ? t[o++] = n : (n < 2048 ? t[o++] = 192 | n >>> 6 : (n < 65536 ? t[o++] = 224 | n >>> 12 : (t[o++] = 240 | n >>> 18, t[o++] = 128 | n >>> 12 & 63), t[o++] = 128 | n >>> 6 & 63), t[o++] = 128 | 63 & n); return t }, n.buf2binstring = function (e) { return u(e, e.length) }, n.binstring2buf = function (e) { for (var t = new r.Buf8(e.length), n = 0, i = t.length; n < i; n++)t[n] = e.charCodeAt(n); return t }, n.buf2string = function (e, t) { let n; let r; let i; let a; const s = t || e.length; const l = new Array(2 * s); for (n = r = 0; n < s;) if ((i = e[n++]) < 128)l[r++] = i; else if ((a = o[i]) > 4)l[r++] = 65533, n += a - 1; else { for (i &= a === 2 ? 31 : a === 3 ? 15 : 7; a > 1 && n < s;)i = i << 6 | 63 & e[n++], a--; a > 1 ? l[r++] = 65533 : i < 65536 ? l[r++] = i : (i -= 65536, l[r++] = 55296 | i >> 10 & 1023, l[r++] = 56320 | 1023 & i) } return u(l, r) }, n.utf8border = function (e, t) { let n; for ((t = t || e.length) > e.length && (t = e.length), n = t - 1; n >= 0 && (192 & e[n]) == 128;)n--; return n < 0 || n === 0 ? t : n + o[e[n]] > t ? n : t } }, { './common': 1 }], 3: [function (e, t, n) { t.exports = function (e, t, n, r) { for (var i = 65535 & e | 0, a = e >>> 16 & 65535 | 0, o = 0; n !== 0;) { for (n -= o = n > 2e3 ? 2e3 : n; a = a + (i = i + t[r++] | 0) | 0, --o;);i %= 65521, a %= 65521 } return i | a << 16 | 0 } }, {}], 4: [function (e, t, n) { const r = (function () { for (var e, t = [], n = 0; n < 256; n++) { e = n; for (let r = 0; r < 8; r++)e = 1 & e ? 3988292384 ^ e >>> 1 : e >>> 1; t[n] = e } return t }()); t.exports = function (e, t, n, i) { const a = r; const o = i + n; e ^= -1; for (let s = i; s < o; s++)e = e >>> 8 ^ a[255 & (e ^ t[s])]; return -1 ^ e } }, {}], 5: [function (e, t, n) { let r; const i = e('../utils/common'); const a = e('./trees'); const o = e('./adler32'); const s = e('./crc32'); const u = e('./messages'); const l = 0; const c = 4; const d = 0; const f = -2; const h = -1; const p = 4; const g = 2; const m = 8; const v = 9; const y = 286; const w = 30; const b = 19; const T = 2 * y + 1; const S = 15; const _ = 3; const x = 258; const E = x + _ + 1; const C = 42; const O = 113; const k = 1; const L = 2; const M = 3; const D = 4; function I (e, t) { return e.msg = u[t], t } function P (e) { return (e << 1) - (e > 4 ? 9 : 0) } function R (e) { for (let t = e.length; --t >= 0;)e[t] = 0 } function A (e) { const t = e.state; let n = t.pending; n > e.avail_out && (n = e.avail_out), n !== 0 && (i.arraySet(e.output, t.pending_buf, t.pending_out, n, e.next_out), e.next_out += n, t.pending_out += n, e.total_out += n, e.avail_out -= n, t.pending -= n, t.pending === 0 && (t.pending_out = 0)) } function N (e, t) { a._tr_flush_block(e, e.block_start >= 0 ? e.block_start : -1, e.strstart - e.block_start, t), e.block_start = e.strstart, A(e.strm) } function z (e, t) { e.pending_buf[e.pending++] = t } function V (e, t) { e.pending_buf[e.pending++] = t >>> 8 & 255, e.pending_buf[e.pending++] = 255 & t } function F (e, t) { let n; let r; let i = e.max_chain_length; let a = e.strstart; let o = e.prev_length; let s = e.nice_match; const u = e.strstart > e.w_size - E ? e.strstart - (e.w_size - E) : 0; const l = e.window; const c = e.w_mask; const d = e.prev; const f = e.strstart + x; let h = l[a + o - 1]; let p = l[a + o]; e.prev_length >= e.good_match && (i >>= 2), s > e.lookahead && (s = e.lookahead); do { if (l[(n = t) + o] === p && l[n + o - 1] === h && l[n] === l[a] && l[++n] === l[a + 1]) { a += 2, n++; do {} while (l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && l[++a] === l[++n] && a < f); if (r = x - (f - a), a = f - x, o < r) { if (e.match_start = t, s <= (o = r)) break; h = l[a + o - 1], p = l[a + o] } } } while ((t = d[t & c]) > u && --i != 0); return o <= e.lookahead ? o : e.lookahead } function H (e) { let t; let n; let r; let a; let u; let l; let c; let d; let f; let h; const p = e.w_size; do { if (a = e.window_size - e.lookahead - e.strstart, e.strstart >= p + (p - E)) { for (i.arraySet(e.window, e.window, p, p, 0), e.match_start -= p, e.strstart -= p, e.block_start -= p, t = n = e.hash_size; r = e.head[--t], e.head[t] = p <= r ? r - p : 0, --n;);for (t = n = p; r = e.prev[--t], e.prev[t] = p <= r ? r - p : 0, --n;);a += p } if (e.strm.avail_in === 0) break; if (l = e.strm, c = e.window, d = e.strstart + e.lookahead, h = void 0, (f = a) < (h = l.avail_in) && (h = f), n = h === 0 ? 0 : (l.avail_in -= h, i.arraySet(c, l.input, l.next_in, h, d), l.state.wrap === 1 ? l.adler = o(l.adler, c, h, d) : l.state.wrap === 2 && (l.adler = s(l.adler, c, h, d)), l.next_in += h, l.total_in += h, h), e.lookahead += n, e.lookahead + e.insert >= _) for (u = e.strstart - e.insert, e.ins_h = e.window[u], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[u + 1]) & e.hash_mask; e.insert && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[u + _ - 1]) & e.hash_mask, e.prev[u & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = u, u++, e.insert--, !(e.lookahead + e.insert < _));); } while (e.lookahead < E && e.strm.avail_in !== 0) } function U (e, t) { for (var n, r; ;) { if (e.lookahead < E) { if (H(e), e.lookahead < E && t === l) return k; if (e.lookahead === 0) break } if (n = 0, e.lookahead >= _ && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _ - 1]) & e.hash_mask, n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), n !== 0 && e.strstart - n <= e.w_size - E && (e.match_length = F(e, n)), e.match_length >= _) if (r = a._tr_tally(e, e.strstart - e.match_start, e.match_length - _), e.lookahead -= e.match_length, e.match_length <= e.max_lazy_match && e.lookahead >= _) { for (e.match_length--; e.strstart++, e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _ - 1]) & e.hash_mask, n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart, --e.match_length != 0;);e.strstart++ } else e.strstart += e.match_length, e.match_length = 0, e.ins_h = e.window[e.strstart], e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + 1]) & e.hash_mask; else r = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++; if (r && (N(e, !1), e.strm.avail_out === 0)) return k } return e.insert = e.strstart < _ - 1 ? e.strstart : _ - 1, t === c ? (N(e, !0), e.strm.avail_out === 0 ? M : D) : e.last_lit && (N(e, !1), e.strm.avail_out === 0) ? k : L } function X (e, t) { for (var n, r, i; ;) { if (e.lookahead < E) { if (H(e), e.lookahead < E && t === l) return k; if (e.lookahead === 0) break } if (n = 0, e.lookahead >= _ && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _ - 1]) & e.hash_mask, n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), e.prev_length = e.match_length, e.prev_match = e.match_start, e.match_length = _ - 1, n !== 0 && e.prev_length < e.max_lazy_match && e.strstart - n <= e.w_size - E && (e.match_length = F(e, n), e.match_length <= 5 && (e.strategy === 1 || e.match_length === _ && e.strstart - e.match_start > 4096) && (e.match_length = _ - 1)), e.prev_length >= _ && e.match_length <= e.prev_length) { for (i = e.strstart + e.lookahead - _, r = a._tr_tally(e, e.strstart - 1 - e.prev_match, e.prev_length - _), e.lookahead -= e.prev_length - 1, e.prev_length -= 2; ++e.strstart <= i && (e.ins_h = (e.ins_h << e.hash_shift ^ e.window[e.strstart + _ - 1]) & e.hash_mask, n = e.prev[e.strstart & e.w_mask] = e.head[e.ins_h], e.head[e.ins_h] = e.strstart), --e.prev_length != 0;);if (e.match_available = 0, e.match_length = _ - 1, e.strstart++, r && (N(e, !1), e.strm.avail_out === 0)) return k } else if (e.match_available) { if ((r = a._tr_tally(e, 0, e.window[e.strstart - 1])) && N(e, !1), e.strstart++, e.lookahead--, e.strm.avail_out === 0) return k } else e.match_available = 1, e.strstart++, e.lookahead-- } return e.match_available && (r = a._tr_tally(e, 0, e.window[e.strstart - 1]), e.match_available = 0), e.insert = e.strstart < _ - 1 ? e.strstart : _ - 1, t === c ? (N(e, !0), e.strm.avail_out === 0 ? M : D) : e.last_lit && (N(e, !1), e.strm.avail_out === 0) ? k : L } function j (e, t, n, r, i) { this.good_length = e, this.max_lazy = t, this.nice_length = n, this.max_chain = r, this.func = i } function q () { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = m, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new i.Buf16(2 * T), this.dyn_dtree = new i.Buf16(2 * (2 * w + 1)), this.bl_tree = new i.Buf16(2 * (2 * b + 1)), R(this.dyn_ltree), R(this.dyn_dtree), R(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new i.Buf16(S + 1), this.heap = new i.Buf16(2 * y + 1), R(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new i.Buf16(2 * y + 1), R(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } function B (e) { let t; return e && e.state ? (e.total_in = e.total_out = 0, e.data_type = g, (t = e.state).pending = 0, t.pending_out = 0, t.wrap < 0 && (t.wrap = -t.wrap), t.status = t.wrap ? C : O, e.adler = t.wrap === 2 ? 0 : 1, t.last_flush = l, a._tr_init(t), d) : I(e, f) } function Y (e) { let t; const n = B(e); return n === d && ((t = e.state).window_size = 2 * t.w_size, R(t.head), t.max_lazy_match = r[t.level].max_lazy, t.good_match = r[t.level].good_length, t.nice_match = r[t.level].nice_length, t.max_chain_length = r[t.level].max_chain, t.strstart = 0, t.block_start = 0, t.lookahead = 0, t.insert = 0, t.match_length = t.prev_length = _ - 1, t.match_available = 0, t.ins_h = 0), n } function W (e, t, n, r, a, o) { if (!e) return f; let s = 1; if (t === h && (t = 6), r < 0 ? (s = 0, r = -r) : r > 15 && (s = 2, r -= 16), a < 1 || v < a || n !== m || r < 8 || r > 15 || t < 0 || t > 9 || o < 0 || p < o) return I(e, f); r === 8 && (r = 9); const u = new q(); return (e.state = u).strm = e, u.wrap = s, u.gzhead = null, u.w_bits = r, u.w_size = 1 << u.w_bits, u.w_mask = u.w_size - 1, u.hash_bits = a + 7, u.hash_size = 1 << u.hash_bits, u.hash_mask = u.hash_size - 1, u.hash_shift = ~~((u.hash_bits + _ - 1) / _), u.window = new i.Buf8(2 * u.w_size), u.head = new i.Buf16(u.hash_size), u.prev = new i.Buf16(u.w_size), u.lit_bufsize = 1 << a + 6, u.pending_buf_size = 4 * u.lit_bufsize, u.pending_buf = new i.Buf8(u.pending_buf_size), u.d_buf = 1 * u.lit_bufsize, u.l_buf = 3 * u.lit_bufsize, u.level = t, u.strategy = o, u.method = n, Y(e) }r = [new j(0, 0, 0, 0, function (e, t) { let n = 65535; for (n > e.pending_buf_size - 5 && (n = e.pending_buf_size - 5); ;) { if (e.lookahead <= 1) { if (H(e), e.lookahead === 0 && t === l) return k; if (e.lookahead === 0) break }e.strstart += e.lookahead, e.lookahead = 0; const r = e.block_start + n; if ((e.strstart === 0 || e.strstart >= r) && (e.lookahead = e.strstart - r, e.strstart = r, N(e, !1), e.strm.avail_out === 0)) return k; if (e.strstart - e.block_start >= e.w_size - E && (N(e, !1), e.strm.avail_out === 0)) return k } return e.insert = 0, t === c ? (N(e, !0), e.strm.avail_out === 0 ? M : D) : (e.strstart > e.block_start && (N(e, !1), e.strm.avail_out), k) }), new j(4, 4, 8, 4, U), new j(4, 5, 16, 8, U), new j(4, 6, 32, 32, U), new j(4, 4, 16, 16, X), new j(8, 16, 32, 32, X), new j(8, 16, 128, 128, X), new j(8, 32, 128, 256, X), new j(32, 128, 258, 1024, X), new j(32, 258, 258, 4096, X)], n.deflateInit = function (e, t) { return W(e, t, m, 15, 8, 0) }, n.deflateInit2 = W, n.deflateReset = Y, n.deflateResetKeep = B, n.deflateSetHeader = function (e, t) { return e && e.state ? e.state.wrap !== 2 ? f : (e.state.gzhead = t, d) : f }, n.deflate = function (e, t) { let n, i, o, u; if (!e || !e.state || t > 5 || t < 0) return e ? I(e, f) : f; if (i = e.state, !e.output || !e.input && e.avail_in !== 0 || i.status === 666 && t !== c) return I(e, e.avail_out === 0 ? -5 : f); if (i.strm = e, n = i.last_flush, i.last_flush = t, i.status === C) if (i.wrap === 2)e.adler = 0, z(i, 31), z(i, 139), z(i, 8), i.gzhead ? (z(i, (i.gzhead.text ? 1 : 0) + (i.gzhead.hcrc ? 2 : 0) + (i.gzhead.extra ? 4 : 0) + (i.gzhead.name ? 8 : 0) + (i.gzhead.comment ? 16 : 0)), z(i, 255 & i.gzhead.time), z(i, i.gzhead.time >> 8 & 255), z(i, i.gzhead.time >> 16 & 255), z(i, i.gzhead.time >> 24 & 255), z(i, i.level === 9 ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), z(i, 255 & i.gzhead.os), i.gzhead.extra && i.gzhead.extra.length && (z(i, 255 & i.gzhead.extra.length), z(i, i.gzhead.extra.length >> 8 & 255)), i.gzhead.hcrc && (e.adler = s(e.adler, i.pending_buf, i.pending, 0)), i.gzindex = 0, i.status = 69) : (z(i, 0), z(i, 0), z(i, 0), z(i, 0), z(i, 0), z(i, i.level === 9 ? 2 : i.strategy >= 2 || i.level < 2 ? 4 : 0), z(i, 3), i.status = O); else { let h = m + (i.w_bits - 8 << 4) << 8; h |= (i.strategy >= 2 || i.level < 2 ? 0 : i.level < 6 ? 1 : i.level === 6 ? 2 : 3) << 6, i.strstart !== 0 && (h |= 32), h += 31 - h % 31, i.status = O, V(i, h), i.strstart !== 0 && (V(i, e.adler >>> 16), V(i, 65535 & e.adler)), e.adler = 1 } if (i.status === 69) if (i.gzhead.extra) { for (o = i.pending; i.gzindex < (65535 & i.gzhead.extra.length) && (i.pending !== i.pending_buf_size || (i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), A(e), o = i.pending, i.pending !== i.pending_buf_size));)z(i, 255 & i.gzhead.extra[i.gzindex]), i.gzindex++; i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), i.gzindex === i.gzhead.extra.length && (i.gzindex = 0, i.status = 73) } else i.status = 73; if (i.status === 73) if (i.gzhead.name) { o = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), A(e), o = i.pending, i.pending === i.pending_buf_size)) { u = 1; break }z(i, u = i.gzindex < i.gzhead.name.length ? 255 & i.gzhead.name.charCodeAt(i.gzindex++) : 0) } while (u !== 0); i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), u === 0 && (i.gzindex = 0, i.status = 91) } else i.status = 91; if (i.status === 91) if (i.gzhead.comment) { o = i.pending; do { if (i.pending === i.pending_buf_size && (i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), A(e), o = i.pending, i.pending === i.pending_buf_size)) { u = 1; break }z(i, u = i.gzindex < i.gzhead.comment.length ? 255 & i.gzhead.comment.charCodeAt(i.gzindex++) : 0) } while (u !== 0); i.gzhead.hcrc && i.pending > o && (e.adler = s(e.adler, i.pending_buf, i.pending - o, o)), u === 0 && (i.status = 103) } else i.status = 103; if (i.status === 103 && (i.gzhead.hcrc ? (i.pending + 2 > i.pending_buf_size && A(e), i.pending + 2 <= i.pending_buf_size && (z(i, 255 & e.adler), z(i, e.adler >> 8 & 255), e.adler = 0, i.status = O)) : i.status = O), i.pending !== 0) { if (A(e), e.avail_out === 0) return i.last_flush = -1, d } else if (e.avail_in === 0 && P(t) <= P(n) && t !== c) return I(e, -5); if (i.status === 666 && e.avail_in !== 0) return I(e, -5); if (e.avail_in !== 0 || i.lookahead !== 0 || t !== l && i.status !== 666) { const p = i.strategy === 2 ? (function (e, t) { for (var n; ;) { if (e.lookahead === 0 && (H(e), e.lookahead === 0)) { if (t === l) return k; break } if (e.match_length = 0, n = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++, n && (N(e, !1), e.strm.avail_out === 0)) return k } return e.insert = 0, t === c ? (N(e, !0), e.strm.avail_out === 0 ? M : D) : e.last_lit && (N(e, !1), e.strm.avail_out === 0) ? k : L }(i, t)) : i.strategy === 3 ? (function (e, t) { for (var n, r, i, o, s = e.window; ;) { if (e.lookahead <= x) { if (H(e), e.lookahead <= x && t === l) return k; if (e.lookahead === 0) break } if (e.match_length = 0, e.lookahead >= _ && e.strstart > 0 && (r = s[i = e.strstart - 1]) === s[++i] && r === s[++i] && r === s[++i]) { o = e.strstart + x; do {} while (r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && r === s[++i] && i < o); e.match_length = x - (o - i), e.match_length > e.lookahead && (e.match_length = e.lookahead) } if (e.match_length >= _ ? (n = a._tr_tally(e, 1, e.match_length - _), e.lookahead -= e.match_length, e.strstart += e.match_length, e.match_length = 0) : (n = a._tr_tally(e, 0, e.window[e.strstart]), e.lookahead--, e.strstart++), n && (N(e, !1), e.strm.avail_out === 0)) return k } return e.insert = 0, t === c ? (N(e, !0), e.strm.avail_out === 0 ? M : D) : e.last_lit && (N(e, !1), e.strm.avail_out === 0) ? k : L }(i, t)) : r[i.level].func(i, t); if (p !== M && p !== D || (i.status = 666), p === k || p === M) return e.avail_out === 0 && (i.last_flush = -1), d; if (p === L && (t === 1 ? a._tr_align(i) : t !== 5 && (a._tr_stored_block(i, 0, 0, !1), t === 3 && (R(i.head), i.lookahead === 0 && (i.strstart = 0, i.block_start = 0, i.insert = 0))), A(e), e.avail_out === 0)) return i.last_flush = -1, d } return t !== c ? d : i.wrap <= 0 ? 1 : (i.wrap === 2 ? (z(i, 255 & e.adler), z(i, e.adler >> 8 & 255), z(i, e.adler >> 16 & 255), z(i, e.adler >> 24 & 255), z(i, 255 & e.total_in), z(i, e.total_in >> 8 & 255), z(i, e.total_in >> 16 & 255), z(i, e.total_in >> 24 & 255)) : (V(i, e.adler >>> 16), V(i, 65535 & e.adler)), A(e), i.wrap > 0 && (i.wrap = -i.wrap), i.pending !== 0 ? d : 1) }, n.deflateEnd = function (e) { let t; return e && e.state ? (t = e.state.status) !== C && t !== 69 && t !== 73 && t !== 91 && t !== 103 && t !== O && t !== 666 ? I(e, f) : (e.state = null, t === O ? I(e, -3) : d) : f }, n.deflateSetDictionary = function (e, t) { let n; let r; let a; let s; let u; let l; let c; let h; let p = t.length; if (!e || !e.state) return f; if ((s = (n = e.state).wrap) === 2 || s === 1 && n.status !== C || n.lookahead) return f; for (s === 1 && (e.adler = o(e.adler, t, p, 0)), n.wrap = 0, p >= n.w_size && (s === 0 && (R(n.head), n.strstart = 0, n.block_start = 0, n.insert = 0), h = new i.Buf8(n.w_size), i.arraySet(h, t, p - n.w_size, n.w_size, 0), t = h, p = n.w_size), u = e.avail_in, l = e.next_in, c = e.input, e.avail_in = p, e.next_in = 0, e.input = t, H(n); n.lookahead >= _;) { for (r = n.strstart, a = n.lookahead - (_ - 1); n.ins_h = (n.ins_h << n.hash_shift ^ n.window[r + _ - 1]) & n.hash_mask, n.prev[r & n.w_mask] = n.head[n.ins_h], n.head[n.ins_h] = r, r++, --a;);n.strstart = r, n.lookahead = _ - 1, H(n) } return n.strstart += n.lookahead, n.block_start = n.strstart, n.insert = n.lookahead, n.lookahead = 0, n.match_length = n.prev_length = _ - 1, n.match_available = 0, e.next_in = l, e.input = c, e.avail_in = u, n.wrap = s, d }, n.deflateInfo = 'pako deflate (from Nodeca project)' }, { '../utils/common': 1, './adler32': 3, './crc32': 4, './messages': 6, './trees': 7 }], 6: [function (e, t, n) { t.exports = { 2: 'need dictionary', 1: 'stream end', 0: '', '-1': 'file error', '-2': 'stream error', '-3': 'data error', '-4': 'insufficient memory', '-5': 'buffer error', '-6': 'incompatible version' } }, {}], 7: [function (e, t, n) { const r = e('../utils/common'); const i = 0; const a = 1; function o (e) { for (let t = e.length; --t >= 0;)e[t] = 0 } const s = 0; const u = 29; const l = 256; const c = l + 1 + u; const d = 30; const f = 19; const h = 2 * c + 1; const p = 15; const g = 16; const m = 7; const v = 256; const y = 16; const w = 17; const b = 18; const T = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]; const S = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]; const _ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]; const x = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]; const E = new Array(2 * (c + 2)); o(E); const C = new Array(2 * d); o(C); const O = new Array(512); o(O); const k = new Array(256); o(k); const L = new Array(u); o(L); let M; let D; let I; const P = new Array(d); function R (e, t, n, r, i) { this.static_tree = e, this.extra_bits = t, this.extra_base = n, this.elems = r, this.max_length = i, this.has_stree = e && e.length } function A (e, t) { this.dyn_tree = e, this.max_code = 0, this.stat_desc = t } function N (e) { return e < 256 ? O[e] : O[256 + (e >>> 7)] } function z (e, t) { e.pending_buf[e.pending++] = 255 & t, e.pending_buf[e.pending++] = t >>> 8 & 255 } function V (e, t, n) { e.bi_valid > g - n ? (e.bi_buf |= t << e.bi_valid & 65535, z(e, e.bi_buf), e.bi_buf = t >> g - e.bi_valid, e.bi_valid += n - g) : (e.bi_buf |= t << e.bi_valid & 65535, e.bi_valid += n) } function F (e, t, n) { V(e, n[2 * t], n[2 * t + 1]) } function H (e, t) { for (var n = 0; n |= 1 & e, e >>>= 1, n <<= 1, --t > 0;);return n >>> 1 } function U (e, t, n) { let r; let i; const a = new Array(p + 1); let o = 0; for (r = 1; r <= p; r++)a[r] = o = o + n[r - 1] << 1; for (i = 0; i <= t; i++) { const s = e[2 * i + 1]; s !== 0 && (e[2 * i] = H(a[s]++, s)) } } function X (e) { let t; for (t = 0; t < c; t++)e.dyn_ltree[2 * t] = 0; for (t = 0; t < d; t++)e.dyn_dtree[2 * t] = 0; for (t = 0; t < f; t++)e.bl_tree[2 * t] = 0; e.dyn_ltree[2 * v] = 1, e.opt_len = e.static_len = 0, e.last_lit = e.matches = 0 } function j (e) { e.bi_valid > 8 ? z(e, e.bi_buf) : e.bi_valid > 0 && (e.pending_buf[e.pending++] = e.bi_buf), e.bi_buf = 0, e.bi_valid = 0 } function q (e, t, n, r) { const i = 2 * t; const a = 2 * n; return e[i] < e[a] || e[i] === e[a] && r[t] <= r[n] } function B (e, t, n) { for (var r = e.heap[n], i = n << 1; i <= e.heap_len && (i < e.heap_len && q(t, e.heap[i + 1], e.heap[i], e.depth) && i++, !q(t, r, e.heap[i], e.depth));)e.heap[n] = e.heap[i], n = i, i <<= 1; e.heap[n] = r } function Y (e, t, n) { let r; let i; let a; let o; let s = 0; if (e.last_lit !== 0) for (;r = e.pending_buf[e.d_buf + 2 * s] << 8 | e.pending_buf[e.d_buf + 2 * s + 1], i = e.pending_buf[e.l_buf + s], s++, r === 0 ? F(e, i, t) : (F(e, (a = k[i]) + l + 1, t), (o = T[a]) !== 0 && V(e, i -= L[a], o), F(e, a = N(--r), n), (o = S[a]) !== 0 && V(e, r -= P[a], o)), s < e.last_lit;);F(e, v, t) } function W (e, t) { let n; let r; let i; const a = t.dyn_tree; const o = t.stat_desc.static_tree; const s = t.stat_desc.has_stree; const u = t.stat_desc.elems; let l = -1; for (e.heap_len = 0, e.heap_max = h, n = 0; n < u; n++)a[2 * n] !== 0 ? (e.heap[++e.heap_len] = l = n, e.depth[n] = 0) : a[2 * n + 1] = 0; for (;e.heap_len < 2;)a[2 * (i = e.heap[++e.heap_len] = l < 2 ? ++l : 0)] = 1, e.depth[i] = 0, e.opt_len--, s && (e.static_len -= o[2 * i + 1]); for (t.max_code = l, n = e.heap_len >> 1; n >= 1; n--)B(e, a, n); for (i = u; n = e.heap[1], e.heap[1] = e.heap[e.heap_len--], B(e, a, 1), r = e.heap[1], e.heap[--e.heap_max] = n, e.heap[--e.heap_max] = r, a[2 * i] = a[2 * n] + a[2 * r], e.depth[i] = (e.depth[n] >= e.depth[r] ? e.depth[n] : e.depth[r]) + 1, a[2 * n + 1] = a[2 * r + 1] = i, e.heap[1] = i++, B(e, a, 1), e.heap_len >= 2;);e.heap[--e.heap_max] = e.heap[1], (function (e, t) { let n; let r; let i; let a; let o; let s; const u = t.dyn_tree; const l = t.max_code; const c = t.stat_desc.static_tree; const d = t.stat_desc.has_stree; const f = t.stat_desc.extra_bits; const g = t.stat_desc.extra_base; const m = t.stat_desc.max_length; let v = 0; for (a = 0; a <= p; a++)e.bl_count[a] = 0; for (u[2 * e.heap[e.heap_max] + 1] = 0, n = e.heap_max + 1; n < h; n++)m < (a = u[2 * u[2 * (r = e.heap[n]) + 1] + 1] + 1) && (a = m, v++), u[2 * r + 1] = a, l < r || (e.bl_count[a]++, o = 0, g <= r && (o = f[r - g]), s = u[2 * r], e.opt_len += s * (a + o), d && (e.static_len += s * (c[2 * r + 1] + o))); if (v !== 0) { do { for (a = m - 1; e.bl_count[a] === 0;)a--; e.bl_count[a]--, e.bl_count[a + 1] += 2, e.bl_count[m]--, v -= 2 } while (v > 0); for (a = m; a !== 0; a--) for (r = e.bl_count[a]; r !== 0;)l < (i = e.heap[--n]) || (u[2 * i + 1] !== a && (e.opt_len += (a - u[2 * i + 1]) * u[2 * i], u[2 * i + 1] = a), r--) } }(e, t)), U(a, l, e.bl_count) } function K (e, t, n) { let r; let i; let a = -1; let o = t[1]; let s = 0; let u = 7; let l = 4; for (o === 0 && (u = 138, l = 3), t[2 * (n + 1) + 1] = 65535, r = 0; r <= n; r++)i = o, o = t[2 * (r + 1) + 1], ++s < u && i === o || (s < l ? e.bl_tree[2 * i] += s : i !== 0 ? (i !== a && e.bl_tree[2 * i]++, e.bl_tree[2 * y]++) : s <= 10 ? e.bl_tree[2 * w]++ : e.bl_tree[2 * b]++, a = i, (s = 0) === o ? (u = 138, l = 3) : i === o ? (u = 6, l = 3) : (u = 7, l = 4)) } function Q (e, t, n) { let r; let i; let a = -1; let o = t[1]; let s = 0; let u = 7; let l = 4; for (o === 0 && (u = 138, l = 3), r = 0; r <= n; r++) if (i = o, o = t[2 * (r + 1) + 1], !(++s < u && i === o)) { if (s < l) for (;F(e, i, e.bl_tree), --s != 0;);else i !== 0 ? (i !== a && (F(e, i, e.bl_tree), s--), F(e, y, e.bl_tree), V(e, s - 3, 2)) : s <= 10 ? (F(e, w, e.bl_tree), V(e, s - 3, 3)) : (F(e, b, e.bl_tree), V(e, s - 11, 7)); a = i, (s = 0) === o ? (u = 138, l = 3) : i === o ? (u = 6, l = 3) : (u = 7, l = 4) } }o(P); let J = !1; function G (e, t, n, i) { let a, o, u, l; V(e, (s << 1) + (i ? 1 : 0), 3), o = t, u = n, l = !0, j(a = e), l && (z(a, u), z(a, ~u)), r.arraySet(a.pending_buf, a.window, o, u, a.pending), a.pending += u }n._tr_init = function (e) { J || ((function () { let e; let t; let n; let r; let i; const a = new Array(p + 1); for (r = n = 0; r < u - 1; r++) for (L[r] = n, e = 0; e < 1 << T[r]; e++)k[n++] = r; for (k[n - 1] = r, r = i = 0; r < 16; r++) for (P[r] = i, e = 0; e < 1 << S[r]; e++)O[i++] = r; for (i >>= 7; r < d; r++) for (P[r] = i << 7, e = 0; e < 1 << S[r] - 7; e++)O[256 + i++] = r; for (t = 0; t <= p; t++)a[t] = 0; for (e = 0; e <= 143;)E[2 * e + 1] = 8, e++, a[8]++; for (;e <= 255;)E[2 * e + 1] = 9, e++, a[9]++; for (;e <= 279;)E[2 * e + 1] = 7, e++, a[7]++; for (;e <= 287;)E[2 * e + 1] = 8, e++, a[8]++; for (U(E, c + 1, a), e = 0; e < d; e++)C[2 * e + 1] = 5, C[2 * e] = H(e, 5); M = new R(E, T, l + 1, c, p), D = new R(C, S, 0, d, p), I = new R(new Array(0), _, 0, f, m) }()), J = !0), e.l_desc = new A(e.dyn_ltree, M), e.d_desc = new A(e.dyn_dtree, D), e.bl_desc = new A(e.bl_tree, I), e.bi_buf = 0, e.bi_valid = 0, X(e) }, n._tr_stored_block = G, n._tr_flush_block = function (e, t, n, r) { let o; let s; let u = 0; e.level > 0 ? (e.strm.data_type === 2 && (e.strm.data_type = (function (e) { let t; let n = 4093624447; for (t = 0; t <= 31; t++, n >>>= 1) if (1 & n && e.dyn_ltree[2 * t] !== 0) return i; if (e.dyn_ltree[18] !== 0 || e.dyn_ltree[20] !== 0 || e.dyn_ltree[26] !== 0) return a; for (t = 32; t < l; t++) if (e.dyn_ltree[2 * t] !== 0) return a; return i }(e))), W(e, e.l_desc), W(e, e.d_desc), u = (function (e) { let t; for (K(e, e.dyn_ltree, e.l_desc.max_code), K(e, e.dyn_dtree, e.d_desc.max_code), W(e, e.bl_desc), t = f - 1; t >= 3 && e.bl_tree[2 * x[t] + 1] === 0; t--);return e.opt_len += 3 * (t + 1) + 5 + 5 + 4, t }(e)), o = e.opt_len + 3 + 7 >>> 3, (s = e.static_len + 3 + 7 >>> 3) <= o && (o = s)) : o = s = n + 5, n + 4 <= o && t !== -1 ? G(e, t, n, r) : e.strategy === 4 || s === o ? (V(e, 2 + (r ? 1 : 0), 3), Y(e, E, C)) : (V(e, 4 + (r ? 1 : 0), 3), (function (e, t, n, r) { let i; for (V(e, t - 257, 5), V(e, n - 1, 5), V(e, r - 4, 4), i = 0; i < r; i++)V(e, e.bl_tree[2 * x[i] + 1], 3); Q(e, e.dyn_ltree, t - 1), Q(e, e.dyn_dtree, n - 1) }(e, e.l_desc.max_code + 1, e.d_desc.max_code + 1, u + 1)), Y(e, e.dyn_ltree, e.dyn_dtree)), X(e), r && j(e) }, n._tr_tally = function (e, t, n) { return e.pending_buf[e.d_buf + 2 * e.last_lit] = t >>> 8 & 255, e.pending_buf[e.d_buf + 2 * e.last_lit + 1] = 255 & t, e.pending_buf[e.l_buf + e.last_lit] = 255 & n, e.last_lit++, t === 0 ? e.dyn_ltree[2 * n]++ : (e.matches++, t--, e.dyn_ltree[2 * (k[n] + l + 1)]++, e.dyn_dtree[2 * N(t)]++), e.last_lit === e.lit_bufsize - 1 }, n._tr_align = function (e) { let t; V(e, 2, 3), F(e, v, E), (t = e).bi_valid === 16 ? (z(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) } }, { '../utils/common': 1 }], 8: [function (e, t, n) { t.exports = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = '', this.state = null, this.data_type = 2, this.adler = 0 } }, {}], '/lib/deflate.js': [function (e, t, n) { const r = e('./zlib/deflate'); const i = e('./utils/common'); const a = e('./utils/strings'); const o = e('./zlib/messages'); const s = e('./zlib/zstream'); const u = Object.prototype.toString; const l = 0; const c = -1; const d = 0; const f = 8; function h (e) { if (!(this instanceof h)) return new h(e); this.options = i.assign({ level: c, method: f, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: d, to: '' }, e || {}); const t = this.options; t.raw && t.windowBits > 0 ? t.windowBits = -t.windowBits : t.gzip && t.windowBits > 0 && t.windowBits < 16 && (t.windowBits += 16), this.err = 0, this.msg = '', this.ended = !1, this.chunks = [], this.strm = new s(), this.strm.avail_out = 0; let n = r.deflateInit2(this.strm, t.level, t.method, t.windowBits, t.memLevel, t.strategy); if (n !== l) throw new Error(o[n]); if (t.header && r.deflateSetHeader(this.strm, t.header), t.dictionary) { let p; if (p = typeof t.dictionary === 'string' ? a.string2buf(t.dictionary) : u.call(t.dictionary) === '[object ArrayBuffer]' ? new Uint8Array(t.dictionary) : t.dictionary, (n = r.deflateSetDictionary(this.strm, p)) !== l) throw new Error(o[n]); this._dict_set = !0 } } function p (e, t) { const n = new h(t); if (n.push(e, !0), n.err) throw n.msg || o[n.err]; return n.result }h.prototype.push = function (e, t) { let n; let o; const s = this.strm; const c = this.options.chunkSize; if (this.ended) return !1; o = t === ~~t ? t : !0 === t ? 4 : 0, typeof e === 'string' ? s.input = a.string2buf(e) : u.call(e) === '[object ArrayBuffer]' ? s.input = new Uint8Array(e) : s.input = e, s.next_in = 0, s.avail_in = s.input.length; do { if (s.avail_out === 0 && (s.output = new i.Buf8(c), s.next_out = 0, s.avail_out = c), (n = r.deflate(s, o)) !== 1 && n !== l) return this.onEnd(n), !(this.ended = !0); s.avail_out !== 0 && (s.avail_in !== 0 || o !== 4 && o !== 2) || (this.options.to === 'string' ? this.onData(a.buf2binstring(i.shrinkBuf(s.output, s.next_out))) : this.onData(i.shrinkBuf(s.output, s.next_out))) } while ((s.avail_in > 0 || s.avail_out === 0) && n !== 1); return o === 4 ? (n = r.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === l) : o !== 2 || (this.onEnd(l), !(s.avail_out = 0)) }, h.prototype.onData = function (e) { this.chunks.push(e) }, h.prototype.onEnd = function (e) { e === l && (this.options.to === 'string' ? this.result = this.chunks.join('') : this.result = i.flattenChunks(this.chunks)), this.chunks = [], this.err = e, this.msg = this.strm.msg }, n.Deflate = h, n.deflate = p, n.deflateRaw = function (e, t) { return (t = t || {}).raw = !0, p(e, t) }, n.gzip = function (e, t) { return (t = t || {}).gzip = !0, p(e, t) } }, { './utils/common': 1, './utils/strings': 2, './zlib/deflate': 5, './zlib/messages': 6, './zlib/zstream': 8 }] }, {}, []))('/lib/deflate.js'), typeof Hammer === 'function' && void 0 !== Hammer ? console && console.info('Hammer:' + Hammer.VERSION + ' is already loaded. But you need 1.1.3.') : (function (e, t) { const n = function e (t, n) { return new e.Instance(t, n || {}) }; n.VERSION = '1.1.3', n.defaults = { behavior: { userSelect: 'none', touchAction: 'pan-y', touchCallout: 'none', contentZooming: 'none', userDrag: 'none', tapHighlightColor: 'rgba(0,0,0,0)' } }, n.DOCUMENT = document, n.HAS_POINTEREVENTS = navigator.pointerEnabled || navigator.msPointerEnabled, n.HAS_TOUCHEVENTS = 'ontouchstart' in e, n.IS_MOBILE = /mobile|tablet|ip(ad|hone|od)|android|silk/i.test(navigator.userAgent), n.NO_MOUSEEVENTS = n.HAS_TOUCHEVENTS && n.IS_MOBILE || n.HAS_POINTEREVENTS, n.CALCULATE_INTERVAL = 25; const r = {}; const i = n.DIRECTION_DOWN = 'down'; const a = n.DIRECTION_LEFT = 'left'; const o = n.DIRECTION_UP = 'up'; const s = n.DIRECTION_RIGHT = 'right'; const u = n.POINTER_MOUSE = 'mouse'; const l = n.POINTER_TOUCH = 'touch'; const c = n.POINTER_PEN = 'pen'; const d = n.EVENT_START = 'start'; const f = n.EVENT_MOVE = 'move'; const h = n.EVENT_END = 'end'; const p = n.EVENT_RELEASE = 'release'; const g = n.EVENT_TOUCH = 'touch'; n.READY = !1, n.plugins = n.plugins || {}, n.gestures = n.gestures || {}; var m = n.utils = { extend: function (e, n, r) { for (const i in n)!n.hasOwnProperty(i) || e[i] !== t && r || (e[i] = n[i]); return e }, on: function (e, t, n) { e.addEventListener(t, n, !1) }, off: function (e, t, n) { e.removeEventListener(t, n, !1) }, each: function (e, n, r) { let i, a; if ('forEach' in e)e.forEach(n, r); else if (e.length !== t) { for (i = 0, a = e.length; a > i; i++) if (!1 === n.call(r, e[i], i, e)) return } else for (i in e) if (e.hasOwnProperty(i) && !1 === n.call(r, e[i], i, e)) return }, inStr: function (e, t) { return e.indexOf(t) > -1 }, inArray: function (e, t) { if (e.indexOf) { const n = e.indexOf(t); return n !== -1 && n } for (let r = 0, i = e.length; i > r; r++) if (e[r] === t) return r; return !1 }, toArray: function (e) { return Array.prototype.slice.call(e, 0) }, hasParent: function (e, t) { for (;e;) { if (e == t) return !0; e = e.parentNode } return !1 }, getCenter: function (e) { const t = []; const n = []; const r = []; const i = []; const a = Math.min; const o = Math.max; return e.length === 1 ? { pageX: e[0].pageX, pageY: e[0].pageY, clientX: e[0].clientX, clientY: e[0].clientY } : (m.each(e, function (e) { t.push(e.pageX), n.push(e.pageY), r.push(e.clientX), i.push(e.clientY) }), { pageX: (a.apply(Math, t) + o.apply(Math, t)) / 2, pageY: (a.apply(Math, n) + o.apply(Math, n)) / 2, clientX: (a.apply(Math, r) + o.apply(Math, r)) / 2, clientY: (a.apply(Math, i) + o.apply(Math, i)) / 2 }) }, getVelocity: function (e, t, n) { return { x: Math.abs(t / e) || 0, y: Math.abs(n / e) || 0 } }, getAngle: function (e, t) { const n = t.clientX - e.clientX; const r = t.clientY - e.clientY; return 180 * Math.atan2(r, n) / Math.PI }, getDirection: function (e, t) { return Math.abs(e.clientX - t.clientX) >= Math.abs(e.clientY - t.clientY) ? e.clientX - t.clientX > 0 ? a : s : e.clientY - t.clientY > 0 ? o : i }, getDistance: function (e, t) { const n = t.clientX - e.clientX; const r = t.clientY - e.clientY; return Math.sqrt(n * n + r * r) }, getScale: function (e, t) { return e.length >= 2 && t.length >= 2 ? this.getDistance(t[0], t[1]) / this.getDistance(e[0], e[1]) : 1 }, getRotation: function (e, t) { return e.length >= 2 && t.length >= 2 ? this.getAngle(t[1], t[0]) - this.getAngle(e[1], e[0]) : 0 }, isVertical: function (e) { return e == o || e == i }, setPrefixedCss: function (e, t, n, r) { const i = ['', 'Webkit', 'Moz', 'O', 'ms']; t = m.toCamelCase(t); for (let a = 0; a < i.length; a++) { let o = t; if (i[a] && (o = i[a] + o.slice(0, 1).toUpperCase() + o.slice(1)), o in e.style) { e.style[o] = (r == null || r) && n || ''; break } } }, toggleBehavior: function (e, t, n) { if (t && e && e.style) { m.each(t, function (t, r) { m.setPrefixedCss(e, r, t, n) }); const r = n && function () { return !1 }; t.userSelect == 'none' && (e.onselectstart = r), t.userDrag == 'none' && (e.ondragstart = r) } }, toCamelCase: function (e) { return e.replace(/[_-]([a-z])/g, function (e) { return e[1].toUpperCase() }) } }; const v = n.event = { preventMouseEvents: !1, started: !1, shouldDetect: !1, on: function (e, t, n, r) { const i = t.split(' '); m.each(i, function (t) { m.on(e, t, n), r && r(t) }) }, off: function (e, t, n, r) { const i = t.split(' '); m.each(i, function (t) { m.off(e, t, n), r && r(t) }) }, onTouch: function (e, t, i) { const a = this; const o = function (r) { let o; const s = r.type.toLowerCase(); const u = n.HAS_POINTEREVENTS; const c = m.inStr(s, 'mouse'); c && a.preventMouseEvents || (c && t == d && r.button === 0 ? (a.preventMouseEvents = !1, a.shouldDetect = !0) : u && t == d ? a.shouldDetect = r.buttons === 1 || y.matchType(l, r) : c || t != d || (a.preventMouseEvents = !0, a.shouldDetect = !0), u && t != h && y.updatePointer(t, r), a.shouldDetect && (o = a.doDetect.call(a, r, t, e, i)), o == h && (a.preventMouseEvents = !1, a.shouldDetect = !1, y.reset()), u && t == h && y.updatePointer(t, r)) }; return this.on(e, r[t], o), o }, doDetect: function (e, t, n, r) { const i = this.getTouchList(e, t); const a = i.length; let o = t; let s = i.trigger; let u = a; t == d ? s = g : t == h && (s = p, u = i.length - (e.changedTouches ? e.changedTouches.length : 1)), u > 0 && this.started && (o = f), this.started = !0; const l = this.collectEventData(n, o, i, e); return t != h && r.call(w, l), s && (l.changedLength = u, l.eventType = s, r.call(w, l), l.eventType = o, delete l.changedLength), o == h && (r.call(w, l), this.started = !1), o }, determineEventTypes: function () { let t; return t = n.HAS_POINTEREVENTS ? e.PointerEvent ? ['pointerdown', 'pointermove', 'pointerup pointercancel lostpointercapture'] : ['MSPointerDown', 'MSPointerMove', 'MSPointerUp MSPointerCancel MSLostPointerCapture'] : n.NO_MOUSEEVENTS ? ['touchstart', 'touchmove', 'touchend touchcancel'] : ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'], r[d] = t[0], r[f] = t[1], r[h] = t[2], r }, getTouchList: function (e, t) { if (n.HAS_POINTEREVENTS) return y.getTouchList(); if (e.touches) { if (t == f) return e.touches; const r = []; const i = [].concat(m.toArray(e.touches), m.toArray(e.changedTouches)); const a = []; return m.each(i, function (e) { !1 === m.inArray(r, e.identifier) && a.push(e), r.push(e.identifier) }), a } return e.identifier = 1, [e] }, collectEventData: function (e, t, n, r) { let i = l; return m.inStr(r.type, 'mouse') || y.matchType(u, r) ? i = u : y.matchType(c, r) && (i = c), { center: m.getCenter(n), timeStamp: Date.now(), target: r.target, touches: n, eventType: t, pointerType: i, srcEvent: r, preventDefault: function () { const e = this.srcEvent; e.preventManipulation && e.preventManipulation(), e.preventDefault && e.preventDefault() }, stopPropagation: function () { this.srcEvent.stopPropagation() }, stopDetect: function () { return w.stopDetect() } } } }; var y = n.PointerEvent = { pointers: {}, getTouchList: function () { const e = []; return m.each(this.pointers, function (t) { e.push(t) }), e }, updatePointer: function (e, t) { e == h ? delete this.pointers[t.pointerId] : (t.identifier = t.pointerId, this.pointers[t.pointerId] = t) }, matchType: function (e, t) { if (!t.pointerType) return !1; const n = t.pointerType; const r = {}; return r[u] = n === (t.MSPOINTER_TYPE_MOUSE || u), r[l] = n === (t.MSPOINTER_TYPE_TOUCH || l), r[c] = n === (t.MSPOINTER_TYPE_PEN || c), r[e] }, reset: function () { this.pointers = {} } }; var w = n.detection = { gestures: [], current: null, previous: null, stopped: !1, startDetect: function (e, t) { this.current || (this.stopped = !1, this.current = { inst: e, startEvent: m.extend({}, t), lastEvent: !1, lastCalcEvent: !1, futureCalcEvent: !1, lastCalcData: {}, name: '' }, this.detect(t)) }, detect: function (e) { if (this.current && !this.stopped) { e = this.extendEventData(e); const t = this.current.inst; const n = t.options; return m.each(this.gestures, function (r) { !this.stopped && t.enabled && n[r.name] && r.handler.call(r, e, t) }, this), this.current && (this.current.lastEvent = e), e.eventType == h && this.stopDetect(), e } }, stopDetect: function () { this.previous = m.extend({}, this.current), this.current = null, this.stopped = !0 }, getCalculatedData: function (e, t, r, i, a) { const o = this.current; let s = !1; const u = o.lastCalcEvent; const l = o.lastCalcData; u && e.timeStamp - u.timeStamp > n.CALCULATE_INTERVAL && (t = u.center, r = e.timeStamp - u.timeStamp, i = e.center.clientX - u.center.clientX, a = e.center.clientY - u.center.clientY, s = !0), (e.eventType == g || e.eventType == p) && (o.futureCalcEvent = e), (!o.lastCalcEvent || s) && (l.velocity = m.getVelocity(r, i, a), l.angle = m.getAngle(t, e.center), l.direction = m.getDirection(t, e.center), o.lastCalcEvent = o.futureCalcEvent || e, o.futureCalcEvent = e), e.velocityX = l.velocity.x, e.velocityY = l.velocity.y, e.interimAngle = l.angle, e.interimDirection = l.direction }, extendEventData: function (e) { const t = this.current; const n = t.startEvent; const r = t.lastEvent || n; (e.eventType == g || e.eventType == p) && (n.touches = [], m.each(e.touches, function (e) { n.touches.push({ clientX: e.clientX, clientY: e.clientY }) })); const i = e.timeStamp - n.timeStamp; const a = e.center.clientX - n.center.clientX; const o = e.center.clientY - n.center.clientY; return this.getCalculatedData(e, r.center, i, a, o), m.extend(e, { startEvent: n, deltaTime: i, deltaX: a, deltaY: o, distance: m.getDistance(n.center, e.center), angle: m.getAngle(n.center, e.center), direction: m.getDirection(n.center, e.center), scale: m.getScale(n.touches, e.touches), rotation: m.getRotation(n.touches, e.touches) }), e }, register: function (e) { const r = e.defaults || {}; return r[e.name] === t && (r[e.name] = !0), m.extend(n.defaults, r, !0), e.index = e.index || 1e3, this.gestures.push(e), this.gestures.sort(function (e, t) { return e.index < t.index ? -1 : e.index > t.index ? 1 : 0 }), this.gestures } }; n.Instance = function (e, t) { const r = this; n.READY || (v.determineEventTypes(), m.each(n.gestures, function (e) { w.register(e) }), v.onTouch(n.DOCUMENT, f, w.detect), v.onTouch(n.DOCUMENT, h, w.detect), n.READY = !0), this.element = e, this.enabled = !0, m.each(t, function (e, n) { delete t[n], t[m.toCamelCase(n)] = e }), this.options = m.extend(m.extend({}, n.defaults), t || {}), this.options.behavior && m.toggleBehavior(this.element, this.options.behavior, !0), this.eventStartHandler = v.onTouch(e, d, function (e) { r.enabled && e.eventType == d ? w.startDetect(r, e) : e.eventType == g && w.detect(e) }), this.eventHandlers = [] }, n.Instance.prototype = { on: function (e, t) { const n = this; return v.on(n.element, e, t, function (e) { n.eventHandlers.push({ gesture: e, handler: t }) }), n }, off: function (e, t) { const n = this; return v.off(n.element, e, t, function (e) { const r = m.inArray({ gesture: e, handler: t }); !1 !== r && n.eventHandlers.splice(r, 1) }), n }, trigger: function (e, t) { t || (t = {}); const r = n.DOCUMENT.createEvent('Event'); r.initEvent(e, !0, !0), r.gesture = t; let i = this.element; return m.hasParent(t.target, i) && (i = t.target), i.dispatchEvent(r), this }, enable: function (e) { return this.enabled = e, this }, dispose: function () { let e, t; for (m.toggleBehavior(this.element, this.options.behavior, !1), e = -1; t = this.eventHandlers[++e];)m.off(this.element, t.gesture, t.handler); return this.eventHandlers = [], v.off(this.element, r[d], this.eventStartHandler), null } }, (function (e) { let t = !1; n.gestures.Drag = { name: e, index: 50, handler: function (n, r) { const u = w.current; if (!(r.options.dragMaxTouches > 0 && n.touches.length > r.options.dragMaxTouches)) switch (n.eventType) { case d:t = !1; break; case f:if (n.distance < r.options.dragMinDistance && u.name != e) return; var l = u.startEvent.center; if (u.name != e && (u.name = e, r.options.dragDistanceCorrection && n.distance > 0)) { const c = Math.abs(r.options.dragMinDistance / n.distance); l.pageX += n.deltaX * c, l.pageY += n.deltaY * c, l.clientX += n.deltaX * c, l.clientY += n.deltaY * c, n = w.extendEventData(n) }(u.lastEvent.dragLockToAxis || r.options.dragLockToAxis && r.options.dragLockMinDistance <= n.distance) && (n.dragLockToAxis = !0); var g = u.lastEvent.direction; n.dragLockToAxis && g !== n.direction && (n.direction = m.isVertical(g) ? n.deltaY < 0 ? o : i : n.deltaX < 0 ? a : s), t || (r.trigger(e + 'start', n), t = !0), r.trigger(e, n), r.trigger(e + n.direction, n); var v = m.isVertical(n.direction); (r.options.dragBlockVertical && v || r.options.dragBlockHorizontal && !v) && n.preventDefault(); break; case p:t && n.changedLength <= r.options.dragMaxTouches && (r.trigger(e + 'end', n), t = !1); break; case h:t = !1 } }, defaults: { dragMinDistance: 10, dragDistanceCorrection: !0, dragMaxTouches: 1, dragBlockHorizontal: !1, dragBlockVertical: !1, dragLockToAxis: !1, dragLockMinDistance: 25 } } }('drag')), n.gestures.Gesture = { name: 'gesture', index: 1337, handler: function (e, t) { t.trigger(this.name, e) } }, (function (e) { let t; n.gestures.Hold = { name: e, index: 10, defaults: { holdTimeout: 500, holdThreshold: 2 }, handler: function (n, r) { const i = r.options; const a = w.current; switch (n.eventType) { case d:clearTimeout(t), a.name = e, t = setTimeout(function () { a && a.name == e && r.trigger(e, n) }, i.holdTimeout); break; case f:n.distance > i.holdThreshold && clearTimeout(t); break; case p:clearTimeout(t) } } } }('hold')), n.gestures.Release = { name: 'release', index: 1 / 0, handler: function (e, t) { e.eventType == p && t.trigger(this.name, e) } }, n.gestures.Swipe = { name: 'swipe', index: 40, defaults: { swipeMinTouches: 1, swipeMaxTouches: 1, swipeVelocityX: 0.6, swipeVelocityY: 0.6 }, handler: function (e, t) { if (e.eventType == p) { const n = e.touches.length; const r = t.options; if (n < r.swipeMinTouches || n > r.swipeMaxTouches) return; (e.velocityX > r.swipeVelocityX || e.velocityY > r.swipeVelocityY) && (t.trigger(this.name, e), t.trigger(this.name + e.direction, e)) } } }, (function (e) { let t = !1; n.gestures.Tap = { name: e, index: 100, handler: function (n, r) { let i; let a; const o = r.options; const s = w.current; const u = w.previous; switch (n.eventType) { case d:t = !1; break; case f:t = t || n.distance > o.tapMaxDistance; break; case h:!m.inStr(n.srcEvent.type, 'cancel') && n.deltaTime < o.tapMaxTime && !t && (i = u && u.lastEvent && n.timeStamp - u.lastEvent.timeStamp, a = !1, u && u.name == e && i && i < o.doubleTapInterval && n.distance < o.doubleTapDistance && (r.trigger('doubletap', n), a = !0), (!a || o.tapAlways) && (s.name = e, r.trigger(s.name, n))) } }, defaults: { tapMaxTime: 250, tapMaxDistance: 10, tapAlways: !0, doubleTapDistance: 20, doubleTapInterval: 300 } } }('tap')), n.gestures.Touch = { name: 'touch', index: -1 / 0, defaults: { preventDefault: !1, preventMouse: !1 }, handler: function (e, t) { return t.options.preventMouse && e.pointerType == u ? void e.stopDetect() : (t.options.preventDefault && e.preventDefault(), void (e.eventType == g && t.trigger('touch', e))) } }, (function (e) { let t = !1; n.gestures.Transform = { name: e, index: 45, defaults: { transformMinScale: 0.01, transformMinRotation: 1 }, handler: function (n, r) { switch (n.eventType) { case d:t = !1; break; case f:if (n.touches.length < 2) return; var i = Math.abs(1 - n.scale); var a = Math.abs(n.rotation); if (i < r.options.transformMinScale && a < r.options.transformMinRotation) return; w.current.name = e, t || (r.trigger(e + 'start', n), t = !0), r.trigger(e, n), a > r.options.transformMinRotation && r.trigger('rotate', n), i > r.options.transformMinScale && (r.trigger('pinch', n), r.trigger('pinch' + (n.scale < 1 ? 'in' : 'out'), n)); break; case p:t && n.changedLength < 2 && (r.trigger(e + 'end', n), t = !1) } } } }('transform')), typeof define === 'function' && define.amd ? define(function () { return n }) : typeof module !== 'undefined' && module.exports ? module.exports = n : e.Hammer = n }(window)), Hammer && Hammer.VERSION == '1.1.3' ? TLT.addModule('gestures', function (e) { let t; let n; let r; let i; const a = { 'input:radio': 'radioButton', 'input:checkbox': 'checkBox', 'input:text': 'textBox', 'input:password': 'textBox', 'input:file': 'fileInput', 'input:button': 'button', 'input:submit': 'submitButton', 'input:reset': 'resetButton', 'input:image': 'image', 'input:color': 'color', 'input:date': 'date', 'input:datetime': 'datetime', 'input:datetime-local': 'datetime-local', 'input:number': 'number', 'input:email': 'email', 'input:tel': 'tel', 'input:search': 'search', 'input:url': 'url', 'input:time': 'time', 'input:week': 'week', 'input:month': 'month', 'textarea:': 'textBox', 'select:': 'selectList', 'select:select-one': 'selectList', 'button:': 'button', 'a:': 'link' }; const o = e.utils; let s = []; let u = 0; let l = !0; let c = function () {}; const d = { swipeAfterPinchInterval: 300, doubleTapInterval: 300, preventMouse: !0, dragMinDistance: 10 }; let f = []; let h = []; function p (t) { e.post(t) } function g (e) { for (var t = e.gesture.srcEvent.target, n = 0, r = 0; t && t.tagName !== 'BODY';)n += t.offsetTop, r += t.offsetLeft, t = t.offsetParent; return { topLeftX: r, topLeftY: n } } function m (e, t) { t === 'radioButton' && delete e.control.position.relXY, e.control.name !== null && void 0 !== e.control.name && e.control.name !== '' || delete e.control.name, e.control.subType !== null && void 0 !== e.control.subType && e.control.subType !== '' || delete e.control.subType } function v (t) { let i; let u; let l; let c; let d; let f; let h; let p; let v; const y = typeof (v = (p = o.getValue(t, 'webEvent')).type === 'drag' ? 'swipe' : p.type === 'hold' ? 'tapHold' : p.type) === 'string' ? v.toLowerCase() : 'unknown'; const w = o.getValue(t, 'webEvent.gesture.srcEvent.target', document.body); const b = o.getTagName(w) || 'body'; const T = o.getValue(w, 'type', ''); const S = a[b.toLowerCase() + ':' + T.toLowerCase()] || b; const _ = o.getValue(t, 'webEvent.target.subtype'); const x = []; for (r === '1' ? (u = t.webEvent.gesture.touches, l = 'webEvent.gesture.touches.', c = y === 'swipe' && !(void 0 !== n && n.event.tlEvent === 'swipe') || y === 'pinch' && !(void 0 !== n && n.event.tlEvent === 'pinch'), d = y === 'swipe' || y === 'pinch') : (u = t.webEvent.gesture.pointers, l = 'webEvent.gesture.pointers.', c = o.getValue(t, 'webEvent.gesture.firstOrLastSwipeEvent') === 'first' || o.getValue(t, 'webEvent.gesture.firstOrLastPinchEvent') === 'first', d = o.getValue(t, 'webEvent.gesture.firstOrLastSwipeEvent') === 'last' || o.getValue(t, 'webEvent.gesture.firstOrLastPinchEvent') === 'last'), h = 0; h < u.length; h += 1)f = { x: o.getValue(t, l + h + '.pageX') - g(t.webEvent).topLeftX, y: o.getValue(t, l + h + '.pageY') - g(t.webEvent).topLeftY, width: o.getValue(t, 'webEvent.gesture.srcEvent.target.offsetWidth'), height: o.getValue(t, 'webEvent.gesture.srcEvent.target.offsetHeight') }, x.push([{ position: { y: Math.round(o.getValue(t, l + h + '.pageY')), x: Math.round(o.getValue(t, l + h + '.pageX')) }, control: { position: { width: Math.round(o.getValue(t, l + h + '.target.offsetWidth')), height: Math.round(o.getValue(t, l + h + '.target.offsetHeight')), relXY: o.calculateRelativeXY(f), scrollX: Math.round(document.documentElement.scrollLeft || document.body.scrollLeft), scrollY: Math.round(document.documentElement.scrollTop || document.body.scrollTop) }, id: o.getValue(t, l + h + '.target.id') || e.getXPathFromNode(o.getValue(t, l + h + '.target')), idType: o.getValue(t, 'webEvent.gesture.idType'), name: o.getValue(t, l + h + '.target.name'), tlType: S, type: b, subType: T } }]), m(x[h][0], S); if (c) for (h = 0; h < u.length; h += 1)s.push(x[h][0]); if (d) for (h = 0; h < u.length; h += 1)x[h].unshift(s[h]); return i = { type: 11, event: { tlEvent: y, type: y }, touches: x }, y === 'swipe' && (i.velocityX = t.webEvent.gesture.velocityX, i.velocityY = t.webEvent.gesture.velocityY), y === 'swipe' && (i.direction = t.webEvent.gesture.direction, i.direction === 2 && (i.direction = 'left'), i.direction === 4 && (i.direction = 'right'), i.direction === 8 && (i.direction = 'up'), i.direction === 16 && (i.direction = 'down')), y === 'pinch' && (t.webEvent.gesture.scale > 1 ? i.direction = 'open' : t.webEvent.gesture.scale < 1 && (i.direction = 'close')), _ != null && (i.event.subType = _), i } function y (e, t) { r === '1' ? t.type === 'doubletap' || t.type === 'hold' || t.type === 'tap' ? p(v({ webEvent: t, id: e, currState: o.getValue(t, 'target.state') })) : t.type !== 'release' || void 0 === n || n.event.tlEvent !== 'swipe' && n.event.tlEvent !== 'pinch' ? t.type !== 'drag' && t.type !== 'pinch' || (n = v({ webEvent: t, id: e, currState: o.getValue(t, 'target.state') })) : (p(n), n = void 0, s = []) : t.type === 'doubletap' || t.type === 'tapHold' || t.type === 'tap' ? p(v({ webEvent: t, id: e, currState: o.getValue(t, 'target.state') })) : t.gesture.firstOrLastSwipeEvent === 'last' || t.gesture.firstOrLastPinchEvent === 'last' ? (p(v({ webEvent: t, id: e, currState: o.getValue(t, 'target.state') })), s = []) : t.gesture.firstOrLastSwipeEvent !== 'first' && t.gesture.firstOrLastPinchEvent !== 'first' || v({ webEvent: t, id: e, currState: o.getValue(t, 'target.state') }) } function w (e) { let t; return document.createEvent ? ((t = document.createEvent('HTMLEvents')).initEvent(e.type, !0, !0), t.gesture = e) : ((t = document.createEventObject()).eventType = e.type, t.gesture = e), t } function b (e, t) { void 0 !== t && (document.createEvent ? t.dispatchEvent(e) : t.fireEvent('on' + e.eventType, e)) } function T (e) { const t = e.type; const n = e.target; t === 'tap' ? (b(w(e), n), i = void 0) : t === 'press' ? (e.type = 'tapHold', b(w(e), n), i = void 0) : t === 'panstart' ? (e.type = 'swipe', e.firstOrLastSwipeEvent = 'first', b(w(e), n), i = n) : t === 'panend' ? (e.type = 'swipe', e.firstOrLastSwipeEvent = 'last', b(w(e), i), i = void 0) : t === 'pinchstart' ? (e.type = 'pinch', e.firstOrLastPinchEvent = 'first', b(w(e), n), i = n) : t === 'pinchend' && (e.type = 'pinch', e.firstOrLastPinchEvent = 'last', b(w(e), i), i = void 0) } return { init: function () { let t; let n; let a; let s; let u; let l; let c; let p = []; const g = TLT.getCoreConfig().modules.gestures.events; let m = ''; if (typeof Hammer === 'function') { for ((r = Hammer.VERSION.split('.')[0]) === '1' && (Hammer.defaults.behavior.userSelect = 'auto', Hammer.defaults.behavior.userDrag = 'auto', Hammer.defaults.behavior.contentZooming = 'auto', Hammer.defaults.behavior.touchCallout = 'default', Hammer.defaults.behavior.touchAction = 'auto'), e.getConfig() && e.getConfig().options && o.extend(!0, d, e.getConfig().options), t = 0; t < g.length; t += 1) if ((c = g[t].name) === 'tap' && (m += 'tap '), c === 'swipe' && (m += 'panstart panend '), c === 'tapHold' && (m += 'press '), c === 'pinch' && (m += 'pinchstart pinchend'), (s = g[t].target) === window || s === 'window')r === '1' && f.push(new Hammer(window, d)); else if (u != null) for (u = s.split(', '), n = 0; n < u.length; n += 1) for (p = TLT.getService('browser').queryAll(u[n], document), a = 0; a < p.length; a += 1)o.indexOf(h, p[a]) === -1 && h.push(p[a]); if (r === '1') for (t = 0; t < h.length; t += 1)f.push(new Hammer(h[t], d)); else if (h.length !== 0) for (t = 0; t < h.length; t += 1)(l = new Hammer.Manager(h[t])).add(new Hammer.Tap({ event: 'tap' })), l.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL })), l.add(new Hammer.Press()), l.add(new Hammer.Pinch({ enable: !0 })), l.on(m, function (e) { ((e.type === 'panend' || e.type === 'pinchend') && h.indexOf(i) > -1 || h.indexOf(e.target) > -1) && T(e) }), f.push(l); else void 0 === window.style && (window.style = []), (l = new Hammer.Manager(window)).add(new Hammer.Tap({ event: 'tap' })), l.add(new Hammer.Pan({ direction: Hammer.DIRECTION_ALL })), l.add(new Hammer.Press()), l.add(new Hammer.Pinch({ enable: !0 })), l.on(m, function (e) { T(e) }), f.push(l) } }, destroy: function () { let e; if (f != null) for (e = 0; e < f.length; e += 1)f[e].off('tap press pinchstart pinchend panstart panend'), f[e].enabled = !1; f = [], h = [] }, onevent: function (e) { let n; if (typeof e === 'object' && e.type && (e.gesture || e.type === 'unload') && e.target && (e.type === 'unload' || e.gesture.pointerType !== 'mouse' || !d.preventMouse)) switch (n = o.getValue(e, 'target.id'), e.type) { case 'tap':!(function (e, n) { const r = d.doubleTapInterval; (u += 1) === 1 ? (c = (function (e, t) { const n = e; const r = t; return function () { y(n, r), u = 0 } }(e, n)), t = setTimeout(function () { c(), c = function () {} }, r)) : (clearTimeout(t), n.type = 'doubletap', y(e, n), c = function () {}, u = 0) }(n, e)); break; case 'swipe':case 'pinch':case 'drag':!(function (e, n) { const r = d.swipeAfterPinchInterval; !l || n.type !== 'swipe' && n.type !== 'drag' || y(e, n), n.type === 'pinch' && (y(e, n), l = !1, t = setTimeout(function () { l = !0 }, r)) }(n, e)); break; case 'tapHold':case 'hold':case 'release':y(n, e); break; case 'unload':clearTimeout(t), c() } } } }) : console && console.info('Could not load TL.Gestures.'), window.TLT.utils.isiOS && (function () { if (typeof document !== 'undefined' && !('adoptedStyleSheets' in document)) { var e = 'ShadyCSS' in window && !ShadyCSS.nativeShadow; var t = document.implementation.createHTMLDocument(''); var n = new WeakMap(); const r = typeof DOMException === 'object' ? Error : DOMException; var i = Object.defineProperty; var a = Array.prototype.forEach; const o = /@import.+?;?$/gm; var s = CSSStyleSheet.prototype; s.replace = function () { return Promise.reject(new r("Can't call replace on non-constructed CSSStyleSheets.")) }, s.replaceSync = function () { throw new r("Failed to execute 'replaceSync' on 'CSSStyleSheet': Can't call replaceSync on non-constructed CSSStyleSheets.") }; var u = new WeakMap(); var l = new WeakMap(); var c = new WeakMap(); var d = new WeakMap(); var f = O.prototype; f.replace = function (e) { try { return this.replaceSync(e), Promise.resolve(this) } catch (e) { return Promise.reject(e) } }, f.replaceSync = function (e) { if (C(this), typeof e === 'string') { const t = this; u.get(t).textContent = (function (e) { const t = e.replace(o, ''); return t !== e && console.warn('@import rules are not allowed here. See https://github.com/WICG/construct-stylesheets/issues/119#issuecomment-588352418'), t.trim() }(e)), d.set(t, []), l.get(t).forEach(function (e) { e.isConnected() && E(t, x(t, e)) }) } }, i(f, 'cssRules', { configurable: !0, enumerable: !0, get: function () { return C(this), u.get(this).sheet.cssRules } }), i(f, 'media', { configurable: !0, enumerable: !0, get: function () { return C(this), u.get(this).sheet.media } }), ['addRule', 'deleteRule', 'insertRule', 'removeRule'].forEach(function (e) { f[e] = function () { const t = this; C(t); const n = arguments; d.get(t).push({ method: e, args: n }), l.get(t).forEach(function (r) { if (r.isConnected()) { const i = x(t, r).sheet; i[e].apply(i, n) } }); const r = u.get(t).sheet; return r[e].apply(r, n) } }), i(O, Symbol.hasInstance, { configurable: !0, value: S }); var h = { childList: !0, subtree: !0 }; var p = new WeakMap(); var g = new WeakMap(); var m = new WeakMap(); var v = new WeakMap(); if (P.prototype = { isConnected: function () { const e = g.get(this); return e instanceof Document ? e.readyState !== 'loading' : (function (e) { return 'isConnected' in e ? e.isConnected : document.contains(e) }(e.host)) }, connect: function () { const e = D(this); v.get(this).observe(e, h), m.get(this).length > 0 && I(this), M(e, function (e) { k(e).connect() }) }, disconnect: function () { v.get(this).disconnect() }, update: function (e) { const t = this; const n = g.get(t) === document ? 'Document' : 'ShadowRoot'; if (!Array.isArray(e)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + n + ': Iterator getter is not callable.'); if (!e.every(S)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + n + ": Failed to convert value to 'CSSStyleSheet'"); if (e.some(_)) throw new TypeError("Failed to set the 'adoptedStyleSheets' property on " + n + ": Can't adopt non-constructed stylesheets"); t.sheets = e; let r; let i; const a = m.get(t); const o = (r = e).filter(function (e, t) { return r.indexOf(e) === t }); (i = o, a.filter(function (e) { return i.indexOf(e) === -1 })).forEach(function (e) { let n; (n = x(e, t)).parentNode.removeChild(n), (function (e, t) { c.get(e).delete(t), l.set(e, l.get(e).filter(function (e) { return e !== t })) }(e, t)) }), m.set(t, o), t.isConnected() && o.length > 0 && I(t) } }, window.CSSStyleSheet = O, L(Document), 'ShadowRoot' in window) { L(ShadowRoot); const y = Element.prototype; const w = y.attachShadow; y.attachShadow = function (e) { const t = w.call(this, e); return e.mode === 'closed' && n.set(this, t), t } } const b = k(document); b.isConnected() ? b.connect() : document.addEventListener('DOMContentLoaded', b.connect.bind(b)) } function T (e) { return e.shadowRoot || n.get(e) } function S (e) { return typeof e === 'object' && (f.isPrototypeOf(e) || s.isPrototypeOf(e)) } function _ (e) { return typeof e === 'object' && s.isPrototypeOf(e) } function x (e, t) { return c.get(e).get(t) } function E (e, t) { requestAnimationFrame(function () { t.textContent = u.get(e).textContent, d.get(e).forEach(function (e) { return t.sheet[e.method].apply(t.sheet, e.args) }) }) } function C (e) { if (!u.has(e)) throw new TypeError('Illegal invocation') } function O () { const e = this; const n = document.createElement('style'); t.body.appendChild(n), u.set(e, n), l.set(e, []), c.set(e, new WeakMap()), d.set(e, []) } function k (e) { let t = p.get(e); return t || (t = new P(e), p.set(e, t)), t } function L (e) { i(e.prototype, 'adoptedStyleSheets', { configurable: !0, enumerable: !0, get: function () { return k(this).sheets }, set: function (e) { k(this).update(e) } }) } function M (e, t) { for (let n = document.createNodeIterator(e, NodeFilter.SHOW_ELEMENT, function (e) { return T(e) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT }, null, !1), r = void 0; r = n.nextNode();)t(T(r)) } function D (e) { const t = g.get(e); return t instanceof Document ? t.body : t } function I (e) { const t = document.createDocumentFragment(); const n = m.get(e); const r = v.get(e); const i = D(e); r.disconnect(), n.forEach(function (n) { t.appendChild(x(n, e) || (function (e, t) { const n = document.createElement('style'); return c.get(e).set(t, n), l.get(e).push(t), n }(n, e))) }), i.insertBefore(t, null), r.observe(i, h), n.forEach(function (t) { E(t, x(t, e)) }) } function P (t) { const n = this; n.sheets = [], g.set(n, t), m.set(n, []), v.set(n, new MutationObserver(function (t, r) { document ? t.forEach(function (t) { e || a.call(t.addedNodes, function (e) { e instanceof Element && M(e, function (e) { k(e).connect() }) }), a.call(t.removedNodes, function (t) { t instanceof Element && ((function (e, t) { return t instanceof HTMLStyleElement && m.get(e).some(function (t) { return x(t, e) }) }(n, t)) && I(n), e || M(t, function (e) { k(e).disconnect() })) }) }) : r.disconnect() })) } }()), TLT.addModule('ajaxListener', function (e) { let t; let n; let r; let i; let a = {}; let o = !1; const s = e.utils; function u (e) { let t; let n; let r = !1; const i = a.urlBlocklist; if (!e || !i) return r; for (t = 0, n = i.length; !r && t < n; t += 1)r = i[t].cRegex.test(e); return r } function l (e, t, n) { let r; let i; let o; let s = {}; const u = a.filters; if (!u || !u.length) return s; for (r = 0, i = u.length, o = !1; !o && r < i; r += 1)o = !0, (s = u[r]).url && (o = s.url.cRegex.test(e)), o && s.method && (o = s.method.cRegex.test(t)), o && s.status && (o = s.status.cRegex.test(n)); return o || (s = null), s } function c (t, n) { let r; let i; const a = { type: 5, customEvent: { name: 'ajaxListener', data: { interfaceType: 'XHR' } } }; const o = a.customEvent.data; if (t) { if ((r = document.createElement('a')).href = t.tListener.url, o.originalURL = r.host + (r.pathname[0] === '/' ? '' : '/') + r.pathname, o.requestURL = e.normalizeUrl ? e.normalizeUrl(o.originalURL, 3) : o.originalURL, o.description = 'Full Ajax Monitor ' + o.requestURL, o.method = t.tListener.method, o.status = t.status, o.statusText = t.statusText || '', o.async = t.tListener.async, o.ajaxResponseTime = t.tListener.end - t.tListener.start, o.locationHref = e.normalizeUrl(document.location.href, 3), o.queryParams = h(t.tListener.url), n.requestHeaders && (o.requestHeaders = t.tListener.reqHeaders), n.requestData && typeof t.tListener.reqData === 'string' && !t.tListener.isSystemXHR) try { o.request = JSON.parse(t.tListener.reqData) } catch (e) { o.request = t.tListener.reqData } if (n.responseHeaders && (o.responseHeaders = (function (e) { let t; let n; let r; let i; let a; const o = {}; for (t = 0, n = (e = e.split(/[\r\n]+/)).length; t < n; t += 1)i = (r = e[t].split(': '))[0], a = s.rtrim(r[1]), i && i.length && (o[i] = a); return o }(t.getAllResponseHeaders()))), n.responseData) { if (void 0 === t.responseType ? i = t.responseText : t.responseType === '' || t.responseType === 'text' ? i = t.response : t.responseType === 'json' ? o.response = t.response : o.response = typeof t.response, i) try { o.response = JSON.parse(i) } catch (e) { o.response = i }t.responseType && (o.responseType = t.responseType) }e.post(a) } } function d (e) { for (var t, n = {}, r = e.entries(), i = r.next(); !i.done;)n[(t = i.value)[0]] = t[1], i = r.next(); return n } function f (e) { return d(e) } function h (e) { const t = e.indexOf('?'); if (t < 0) return {}; const n = e.substring(t + 1); const r = {}; const i = new URLSearchParams(n).entries(); for (const a in i)r[i[a][0]] = i[a][1]; return r } function p (t, n, r) { let i; let a; const o = { type: 5, customEvent: { name: 'ajaxListener', data: { interfaceType: 'fetch' } } }; const s = o.customEvent.data; if ((i = document.createElement('a')).href = t.url, s.originalURL = i.host + (i.pathname[0] === '/' ? '' : '/') + i.pathname, s.requestURL = e.normalizeUrl ? e.normalizeUrl(s.originalURL, 3) : s.originalURL, s.description = 'Full Ajax Monitor ' + s.requestURL, s.method = t.initData.method, s.status = n.status, s.statusText = n.statusText || '', s.async = !0, s.ajaxResponseTime = t.end - t.start, s.responseType = n.type, s.locationHref = e.normalizeUrl(document.location.href, 3), s.queryParams = h(t.url), r.requestHeaders && (t.initData.headers && t.initData.headers.toString().indexOf('Headers') !== -1 ? s.requestHeaders = f(t.initData.headers) : s.requestHeaders = t.initData.headers || ''), r.requestData && void 0 !== t.body && !t.isSystemXHR && (s.request = (function (e) { let t = e; if (!e) return t; if (typeof e === 'object' && e.toString().indexOf('FormData') !== -1)t = d(e); else if (typeof e === 'string') try { t = JSON.parse(e) } catch (n) { t = e } return t }(t.body))), r.responseHeaders && (s.responseHeaders = f(n.headers)), r.responseData) { if ((a = n.headers.get('content-type')) && a.indexOf('application/json') !== -1) return void n.clone().json().then(function (t) { s.response = t, e.post(o) }); if (a && (a.indexOf('text') !== -1 || a.indexOf('xml') !== -1)) return void n.clone().text().then(function (t) { s.response = t, e.post(o) }); s.response = 'Not logging unsupported response content: ' + a }e.post(o) } function g (e) { let t; e && e.target && (t = e.target).readyState === 4 && (t.removeEventListener('readystatechange', g), t.tListener.end = Date.now(), (function (e) { let t; let n = { requestHeaders: !1, requestData: !1, responseHeaders: !1, responseData: !1 }; (t = l(e.tListener.url, e.tListener.method, e.status.toString())) && (t.log && (n = t.log), c(e, n)) }(t))) } function m (e) { let t, n; for (n = TLT.getServiceConfig('queue').queues || [], t = 0; t < n.length; t += 1) if (n[t].endpoint && e.indexOf(n[t].endpoint) !== -1) return !0; return !1 } function v (e, n, r) { const i = this; return o && !u(n) && (i.addEventListener('readystatechange', g), i.tListener = { method: e, url: n, async: void 0 === r || !!r, reqHeaders: {}, isSystemXHR: m(n) }, (function (e) { const t = e.setRequestHeader; e.setRequestHeader = function (e, n) { const r = this.tListener; return e && e.length && (r.reqHeaders[e] = n), t.apply(this, arguments) } }(i)), (function (e) { const t = e.send; e.send = function (e) { const n = this.tListener; return e && (n.reqData = e), n.start = Date.now(), t.apply(this, arguments) } }(i))), t.apply(i, arguments) } function y () { n = window.fetch, window.fetch = function (e, t) { const r = {}; return e instanceof Request ? (r.initData = e, r.url = e.url, r.initData.clone().text().then(function (e) { e.length > 0 && (r.body = e) })) : (r.initData = t || {}, r.url = e.toString(), t && t.body && (r.body = t.body)), r.isSystemXHR = m(r.url), r.start = Date.now(), n.apply(this, arguments).then(function (e) { return r.end = Date.now(), (function (e, t) { let n; const r = e.url; const i = e.initData.method; const a = t.status.toString(); let o = { requestHeaders: !1, requestData: !1, responseHeaders: !1, responseData: !1 }; u(r) || (n = l(r, i, a)) && (n.log && (o = n.log), p(e, t, o)) }(r, e)), e }) } } function w (e) { e && e.regex && (e.cRegex = new RegExp(e.regex, e.flags)) } return { init: function () { !(function (e) { let t; let n; let a; let o = []; const u = s.getValue(e, 'skipSafetyCheck', !1); for (e && e.filters && (o = e.filters), t = 0, n = o.length; t < n; t += 1)a = o[t], s.forEach([a.url, a.method, a.status], w); e && e.urlBlocklist && s.forEach(e.urlBlocklist, w), !(r = s.getValue(e, 'xhrEnabled', !0) && window.XMLHttpRequest) || u || XMLHttpRequest.toString().indexOf('[native code]') !== -1 && XMLHttpRequest.toString().indexOf('XMLHttpRequest') !== -1 || (r = !1), (i = s.getValue(e, 'fetchEnabled', !0) && window.fetch) && !u && window.fetch.toString().indexOf('[native code]') === -1 && (i = !1) }(a = e.getConfig())) }, destroy: function () { o = !1 }, onevent: function (e) { switch (e.type) { case 'load':r && XMLHttpRequest && (t = XMLHttpRequest.prototype.open, XMLHttpRequest.prototype.open = v), i && y(), o = !0; break; case 'unload':o = !1 } }, version: '1.3.0' } }), TLT.addModule('flushQueue', function () { return { onevent: function (e) { if (e && e.type === 'visibilitychange')TLT.flushAll() } } }), f = { core: { buildNote: 'Acoustic Tealeaf UIC ' + window.TLT.getLibraryVersion(), blockedElements: [], ieExcludedLinks: ['a[href*="javascript:void"]', "input[onclick*='javascript:']"], blockedUserAgents: [{ regex: '(Google|Bing|Face|DuckDuck|Yandex|Exa)bot|spider|archiver', flags: 'i' }, 'PhantomJS'], inactivityTimeout: 174e4, modules: { replay: { events: [{ name: 'change', attachToShadows: !0, recurseFrames: !0 }, { name: 'click', recurseFrames: !0 }, { name: 'dblclick', recurseFrames: !0 }, { name: 'contextmenu', recurseFrames: !0 }, { name: 'pointerdown', recurseFrames: !0 }, { name: 'pointerup', recurseFrames: !0 }, { name: 'hashchange', target: window }, { name: 'focus', recurseFrames: !0 }, { name: 'blur', recurseFrames: !0 }, { name: 'load', target: window }, { name: 'unload', target: window }, { name: 'resize', target: window }, { name: 'scroll', target: window }, { name: 'mousemove', recurseFrames: !0 }, { name: 'orientationchange', target: window }, { name: 'touchend' }, { name: 'touchstart' }, { name: 'error', target: window }, { name: 'visibilitychange' }] }, flushQueue: { events: [] }, overstat: { enabled: !0, events: [{ name: 'click', recurseFrames: !0 }, { name: 'mousemove', recurseFrames: !0 }, { name: 'mouseout', recurseFrames: !0 }, { name: 'submit', recurseFrames: !0 }] }, performance: { enabled: !0, events: [{ name: 'load', target: window }, { name: 'unload', target: window }] }, ajaxListener: { enabled: !0, events: [{ name: 'load', target: window }, { name: 'unload', target: window }] }, gestures: { enabled: !0, events: [{ name: 'tap', target: window }, { name: 'hold', target: window }, { name: 'drag', target: window }, { name: 'release', target: window }, { name: 'pinch', target: window }] }, dataLayer: { enabled: !1, events: [{ name: 'load', target: window }, { name: 'unload', target: window }] }, TLCookie: { enabled: !0 } }, screenviewAutoDetect: !0, framesBlacklist: [] }, services: { queue: { asyncReqOnUnload: /WebKit/i.test(navigator.userAgent), useBeacon: !0, useFetch: !0, xhrEnabled: !0, queues: [{ qid: 'DEFAULT', endpoint: t, maxEvents: 30, timerInterval: 6e4, maxSize: 3e5, checkEndpoint: !0, endpointCheckTimeout: 4e3, encoder: 'gzip' }] }, message: { privacy: [{ targets: ['input[type=password]'], maskType: 2 }, { targets: ['input[id*=phone]', 'input[name*=phone]'], maskType: 4, maskFunction: function (e) { return e.slice(0, -3).replace(/[0-9]/g, 'X') + e.slice(-3) } }, { exclude: !0, targets: ['input[type=hidden]', 'input[type=radio]', 'input[type=checkbox]', 'input[type=submit]', 'input[type=button]', 'input[type=search]'], maskType: 4, maskFunction: function (e) { return e.replace(/[a-z]/gi, 'X').replace(/[0-9]/g, '9') } }], privacyPatterns: [{ pattern: { regex: '\\d{3}-\\d{2}-\\d{4}', flags: 'g' }, replacement: 'XXX-XX-XXXX' }, { pattern: { regex: '<div[^<]*tlPrivate[^<]*>(.+?)</div>', flags: 'g' }, replacement: function (e, t) { if (t.length > 0) return e.replace(t, 'xxxxxx') } }, { pattern: { regex: '<span[^<]*tlPrivate[^<]*>(.+?)</span>', flags: 'g' }, replacement: function (e, t) { if (t.length > 0) return e.replace(t, 'xxxxxx') } }, { pattern: { regex: '<p[^<]*tlPrivate[^<]*>(.+?)</p>', flags: 'g' }, replacement: function (e, t) { if (t.length > 0) return e.replace(t, 'xxxxxx') } }] }, encoder: { gzip: { encode: 'window.pako.gzip', defaultEncoding: 'gzip' } }, domCapture: { diffEnabled: !0, options: { maxLength: 1e7, captureShadowDOM: !0, captureDynamicStyles: !0, captureFrames: !0 } }, browser: { normalizeTargetToParentLink: !0 } }, modules: { overstat: { hoverThreshold: 3e3 }, performance: { calculateRenderTime: !0, renderTimeThreshold: 6e5, performanceAlert: { enabled: !0, threshold: 3e3, maxAlerts: 100, blacklist: [] } }, replay: { domCapture: { enabled: !0, screenviewBlacklist: [], triggers: [{ event: 'change' }, { event: 'click' }, { event: 'dblclick' }, { event: 'contextmenu' }, { event: 'visibilitychange' }, { event: 'load', fullDOMCapture: !0, delay: 300 }] }, mousemove: { enabled: !0, sampleRate: 200, ignoreRadius: 3 } }, ajaxListener: { urlBlocklist: [{ regex: 'brilliantcollector\\.com' }], filters: [{ log: { requestHeaders: !0, requestData: !1, responseHeaders: !0, responseData: !1 } }] }, dataLayer: { dataObject: 'window.dataLayer' }, TLCookie: { appCookieWhitelist: [{ regex: '.*' }], tlAppKey: e } } }, window.TLT.utils.isIE && (document.documentMode === 9 && (f.modules.replay.domCapture.enabled = !1, f.modules.ajaxListener.enabled = !1), document.documentMode === 10 && (f.services.domCapture.diffEnabled = !1, f.modules.replay.domCapture.triggers = [{ event: 'click', targets: ['a', 'a *', 'button', 'button *'] }, { event: 'change' }, { event: 'load', delay: 100 }])), (window.TLT.utils.isiOS || window.TLT.utils.isAndroid) && (f.services.queue.queues[0].maxEvents = 10, f.services.queue.queues[0].maxSize = 1e4, f.services.queue.queues[0].timerInterval = 1e4, f.services.queue.queues[0].endpointCheckTimeout = 1e4, window.TLT.utils.isiOS && ((n = window.navigator.userAgent.match(/OS (\d+)_/)) && n[1] < 13 && (f.services.queue.useBeacon = !1), f.core.modules.flushQueue && f.core.modules.flushQueue.events ? f.core.modules.flushQueue.events.push({ name: 'visibilitychange' }) : console.log('Tealeaf Error: include the flushQueue module!'))), window.TLT.utils.isLegacyIE) return console && (console.warn('This version of the UIC does not support Internet Explorer 9.'), console.info('Applications requiring Internet Explorer 8 (or below) support should use UIC 5.2.0')), void (window.TLT.terminationReason = 'Unsupported browser'); window.TLT.init(f, function (e) { console && (console.info('TLT.initLib has ' + e + ' with the following settings below:'), console.info(f)) }) }, init: function (e, t) { let n; if (!(d = this.utils).isLegacyIE) { if (R = t, !A) throw 'init must only be called once!'; if (!e && !this.config) throw 'missing configuration.'; e = e || this.config, this.config = e, A = !1, m = 'P.' + d.getRandomString(28), v = (function () { let e = null; const t = 'tltTabId'; try { (e = sessionStorage.getItem(t)) || (e = d.getRandomString(4), sessionStorage.setItem(t, e)) } catch (e) {} return e }()), n = function (r) { (r = r || window.event || {}).type !== 'load' && document.readyState === 'loading' || (document.removeEventListener ? (document.removeEventListener('DOMContentLoaded', n, !1), window.removeEventListener('load', n, !1)) : (document.detachEvent('onreadystatechange', n), window.detachEvent('onload', n)), P(e, t)) }, document.readyState === 'complete' || document.readyState === 'interactive' && !d.isIE ? setTimeout(n) : document.addEventListener ? (document.addEventListener('DOMContentLoaded', n, !1), window.addEventListener('load', n, !1)) : (document.attachEvent('onreadystatechange', n), window.attachEvent('onload', n)) } }, isInitialized: function () { return _ }, getState: function () { return x }, destroy: function (e, t) { let r = ''; let i = ''; let a = null; let o = null; let s = null; let u = !1; if (A) return !1; if (this.stopAll(), !e) { for (r in M)M.hasOwnProperty(r) && (i = r.split('|')[0], a = M[r].target, u = M[r].delegateTarget || void 0, n.unsubscribe(i, a, this._publishEvent, u)); c && (n.unsubscribe('mousemove', document, c), c = null) } for (o in S)S.hasOwnProperty(o) && ((s = S[o].instance) && typeof s.destroy === 'function' && s.destroy(), S[o].instance = null); E.clearCache(), M = {}, L = {}, I = [], _ = !1, A = !0, x = 'destroyed', TLT.terminationReason = t || x; try { sessionStorage.setItem('tl.TR', TLT.terminationReason), sessionStorage.setItem('tl.PU', this.normalizeUrl('', location.href)) } catch (e) {} if (typeof R === 'function') try { R('destroyed') } catch (e) {}l || (window.addEventListener('pageshow', p), l = !0) }, _updateModules: function (e) { let t = null; let n = null; let r = !0; if (u && u.modules) try { for (n in u.modules) if (u.modules.hasOwnProperty(n) && (t = u.modules[n], T.hasOwnProperty(n))) { if (!1 === t.enabled) { this.stop(n); continue } this.start(n), t.events && this._registerModuleEvents(n, t.events, e) } this._registerModuleEvents.clearCache() } catch (e) { H.destroy(!1, '_updateModules: ' + e.message), r = !1 } else r = !1; return r }, rebind: function (e) { H._updateModules(e) }, getSessionData: function () { if (H.isInitialized()) { let e; let t; let n; let r; let i = null; return u && u.sessionDataEnabled ? ((t = (e = u.sessionData || {}).sessionQueryName) ? n = d.getQueryStringValue(t, e.sessionQueryDelim) : (t = e.sessionCookieName) ? n = d.getCookieValue(t) : (t = (r = TLT.getTLTSessionCookieInfo()).tltCookieName, n = r.tltCookieValue), t && n && ((i = i || {}).tltSCN = t, i.tltSCV = n, i.tltSCVNeedsHashing = !!e.sessionValueNeedsHashing), i) : null } }, logGeolocation: function (e) { let t; H.isInitialized() && e && e.coords && (t = { type: 13, geolocation: { lat: d.getValue(e, 'coords.latitude', 0), long: d.getValue(e, 'coords.longitude', 0), accuracy: Math.ceil(d.getValue(e, 'coords.accuracy', 0)) } }, a.post('', t)) }, logCustomEvent: function (e, t) { if (H.isInitialized()) { let n; e && typeof e === 'string' || (e = 'CUSTOM'), n = { type: 5, customEvent: { name: e, data: t = t || {} } }, a.post('', n) } }, logExceptionEvent: function (e, t, n) { if (H.isInitialized()) { let r; e && typeof e === 'string' && (t && (t = H.normalizeUrl('', t, 6)), r = { type: 6, exception: { description: e, url: t = t || '', line: n = n || -1 } }, a.post('', r)) } }, logFormCompletion: function (e, t) { if (H.isInitialized()) { const n = { type: 15, formCompletion: { submitted: !!e, valid: typeof t === 'boolean' ? t : null } }; a.post('', n) } }, logDataLayer: function (e) { let t; H.isInitialized() && s && (e && typeof e !== 'object' || (t = { type: 'logDataLayer', data: e }, s.onevent(t))) }, logScreenviewLoad: function (e, t, n) { H.isInitialized() && g('LOAD', e, t) }, logScreenviewUnload: function (e) { H.isInitialized() && g('UNLOAD', e) }, logDOMCapture: function (e, t) { let n; let r; let o; let s = null; return this.isInitialized() ? (d.isLegacyIE || i && (e = e || window.document, r = this.getServiceConfig('domCapture'), t = d.mixin({}, r.options, t), (n = i.captureDOM(e, t)) && (s = t.dcid || 'dcid-' + d.getSerialNumber() + '.' + (new Date()).getTime(), n.dcid = s, n.eventOn = !!t.eventOn, o = { type: 12, domCapture: n }, t.timeoutExpired && (o.domCapture.timeout = !0), a.post('', o), !1 !== t.qffd && !z && o.domCapture.fullDOM && (a.flush(), z = !0))), s) : s }, performDOMCapture: function (e, t, n) { return this.logDOMCapture(t, n) }, performFormCompletion: function (e, t, n) { return this.logFormCompletion(t, n) }, _bridgeCallback: function (e) { const t = D[e]; return t && t.enabled ? t : null }, logScreenCapture: function () { if (H.isInitialized()) { const e = H._bridgeCallback('screenCapture'); e !== null && e.cbFunction() } }, enableTealeafFramework: function () { if (H.isInitialized()) { const e = H._bridgeCallback('enableTealeafFramework'); e !== null && e.cbFunction() } }, disableTealeafFramework: function () { if (H.isInitialized()) { const e = H._bridgeCallback('disableTealeafFramework'); e !== null && e.cbFunction() } }, startNewTLFSession: function () { if (H.isInitialized()) { const e = H._bridgeCallback('startNewTLFSession'); e !== null && e.cbFunction() } }, currentSessionId: function () { if (H.isInitialized()) { let e; const t = H._bridgeCallback('currentSessionId'); return t !== null && (e = t.cbFunction()), e } }, defaultValueForConfigurableItem: function (e) { if (H.isInitialized()) { let t; const n = H._bridgeCallback('defaultValueForConfigurableItem'); return n !== null && (t = n.cbFunction(e)), t } }, valueForConfigurableItem: function (e) { if (H.isInitialized()) { let t; const n = H._bridgeCallback('valueForConfigurableItem'); return n !== null && (t = n.cbFunction(e)), t } }, setConfigurableItem: function (e, t) { if (H.isInitialized()) { let n = !1; const r = H._bridgeCallback('setConfigurableItem'); return r !== null && (n = r.cbFunction(e, t)), n } }, addAdditionalHttpHeader: function (e, t) { if (H.isInitialized()) { let n = !1; const r = H._bridgeCallback('addAdditionalHttpHeader'); return r !== null && (n = r.cbFunction(e, t)), n } }, logCustomEventBridge: function (e, t, n) { if (H.isInitialized()) { let r = !1; const i = H._bridgeCallback('logCustomEventBridge'); return i !== null && (r = i.cbFunction(e, t, n)), r } }, registerBridgeCallbacks: function (e) { let t; let n; let r; let i; let a; let o; let s; let u = null; const l = TLT.utils; if (!e) return !1; if (e.length === 0) return D = {}, !1; try { for (t = 0, r = e.length; t < r; t += 1) if (typeof (u = e[t]) === 'object' && u.cbType && u.cbFunction) if (i = { enabled: u.enabled, cbFunction: u.cbFunction, cbOrder: u.order || 0 }, l.isUndefOrNull(D[u.cbType]))i.enabled && (D[u.cbType] = i); else { for (l.isArray(D[u.cbType]) || (D[u.cbType] = [D[u.cbType]]), a = D[u.cbType], n = 0, s = !1, o = a.length; n < o; n += 1) if (a[n].cbOrder === i.cbOrder && a[n].cbFunction === i.cbFunction)s = !0, i.enabled || (a.splice(n, 1), a.length || delete D[u.cbType]); else if (a[n].cbOrder > i.cbOrder) break; s || i.enabled && a.splice(n, 0, i) } } catch (e) { return !1 } return !0 }, registerMutationCallback: function (e, t) { let n; return !(!e || typeof e !== 'function') && (t ? (n = I.indexOf(e)) === -1 && I.push(e) : (n = I.indexOf(e)) !== -1 && I.splice(n, 1), !0) }, invokeMutationCallbacks: function (e) { let t; let n; let r; let i; const a = []; const o = []; if (I.length !== 0) { for (i = Map ? new Map() : new d.WeakMap(), t = 0; t < e.length; t++)(r = e[t].target) && (n = d.getDocument(r), void 0 === i.get(n) && (n.host ? o.push(n) : a.push(n), i.set(n, !0))); for (i.clear(), t = 0; t < I.length; t++)(0, I[t])(e, a, o) } }, redirectQueue: function (e) { let t, n, r, i, a, s, u; if (!e || !e.length) return e; if (!(i = D.messageRedirect)) return e; for (n = 0, s = (a = d.isArray(i) ? i : [i]).length; n < s; n += 1) if ((i = a[n]) && i.enabled) for (t = 0, r = e.length; t < r; t += 1)(u = i.cbFunction(o.serialize(e[t]), e[t])) && typeof u === 'object' ? e[t] = u : (e.splice(t, 1), t -= 1, r = e.length); return e }, _hasSameOrigin: function (e) { let t = !1; try { return (t = e.document.location.host === document.location.host && e.document.location.protocol === document.location.protocol) || (t = e.document.domain === document.domain), t } catch (e) {} return !1 }, provideRequestHeaders: function () { let e = null; const t = D.addRequestHeaders; return t && t.enabled && (e = t.cbFunction()), e }, _registerModuleEvents: (function () { let e; let r = 0; const a = function (e, t, n) { return e === 'window' ? t : e === 'document' ? n : e }; function o (e) { const t = d.getIFrameWindow(e); return t !== null && H._hasSameOrigin(t) && t.document !== null && t.document.readyState === 'complete' && t.document.body.innerHTML !== '' } function s (s, u, l) { if (l = l || H._getLocalTop().document, e = e || new d.WeakMap(), (function (r, i, o) { let s; let u; let l; const c = d.getDocument(o); const f = H._getLocalTop(); const h = d.isIFrameDescendant(o); if (o = o || c, k.normalizeModuleEvents(r, i, f, c), h && typeof (s = t.ElementData.prototype.examineID(o).id) === 'string') for (u in s = s.slice(0, s.length - 1), M) if (M.hasOwnProperty(u)) for (l = 0; l < M[u].length; l += 1) if (r === M[u][l] && u.indexOf(s) !== -1) { delete M[u]; break }d.forEach(i, function (i) { const s = a(i.target, f, c) || c; let u = ''; !0 !== i.recurseFrames && h || (typeof s === 'string' ? d.forEach(n.queryAll(s, o), function (a) { let o = e.get(a); o || (o = t.ElementData.prototype.examineID(a), e.set(a, o)), u = i.name + '|' + o.id + o.idType, d.indexOf(M[u], r) === -1 && (M[u] = M[u] || [], M[u].push(r), M[u].target = a, n.subscribe(i.name, a, H._publishEvent)) }) : (u = H._buildToken4bubbleTarget(i.name, s, void 0 === i.target), M.hasOwnProperty(u) ? d.indexOf(M[u], r) === -1 && M[u].push(r) : (M[u] = [r], n.subscribe(i.name, s, H._publishEvent))), u !== '' && typeof s !== 'string' && (M[u].target = s)) }) }(s, u, l)), s !== 'performance') { let c; let f; let h = null; let p = null; const g = n.queryAll('iframe, frame', l); for (c = 0, f = g.length; c < f; c += 1)h = g[c], E(h) || (o(h) ? (p = d.getIFrameWindow(h), H._registerModuleEvents(s, u, p.document), i.observeWindow(p)) : (r += 1, (function (e, t, n) { let a = null; const s = function () { let a = null; E(n) || (a = d.getIFrameWindow(n), H._hasSameOrigin(a) && (H._registerModuleEvents(e, t, a.document), i.observeWindow(a))), (r -= 1) || H._publishEvent({ type: 'loadWithFrames', custom: !0 }) }; d.addEventListener(n, 'load', function () { s() }), d.isLegacyIE && o(n) && (a = d.getIFrameWindow(n), d.addEventListener(a.document, 'readystatechange', function () { s() })) }(s, u, h)))) } } return s.clearCache = function () { e && (e.clear(), e = null) }, s }()), _buildToken4currentTarget: function (e) { const n = e.nativeEvent ? e.nativeEvent.currentTarget : null; const r = n ? t.ElementData.prototype.examineID(n) : { id: e.target ? e.target.id : null, idType: e.target ? e.target.idType : -1 }; return e.type + '|' + r.id + r.idType }, _buildToken4delegateTarget: function (e, t, n) { return e + '|' + t + '|' + n }, _buildToken4bubbleTarget: function (e, r, i, a) { let o; let s; let u; const l = H._getLocalTop(); const c = d.getDocument(r); let f = null; let h = e; return c && (o = c.defaultView || c.parentWindow), r === window || r === window.window ? h += '|null-2|window' : i && o && H._hasSameOrigin(o.parent) && void 0 !== c && l.document !== c ? (s = c, u = null, H._hasSameOrigin(o.parent) && d.forEach(n.queryAll('iframe, frame', o.parent.document), function (e) { let t = null; E(e) || (t = d.getIFrameWindow(e), H._hasSameOrigin(t) && t.document === s && (u = e)) }), (f = u) && (h += '|' + t.ElementData.prototype.examineID(f).xPath + '-2')) : h += '|null-2|document', h }, _reinitConfig: function () { H._updateModules() }, _publishEvent: function (e) { let t; let r; let i; let o; let s; let l; let c = null; let f = null; let h = e.delegateTarget && e.data ? e.data : H._buildToken4currentTarget(e); let p = null; let g = null; let m = !1; let v = !1; const y = e.delegateTarget || null; if (L = e, e.type.match(/^(click|change|blur|mouse|touch)/) && (N(), a.resetFlushTimer()), d.getValue(u, 'screenviewAutoDetect', !0) && V(), e.type !== 'load' && e.type !== 'pageshow' || e.nativeEvent.customLoad) if (e.type === 'click' && (C = e.target.element), e.type === 'beforeunload' && (m = !1, (o = d.getTagName(C) === 'a' ? C : document.activeElement) && (l = !1, (s = o) && d.getTagName(s) === 'a' && ['intent:', 'mailto:', 'sms:', 'tel:'].indexOf(s.protocol) !== -1 && (l = !0), l ? m = !0 : d.forEach(u.ieExcludedLinks, function (e) { let t; let r; const i = n.queryAll(e); for (t = 0, r = i ? i.length : 0; t < r; t += 1) if (i[t] && i[t] === C) { m = !0; break } })), m))L = {}; else if (k.isUnload(e) && (x = 'unloading'), e.type !== 'change' || !d.isLegacyIE || H.getFlavor() !== 'w3c' || e.target.element.type !== 'checkbox' && e.target.element.type !== 'radio') { if (e.type === 'propertychange') { if (e.nativeEvent.propertyName !== 'checked' || !(e.target.element.type === 'checkbox' || e.target.element.type === 'radio' && e.target.element.checked)) return void (L = {}); e.type = 'change', e.target.type = 'INPUT' } if (e.target && F(e.target.element))L = {}; else { if (M.hasOwnProperty(h) || (e.hasOwnProperty('nativeEvent') && (i = e.nativeEvent.currentTarget || e.nativeEvent.target), h = H._buildToken4bubbleTarget(e.type, i, !0, y)), M.hasOwnProperty(h)) for (t = 0, r = (p = M[h]).length; t < r; t += 1) if (c = p[t], f = H.getModule(c), g = d.mixin({}, e), f && H.isStarted(c) && typeof f.onevent === 'function' && (v = k.canPublish(c, g))) try { f.onevent(g) } catch (e) {}g && g.type === 'unload' && v && H.destroy(!1, g.type), L = {} } } else L = {}; else L = {} }, _getLocalTop: function () { return window.window }, addModule: function (e, t) { T[e] = { creator: t, instance: null, context: null, messages: [] }, this.isInitialized() && this.start(e) }, getModule: function (e) { return T[e] && T[e].instance ? T[e].instance : null }, removeModule: function (e) { this.stop(e), delete T[e] }, isStarted: function (e) { return T.hasOwnProperty(e) && T[e].instance !== null }, start: function (e) { const t = T[e]; let n = null; t && t.instance === null && (t.context = new TLT.ModuleContext(e, this), typeof (n = t.instance = t.creator(t.context)).init === 'function' && n.init()) }, startAll: function () { let e = null; for (e in T)T.hasOwnProperty(e) && this.start(e) }, stop: function (e) { const t = T[e]; let n = null; t && t.instance !== null && (typeof (n = t.instance).destroy === 'function' && n.destroy(), t.instance = t.context = null) }, stopAll: function () { let e = null; for (e in T)T.hasOwnProperty(e) && this.stop(e) }, addService: function (e, t) { S[e] = { creator: t, instance: null } }, getService: function (e) { if (S.hasOwnProperty(e)) { if (!S[e].instance) { try { S[e].instance = S[e].creator(this), typeof S[e].instance.init === 'function' && S[e].instance.init() } catch (t) { throw d.clog('UIC terminated due to error when instanciating the ' + e + ' service.'), t } typeof S[e].instance.getServiceName !== 'function' && (S[e].instance.getServiceName = function () { return e }) } return S[e].instance } return null }, removeService: function (e) { delete S[e] }, broadcast: function (e) { let t, n; if (e && typeof e === 'object') for (t in T)T.hasOwnProperty(t) && (n = T[t], d.indexOf(n.messages, e.type) > -1 && typeof n.instance.onmessage === 'function' && n.instance.onmessage(e)) }, listen: function (e, t) { let n = null; this.isStarted(e) && (n = T[e], d.indexOf(n.messages, t) === -1 && n.messages.push(t)) }, fail: function (e, t, n) { e = 'UIC FAILED. ' + e; try { H.destroy(!!n, e) } catch (t) { d.clog(e) } throw new H.UICError(e, t) }, UICError: (function () { function e (e, t) { this.message = e, this.code = t } return e.prototype = new Error(), e.prototype.name = 'UICError', e.prototype.constructor = e, e }()), getFlavor: function () { return 'w3c' }, isCrossOrigin: function (e, t) { let n; let r; let i = !1; return t = t || window.location.origin, e && t ? (r = e.match(/^\/\//), e.match(/^\//) && !r ? i = !1 : r || e.indexOf('://') !== -1 ? (r && (n = t.indexOf('://')) !== -1 && (t = t.substring(n + 1)), i = e.length < t.length || (t !== e.substring(0, t.length) || e.length > t.length && e.charAt(t.length) !== '/')) : i = !1, i) : i } }; return N = function () { let e = null; const t = d.getValue(u, 'inactivityTimeout', 6e5); function n () { H.destroy(!1, 'inactivity') }t ? (N = function () { e && (clearTimeout(e), e = null), e = setTimeout(n, t) })() : N = function () {} }, P = function (l, f) { let p; let g; let v; let y; let w; let b; let T; let S; let E; let C; let O; let k; let L = null; if (!(_ || TLT && TLT.replay)) if ((r = H.getService('config')).updateConfig(l), E = (function (e, t) { let n; let r; let i; let a; let o = null; if (!e || !t) return o; for (n = 0, r = e.length; n < r; n += 1) switch (typeof (i = e[n])) { case 'object':(a = new RegExp(i.regex, i.flags).exec(t)) && (o = a[0]); break; case 'string':t.indexOf(i) !== -1 && (o = i) } return o }((u = r.getCoreConfig()).blockedUserAgents, navigator.userAgent)), E)TLT.terminationReason = 'blockedUA: ' + E; else if (e = H.getService('ajax'), d.browserBaseService = t = H.getService('browserBase'), d.browserService = n = H.getService('browser'), i = H.getService('domCapture'), a = H.getService('queue'), o = H.getService('serializer'), y = (p = r.getModuleConfig('TLCookie') || {}).sessionizationCookieName || 'TLTSID', (w = d.getCookieValue('TLTSID')) !== 'DND') if ((w = d.getCookieValue(y) || (function (e) { let t, n, r, i; if (localStorage && e) return (r = localStorage.getItem(e)) && (n = r.split('|'), t = parseInt(n[0], 10), Date.now() > t ? localStorage.removeItem(e) : i = n[1]), i }(y))) || (y = p.wcxCookieName || 'WCXSID', w = d.getCookieValue(y)), H._updateModules()) { s = H.getModule('dataLayer'), r.subscribe && r.subscribe('configupdated', H._reinitConfig), _ = !0, x = 'loaded'; try { typeof TLFExtensionNotify === 'function' && TLFExtensionNotify('Initialized') } catch (e) {} for (v = (g = H.getServiceConfig('queue')).queues || [], (d.isLegacyIE || d.isIE9) && (L = d.getOriginAndPath().origin), S = 0; S < v.length; S += 1) { if (L && H.isCrossOrigin(v[S].endpoint, L)) return H.setAutoFlush(!1), void H.destroy(!1, 'CORS not supported'); !w && p.tlAppKey && (b = v[S].endpoint, (T = v[S].killswitchURL || (b.match('collectorPost') ? b.replace('collectorPost', 'switch/' + p.tlAppKey) : null)) && e.sendRequest({ type: 'GET', url: T, async: !0, timeout: 5e3, oncomplete: function (e) { e.responseText !== '0' && e.data !== 0 || (H.setAutoFlush(!1), d.setCookie('TLTSID', 'DND'), H.destroy(!1, 'killswitch')) } })), v[S].checkEndpoint && !g.asyncReqOnUnload && (g.asyncReqOnUnload = !0, e.sendRequest({ oncomplete: function (e) { e.success && (g.asyncReqOnUnload = !1) }, timeout: v[S].endpointCheckTimeout || 3e3, url: v[S].endpoint, headers: { 'X-PageId': m, 'X-Tealeaf-SaaS-AppKey': p.tlAppKey, 'X-Tealeaf-EndpointCheck': !0 }, async: !0, error: function (e) { e.success || (g.endpointCheckFailed = !0) } })) } if (k = function (e) { let r, i; r = { type: 'load', target: window.window, srcElement: window.window, currentTarget: window.window, bubbles: !0, cancelBubble: !1, cancelable: !0, timeStamp: +new Date(), customLoad: !0 }, i = new t.WebEvent(r), H._publishEvent(i), e && n.unsubscribe(C, O, k) }, u.screenviewLoadEvent ? (C = u.screenviewLoadEvent.name, O = u.screenviewLoadEvent.target || window, n.subscribe(C, O, k)) : k(), H.isInitialized() && (x = 'initialized', N(), c = function (e) { e.type === 'mousemove' && (h = !0), n.unsubscribe('mousemove', document, c), c = null }, n.subscribe('mousemove', document, c, { once: !0 })), typeof R === 'function') try { R(x) } catch (e) { d.clog('Error in callback.', e) } } else x !== 'destroyed' && H.destroy(!1, 'modules init'); else x !== 'destroyed' && H.destroy(!1, 'killswitch') }, (function () { let e; let t; let n = null; for (n in O) if (O.hasOwnProperty(n)) for (e = 0, t = O[n].length; e < t; e += 1)!(function (e, t) { H[t] = function () { const n = this.getService(e); if (n) return n[t].apply(n, arguments) } }(n, O[n][e])) }()), H }()), (function () { 'use strict'; let e; let t; let n; const r = window.navigator.userAgent.toLowerCase(); const i = r.indexOf('msie') !== -1 || r.indexOf('trident') !== -1; const a = (n = !!window.performance, i && (!n || document.documentMode < 9)); const o = i && document.documentMode === 9; const s = r.indexOf('android') !== -1; const u = /(ipad|iphone|ipod)/.test(r); const l = r.indexOf('opera mini') !== -1; const c = r.indexOf('chrome') === -1 && r.indexOf('safari') !== -1; let d = 1; const f = { 'a:': 'link', 'button:button': 'button', 'button:submit': 'button', 'input:button': 'button', 'input:checkbox': 'checkBox', 'input:color': 'colorPicker', 'input:date': 'datePicker', 'input:datetime': 'datetimePicker', 'input:datetime-local': 'datetime-local', 'input:email': 'emailInput', 'input:file': 'fileInput', 'input:image': 'button', 'input:month': 'month', 'input:number': 'numberPicker', 'input:password': 'textBox', 'input:radio': 'radioButton', 'input:range': 'slider', 'input:reset': 'button', 'input:search': 'searchBox', 'input:submit': 'button', 'input:tel': 'tel', 'input:text': 'textBox', 'input:time': 'timePicker', 'input:url': 'urlBox', 'input:week': 'week', 'select:': 'selectList', 'select:select-one': 'selectList', 'textarea:': 'textBox', 'textarea:textarea': 'textBox' }; var h = { isIE: i, isLegacyIE: a, isIE9: o, isAndroid: s, isLandscapeZeroDegrees: !1, isiOS: u, isOperaMini: l, isSafari: c, isUndefOrNull: function (e) { return e == null }, isArray: function (e) { return !(!e || Object.prototype.toString.call(e) !== '[object Array]') }, getSerialNumber: function () { let e; return e = d, d += 1, e }, getRandomString: function (e, t) { let n; let r; let i = ''; if (!e) return i; for (typeof t !== 'string' && (t = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'), n = 0, r = t.length; n < e; n += 1)i += t.charAt(Math.floor(Math.random() * r)); return i }, getValue: function (e, t, n) { let r, i, a; if (n = void 0 === n ? null : n, !e || typeof e !== 'object' || typeof t !== 'string') return n; for (r = 0, i = (a = t.split('.')).length; r < i; r += 1) { if (!e || void 0 === e[a[r]]) return n; e = e[a[r]] } return e }, indexOf: function (e, t) { let n, r; if (e && e.indexOf) return e.indexOf(t); if (e && e instanceof Array) for (n = 0, r = e.length; n < r; n += 1) if (e[n] === t) return n; return -1 }, forEach: function (e, t, n) { let r, i; if (e && e.length && t && t.call) for (r = 0, i = e.length; r < i; r += 1)t.call(n, e[r], r, e) }, some: function (e, t) { let n; let r; let i = !1; for (n = 0, r = e.length; n < r; n += 1) if (i = t(e[n], n, e)) return i; return i }, convertToArray: function (e) { for (var t = 0, n = e.length, r = []; t < n;)r.push(e[t]), t += 1; return r }, mixin: function (e) { let t, n, r, i; for (r = 1, i = arguments.length; r < i; r += 1) for (t in n = arguments[r])Object.prototype.hasOwnProperty.call(n, t) && (e[t] = n[t]); return e }, extend: function (e, t, n) { let r = ''; for (r in n)Object.prototype.hasOwnProperty.call(n, r) && (e && Object.prototype.toString.call(n[r]) === '[object Object]' ? (void 0 === t[r] && (t[r] = {}), this.extend(e, t[r], n[r])) : t[r] = n[r]); return t }, clone: function (e) { let t, n; if (e === null || typeof e !== 'object') return e; if (e instanceof Object) { for (n in t = Object.prototype.toString.call(e) === '[object Array]' ? [] : {}, e)Object.prototype.hasOwnProperty.call(e, n) && (t[n] = this.clone(e[n])); return t } }, parseVersion: function (e) { let t; let n; let r = []; if (!e || !e.length) return r; for (t = 0, n = (r = e.split('.')).length; t < n; t += 1)r[t] = /^[0-9]+$/.test(r[t]) ? parseInt(r[t], 10) : r[t]; return r }, isEqual: function (e, t) { let n, r, i, a; if (e === t) return !0; if (typeof e !== typeof t) return !1; if (e instanceof Object && t instanceof Object) { if (Object.prototype.toString.call(e) === '[object Array]' && Object.prototype.toString.call(t) === '[object Array]') { if (e.length !== t.length) return !1; for (n = 0, a = e.length; n < a; n += 1) if (!this.isEqual(e[n], t[n])) return !1; return !0 } if (Object.prototype.toString.call(e) === '[object Object]' && Object.prototype.toString.call(t) === '[object Object]') { for (n = 0; n < 2; n += 1) { for (r in e) if (e.hasOwnProperty(r)) { if (!t.hasOwnProperty(r)) return !1; if (!this.isEqual(e[r], t[r])) return !1 }i = e, e = t, t = i } return !0 } } return !1 }, calculateRelativeXY: function (e) { if (h.isUndefOrNull(e) || h.isUndefOrNull(e.x) || h.isUndefOrNull(e.y) || h.isUndefOrNull(e.width) || h.isUndefOrNull(e.height)) return '0.5,0.5'; let t = Math.abs(e.x / e.width).toFixed(4); let n = Math.abs(e.y / e.height).toFixed(4); return (t = t > 1 || t < 0 ? 0.5 : t) + ',' + (n = n > 1 || n < 0 ? 0.5 : n) }, createObject: (e = null, t = null, typeof Object.create === 'function' ? e = Object.create : (t = function () {}, e = function (e) { if (typeof e !== 'object' && typeof e !== 'function') throw new TypeError('Object prototype need to be an object!'); return t.prototype = e, new t() }), e), access: function (e, t) { let n; let r; let i; let a = t || window; if (typeof e === 'string' && typeof a === 'object') { for (r = 0, i = (n = e.split('.')).length; r < i; r += 1) if (r !== 0 || n[r] !== 'window') { if (!Object.prototype.hasOwnProperty.call(a, n[r])) return; if (a = a[n[r]], r < i - 1 && !(a instanceof Object)) return } return a } }, isNumeric: function (e) { let t = !1; return h.isUndefOrNull(e) || !/\S/.test(e) ? t : t = !isNaN(2 * e) }, isUpperCase: function (e) { return e === e.toUpperCase() && e !== e.toLowerCase() }, isLowerCase: function (e) { return e === e.toLowerCase() && e !== e.toUpperCase() }, extractResponseHeaders: function (e) { let t; let n; const r = {}; let i = null; for (t = 0, n = (e = e && e.length ? e.split('\n') : []).length; t < n; t += 1)(i = e[t].split(': ')).length === 2 && (r[i[0]] = i[1]); return r }, getTargetState: function (e) { const t = this.getTagName(e); let n = { a: ['innerText', 'href'], input: { range: ['maxValue:max', 'value'], checkbox: ['value', 'checked'], radio: ['value', 'checked'], image: ['src'] }, select: ['value'], button: ['value', 'innerText'], textarea: ['value'] }[t] || null; let r = null; let i = null; let a = null; let o = ''; if (n !== null) for (o in Object.prototype.toString.call(n) === '[object Object]' && (n = n[e.type] || ['value']), i = {}, n)n.hasOwnProperty(o) && (n[o].indexOf(':') !== -1 ? i[(a = n[o].split(':'))[0]] = e[a[1]] : n[o] === 'innerText' ? i[n[o]] = this.trim(e.innerText || e.textContent) : i[n[o]] = e[n[o]]); return t === 'select' && e.options && !isNaN(e.selectedIndex) && ((i = i || {}).index = e.selectedIndex, i.index >= 0 && i.index < e.options.length && (r = e.options[e.selectedIndex], i.value = r.getAttribute('value') || r.getAttribute('label') || r.text || r.innerText, i.text = r.text || r.innerText)), i && e.disabled && (i.disabled = !0), i }, getDocument: function (e) { let t = e; return e && e.nodeType !== 9 && (t = e.getRootNode ? e.getRootNode() : e.ownerDocument || e.document), t }, getWindow: function (e) { try { if (e.self !== e) { const t = h.getDocument(e); return h.isUndefOrNull(t.defaultView) ? t.parentWindow : t.defaultView } } catch (t) { e = null } return e }, getOriginAndPath: function (e) { let t; let n; let r; let i; let a; let o; const s = {}; let u = []; const l = {}; (e = e || window.location).origin ? s.origin = e.origin : s.origin = (e.protocol || '') + '//' + (e.host || ''), s.path = (e.pathname || '').split(';', 1)[0], (s.origin.indexOf('file://') > -1 || h.isiOS && window.Ionic) && (t = s.path.match(/(.*)(\/.*app.*)/)) !== null && (s.path = t[2], s.origin = 'file://'), n = e.search || ''; try { new URLSearchParams(n).forEach(function (e, t) { l[t] = e }) } catch (e) { for (n.length > 1 && n.charAt(0) === '?' && (u = decodeURIComponent(n).substring(1).split('&')), a = 0; a < u.length; a += 1)(o = u[a].indexOf('=')) > -1 && (r = u[a].substring(0, o), i = u[a].substring(o + 1), l[r] = i) } return s.queryParams = l, s }, getIFrameWindow: function (e) { let t = null; if (!e) return t; try { t = e.contentWindow || (e.contentDocument ? e.contentDocument.parentWindow : null) } catch (e) {} return t }, getTagName: function (e) { let t = ''; return h.isUndefOrNull(e) ? t : t = e === document || e.nodeType === 9 ? 'document' : e === window || e === window.window ? 'window' : typeof e === 'string' ? e.toLowerCase() : (e.tagName || e.nodeName || '').toLowerCase() }, getTlType: function (e) { let t; let n; let r = ''; return h.isUndefOrNull(e) || !e.type ? r : (n = (t = e.type.toLowerCase()) + ':', e.subType && (n += e.subType.toLowerCase()), r = f[n] || t) }, isIFrameDescendant: function (e) { const t = h.getWindow(e); return !!t && t != TLT._getLocalTop() }, getOrientationMode: function (e) { let t = 'INVALID'; if (typeof e !== 'number') return t; switch (e) { case 0:case 180:case 360:t = 'PORTRAIT'; break; case 90:case -90:case 270:t = 'LANDSCAPE'; break; default:t = 'UNKNOWN' } return t }, getOrientationAngle: function () { if (typeof window.orientation === 'number') return window.orientation; let e = (screen.orientation || {}).angle; if (typeof e !== 'number') switch (screen.mozOrientation || screen.msOrientation) { case 'landscape-primary':case 'landscape-secondary':e = 90; break; default:e = 0 } return e }, clog: (window, function () {}), trim: function (e) { return e && e.toString ? e.trim ? e.trim() : e.toString().replace(/^\s+|\s+$/g, '') : e }, ltrim: function (e) { return e && e.toString ? e.trimStart ? e.trimStart() : e.toString().replace(/^\s+/, '') : e }, rtrim: function (e) { return e && e.toString ? e.trimEnd ? e.trimEnd() : e.toString().replace(/\s+$/, '') : e }, setCookie: function (e, t, n, r, i, a, o) { let s; let u; let l; let c; let d; let f; let h; let p = ''; if (o === 'None' ? a = !0 : o !== 'Lax' && (o = 'Strict'), h = ';SameSite=' + o, f = a ? ';Secure' : '', e) for (e = encodeURIComponent(e), t = encodeURIComponent(t), l = (i || location.hostname).split('.'), d = ';Path=' + (r || '/'), typeof n === 'number' && (this.isIE ? ((c = new Date()).setTime(c.getTime() + 1e3 * n), p = ';Expires=' + c.toUTCString()) : p = ';Max-Age=' + n), s = (u = l.length) === 1 ? 1 : 2; s <= u && (document.cookie = e + '=' + t + ';Domain=' + l.slice(-s).join('.') + d + p + f + h, this.getCookieValue(e) !== t); s += 1)u === 1 && (document.cookie = e + '=' + t + d + p + f + h) }, getCookieValue: function (e, t) { let n; let r; let i; let a; let o; let s = null; try { if (t = t || document.cookie, !e || !e.toString) return null; for (o = (e += '=').length, a = t.split(';'), n = 0, r = a.length; n < r; n += 1) if (i = a[n], (i = h.ltrim(i)).indexOf(e) === 0) { s = i.substring(o, i.length); break } } catch (e) { s = null } return s }, getQueryStringValue: function (e, t, n) { let r; let i; let a; let o; let s = null; try { if (a = (n = n || window.location.search).length, !e || !e.toString || !a) return null; n = (t = t || '&') + n.substring(1), e = t + e + '=', (r = n.indexOf(e)) !== -1 && (o = r + e.length, (i = n.indexOf(t, o)) === -1 && (i = a), s = decodeURIComponent(n.substring(o, i))) } catch (e) {} return s }, addEventListener: window.addEventListener ? function (e, t, n) { e.addEventListener(t, n, !1) } : function (e, t, n) { e.attachEvent('on' + t, n) }, matchTarget: function (e, t) { let n; let r; let i; let a; let o; let s; let u; let l; let c = -1; let d = document; if (!e || !t) return c; for (this.browserService && this.browserBaseService || (this.browserService = TLT.getService('browser'), this.browserBaseService = TLT.getService('browserBase')), t.idType === -2 && (i = this.browserBaseService.getNodeFromID(t.id, t.idType), d = this.getDocument(i)), n = 0, u = e.length; n < u && c === -1; n += 1) if (typeof (l = e[n]) === 'string') { for (r = 0, o = (a = this.browserService.queryAll(l, d)) ? a.length : 0; r < o; r += 1) if (a[r] && (s = this.browserBaseService.ElementData.prototype.examineID(a[r])).idType === t.idType && s.id === t.id) { c = n; break } } else if (l && l.id && l.idType && t.idType && t.idType.toString() === l.idType.toString()) switch (typeof l.id) { case 'string':l.id === t.id && (c = n); break; case 'object':l.cRegex || (l.cRegex = new RegExp(l.id.regex, l.id.flags)), l.cRegex.lastIndex = 0, l.cRegex.test(t.id) && (c = n) } return c }, WeakMap: (function () { function e (e, t) { let n, r; for (n = 0, r = (e = e || []).length; n < r; n += 1) if (e[n][0] === t) return n; return -1 } return function () { let t = []; this.set = function (n, r) { const i = e(t, n); t[i > -1 ? i : t.length] = [n, r] }, this.get = function (n) { const r = t[e(t, n)]; return r ? r[1] : void 0 }, this.clear = function () { t = [] }, this.has = function (n) { return e(t, n) >= 0 }, this.remove = function (n) { const r = e(t, n); r >= 0 && t.splice(r, 1) }, this.delete = this.remove } }()) }; typeof TLT !== 'undefined' && TLT || (window.TLT = {}), TLT.utils = h }()), (function () { 'use strict'; TLT.EventTarget = function () { this._handlers = {} }, TLT.EventTarget.prototype = { constructor: TLT.EventTarget, publish: function (e, t) { let n = 0; let r = 0; const i = this._handlers[e]; const a = { type: e, data: t }; if (void 0 !== i) for (r = i.length; n < r; n += 1)i[n](a) }, subscribe: function (e, t) { this._handlers.hasOwnProperty(e) || (this._handlers[e] = []), this._handlers[e].push(t) }, unsubscribe: function (e, t) { let n = 0; let r = 0; const i = this._handlers[e]; if (i) for (r = i.length; n < r; n += 1) if (i[n] === t) return void i.splice(n, 1) } } }()), TLT.ModuleContext = (function () { 'use strict'; const e = ['broadcast', 'getConfig:getModuleConfig', 'listen', 'post', 'getXPathFromNode', 'performDOMCapture', 'performFormCompletion', 'isInitialized', 'getStartTime', 'normalizeUrl', 'getCurrentOffset', 'getTabId', 'setSessionCookieInfo']; return function (t, n) { let r; let i; const a = {}; let o = null; let s = null; let u = null; for (r = 0, i = e.length; r < i; r += 1)(o = e[r].split(':')).length > 1 ? (u = o[0], s = o[1]) : (u = o[0], s = o[0]), a[u] = (function (e) { return function () { const r = n.utils.convertToArray(arguments); return r.unshift(t), n[e].apply(n, r) } }(s)); return a.utils = n.utils, a } }()), TLT.addService('config', function (e) { 'use strict'; function t (t, n) { e.utils.extend(!0, t, n), r.publish('configupdated', r.getConfig()) } let n = { core: {}, modules: {}, services: {} }; var r = e.utils.extend(!1, e.utils.createObject(new TLT.EventTarget()), { getConfig: function () { return n }, updateConfig: function (e) { t(n, e) }, getCoreConfig: function () { return n.core }, updateCoreConfig: function (e) { t(n.core, e) }, getServiceConfig: function (e) { return n.services[e] || {} }, updateServiceConfig: function (e, r) { void 0 === n.services[e] && (n.services[e] = {}), t(n.services[e], r) }, getModuleConfig: function (e) { return n.modules[e] || {} }, updateModuleConfig: function (e, r) { void 0 === n.modules[e] && (n.modules[e] = {}), t(n.modules[e], r) }, destroy: function () { n = { core: {}, modules: {}, services: {} } } }); return r }), TLT.addService('queue', function (e) { 'use strict'; const t = e.utils; let n = null; let r = {}; let i = 6e5; const a = e.getService('ajax'); const o = e.getService('browser'); const s = e.getService('encoder'); const u = e.getService('serializer'); const l = e.getService('config'); const c = e.getService('message'); let d = null; let f = {}; let h = !0; let p = !0; const g = { 5: { limit: 300, count: 0 }, 6: { limit: 400, count: 0 } }; const m = []; let v = !0; let y = !1; let w = !0; let b = !0; const T = (function () { let t = {}; function n (e) { return void 0 !== t[e] } function r (e) { return n(e) ? t[e] : null } function i (e) { const t = r(e); t !== null && (t.data = []) } return { exists: n, add: function (e, r) { return n(e) || (t[e] = { lastOffset: 0, data: [], queueId: e, url: r.url, eventThreshold: r.eventThreshold, sizeThreshold: r.sizeThreshold || 0, timerInterval: r.timerInterval, size: -1, serializer: r.serializer, encoder: r.encoder, crossDomainEnabled: !!r.crossDomainEnabled, crossDomainIFrame: r.crossDomainIFrame }), t[e] }, remove: function (e) { n(e) && delete t[e] }, reset: function () { t = {} }, get: r, clear: i, flush: function (e) { let t = null; return n(e) && (t = r(e).data, i(e)), t }, push: function (t, i) { let a = null; let o = null; const s = window.tlBridge; const l = window.iOSJSONShuttle; try { o = u.serialize(i) } catch (e) { i = { error: o = 'Serialization failed: ' + (e.name ? e.name + ' - ' : '') + e.message } } if (void 0 !== s && typeof s.addMessage === 'function')s.addMessage(o); else if (void 0 !== l && typeof l === 'function')l(o); else if (n(t)) return (a = r(t)).data.push(i), a.data = e.redirectQueue(a.data), a.sizeThreshold && (o = u.serialize(a.data), a.size = o.length), a.data.length; return 0 } } }()); function S (e) { w && (b = !0), e && e.id && t.extend(!0, m[e.id - 1], { rspEnd: c.getCurrentOffset(), success: e.success, statusCode: e.statusCode, statusText: e.statusText }) } function _ (e, t, n, r) { const i = T.get(e); const a = { name: t, value: n }; typeof t === 'string' && typeof n === 'string' && (i.headers || (i.headers = { once: [], always: [] }), (r ? i.headers.always : i.headers.once).push(a)) } function x (r, o) { let l; let d; let f; let h; let p; let g; const y = T.get(r); let w = y.url ? T.flush(r) : null; const x = w ? w.length : 0; const E = { 'Content-Type': 'application/json', 'X-PageId': e.getPageId(), 'X-Tealeaf': 'device (UIC) Lib/6.4.8', 'X-TealeafType': 'GUI', 'X-TeaLeaf-Page-Url': (g = t.getOriginAndPath(window.location), e.normalizeUrl('', g.path)), 'X-Tealeaf-SyncXHR': (!!o).toString() }; const C = c.getCurrentOffset(); const O = y.serializer || 'json'; const k = y.encoder; const L = n.tltWorker; const M = e.getState() === 'unloading'; const D = t.getOriginAndPath().origin; const I = e.isCrossOrigin(y.url, D); let P = null; if (x && y && (h = C - w[x - 1].offset, !(i && h > i + 6e4))) { if (b = !1, y.lastOffset = w[x - 1].offset, E['X-Tealeaf-MessageTypes'] = (function (e) { let t; let n; const r = []; let i = ''; if (!e || !e.length) return i; for (t = 0, n = e.length; t < n; t += 1)r[e[t].type] = !0; for (t = 0, n = r.length; t < n; t += 1)r[t] && (i && (i += ','), i += t); return i }(w)), l = (w = c.wrapMessages(w)).serialNumber, m[l - 1] = { serialNumber: l, reqStart: C }, v && (w.log = { requests: m }), n.endpointCheckFailed && (w.log.endpointCheckFailed = !0), (function () { let t; let n; let r = 0; const i = e.provideRequestHeaders(); if (i && i.length) for (r = 0, t = i.length; r < t; r += 1)_('DEFAULT', (n = i[r]).name, n.value, n.recurring) }()), (function (e, t) { let n; let r; const i = T.get(e).headers; let a = null; function o (e, t) { let n; let r; let i = null; for (n = 0, r = e.length; n < r; n += 1)t[(i = e[n]).name] = i.value } if (t = t || {}, i) for (n = 0, r = (a = [i.always, i.once]).length; n < r; n += 1)o(a[n], t) }(r, E)), !L || o || M) if (O && (w = u.serialize(w, O)), k && (f = s.encode(w, k)) && (f.data && !f.error && (f.data instanceof window.ArrayBuffer ? f.data.byteLength < w.length ? (w = f.data, E['Content-Encoding'] = f.encoding) : f.error = k + ' encoder did not reduce payload (' + f.data.byteLength + ') compared to original data (' + w.length + ')' : f.error = 'Encoder did not apply ' + k + ' encoding.'), f.error && e.logExceptionEvent('EncoderError: ' + f.error, 'UIC', -1)), y.crossDomainEnabled) { if (!(P = t.getIFrameWindow(y.crossDomainIFrame))) return; if (d = { request: { id: l, url: y.url, async: !o, headers: E, data: w } }, typeof window.postMessage === 'function')P.postMessage(d, y.crossDomainIFrame.src); else try { P.sendMessage(d) } catch (e) { return }b = !0 } else a.sendRequest({ id: l, oncomplete: S, url: y.url, async: !o, isUnloading: M, isCrossOrigin: I, headers: E, data: w }); else L.onmessage = function (e) { S(e.data) }, p = { id: l, url: y.url, headers: E, data: w, isUnloading: M, isCrossOrigin: I }, L.postMessage(p); !(function (e) { let t; let n = null; if (!T.exists(e)) throw new Error('Queue: ' + e + ' does not exist!'); (n = (t = T.get(e)) ? t.headers : null) && (n.once = []) }(r)) } } function E (e) { let t; const r = n.queues; for (t = 0; t < r.length; t += 1)x(r[t].qid, e); return !0 } function C (t, r) { let a; let o; let s; const u = c.createMessage(r); const l = T.get(t); if ((a = l.data.length) && (s = u.offset - l.data[a - 1].offset, i && s > i)) return e.setAutoFlush(!1), void e.destroy(!1, 'inactivity(2)'); a = T.push(t, u), o = l.size, w && !b || (a >= l.eventThreshold || o >= l.sizeThreshold) && h && e.getState() !== 'unloading' && (e.getCurrentWebEvent().type !== 'click' || n.ddfoc ? x(t) : p && (p = !1, window.setTimeout(function () { T.exists(t) && (x(t), p = !0) }, 500))) } function O (e, t) { f[e] = window.setTimeout(function n () { h && (!w || w && b) && x(e), f[e] = window.setTimeout(n, t) }, t) } function k (e) { let t = !1; return e && f[e] && (window.clearTimeout(f[e]), delete f[e], t = !0), t } function L (e) {} function M () { h && E(!n.asyncReqOnUnload), l.unsubscribe('configupdated', L), (function () { let e = 0; for (e in f)f.hasOwnProperty(e) && k(e); f = {} }()), T.reset(), n = null, d = null, y = !1 } return { init: function () { let a; y || (a = l.getServiceConfig('queue') || {}, n = a, r = e.getCoreConfig(), i = t.getValue(r, 'inactivityTimeout', 6e5), w = t.getValue(n, 'serializePost', !0), t.forEach(n.queues, function (t, n) { let r = null; t.qid === 'DEFAULT' && (d = t), t.crossDomainEnabled && ((r = o.query(t.crossDomainFrameSelector)) || e.fail('Cross domain iframe not found')), T.add(t.qid, { url: t.endpoint, eventThreshold: t.maxEvents, sizeThreshold: t.maxSize || 0, serializer: t.serializer, encoder: t.encoder, timerInterval: t.timerInterval || 0, crossDomainEnabled: t.crossDomainEnabled || !1, crossDomainIFrame: r }), void 0 !== t.timerInterval && t.timerInterval > 0 && O(t.qid, t.timerInterval) }), l.subscribe('configupdated', L), y = !0) }, destroy: function () { M() }, _getQueue: function (e) { return T.get(e).data }, setAutoFlush: function (e) { h = !0 === e }, flush: function (e) { if (e = e || d.qid, !T.exists(e)) throw new Error('Queue: ' + e + ' does not exist!'); x(e) }, flushAll: function (e) { return E(!!e) }, post: function (t, r, i) { let a, o, s; e.isInitialized() && (i = i || (function (e) { let t; let r; let i; let a; let o = null; const s = n.queues; for (t = 0, i = s.length; t < i; t += 1) if ((o = s[t]) && o.modules) for (r = 0, a = o.modules.length; r < a; r += 1) if (o.modules[r] === e) return o.qid; return d.qid }(t)), T.exists(i) && (s = !1, (a = r) && a.type && ((o = g[a.type]) && (o.count += 1, o.count > o.limit && (s = !0, o.count === o.limit + 1 && C('DEFAULT', { type: 16, dataLimit: { messageType: a.type, maxCount: o.limit } }))), !s) && C(i, r))) }, resetFlushTimer: function (e) { let t, n; (e = e || d.qid, T.exists(e)) && ((t = e) && k(t) && (n = T.get(t)).timerInterval && O(t, n.timerInterval)) }, setXHRLog: function () { v = !v } } }), TLT.addService('browserBase', function (e) { 'use strict'; let t; let n; let r; let i; let a; let o; let s; let u; let l; const c = e.utils; const d = { optgroup: !0, option: !0, nobr: !0 }; const f = {}; let h = null; let p = !1; const g = 5; const m = 60; function v () { n = e.getService('config'), h = e.getService('serializer'), r = n ? n.getServiceConfig('browser') : {}, i = r.blacklist || [], a = r.customid || [], o = c.getValue(r, 'normalizeTargetToParentLink', !0), s = c.getValue(r, 'logAttributes', []) } function y (e, t) { let n, r, a; if (!e) return null; if (!(a = void 0 !== t ? t : e.id) || typeof a !== 'string') return null; for (n = 0, r = i.length; n < r; n += 1) if (typeof i[n] === 'string') { if (a === i[n]) return null } else if (typeof i[n] === 'object' && (i[n].cRegex || (i[n].cRegex = new RegExp(i[n].regex, i[n].flags)), i[n].cRegex.lastIndex = 0, i[n].cRegex.test(a))) return null; return a } function w (e) { let t = 'null'; return e && e.length ? t = h.serialize(e, 'json') : t } function b (e, t, n, r) { let i; return i = u(e, !!t, !!r), n ? i : w(i) } function T (e) { return e && void 0 !== e.originalEvent && void 0 !== e.isDefaultPrevented && !e.isSimulated } function S (e) { return e ? (e.type && e.type.indexOf('touch') === 0 && (T(e) && (e = e.originalEvent), e.type === 'touchstart' ? e = e.touches[e.touches.length - 1] : e.type === 'touchend' && (e = e.changedTouches[0])), e) : null } function _ (e) { let t = 0; let n = 0; const r = document.documentElement; const i = document.body; return (e = S(e)) && (e.pageX || e.pageY ? (t = e.pageX, n = e.pageY) : (e.clientX || e.clientY) && (t = e.clientX + (r ? r.scrollLeft : i ? i.scrollLeft : 0) - (r ? r.clientLeft : i ? i.clientLeft : 0), n = e.clientY + (r ? r.scrollTop : i ? i.scrollTop : 0) - (r ? r.clientTop : i ? i.clientTop : 0))), { x: t, y: n } } function x (e, t) { this.x = Math.round(e || 0), this.y = Math.round(t || 0) } function E (e, t) { this.width = Math.round(e || 0), this.height = Math.round(t || 0) } function C (e, t) { let n, r, i, a, u, l; t = (function (e) { let t; let n; let r; let i = null; if (!e || !e.type) return null; if (e.type.indexOf('touch') === 0)i = S(e).target; else if (typeof e.composedPath === 'function') if ((r = e.composedPath()) && r.length) { if (i = r[0], o) for (t = 0, n = r.length; t < n; t += 1) if (c.getTagName(r[t]) === 'a') { i = r[t]; break } } else i = e.target || window.window; else i = e.srcElement ? e.srcElement : e.target; for (;i && d[c.getTagName(i)] && i.parentElement;)i = i.parentElement; return i.nodeType === 9 && i.documentElement && (i = i.documentElement), i }(e)), n = this.examineID(t), l = { type: null, subType: null }, i = (u = t) ? (l.type = c.getTagName(u), l.subType = u.type || null, l) : l, a = this.examinePosition(e, t), (r = t && t.getAttribute ? t.getAttribute('aria-label') : null) && (this.accessibility = { id: r }), this.attributes = (function (e) { let t; let n; let r; let i; let a; const o = {}; if (!e || !e.hasAttribute) return o; for (t = 0, n = s.length, a = 0; t < n && a < g; t += 1)r = s[t], e.hasAttribute(r) && (i = e.getAttribute(r) || '', o[r] = i.slice(0, m), a += 1); return o }(t)), t && t.innerText && (this.attributes.innerText = c.trim(t.innerText).slice(0, m)), this.element = t, this.id = n.id, this.idType = n.idType, this.type = i.type, this.subType = i.subType, this.state = this.examineState(t), this.position = new x(a.x, a.y), this.position.relXY = a.relXY, this.size = new E(a.width, a.height), this.xPath = n.xPath, this.name = n.name } function O (e) { let t, n, r, i; if (!e || !e.getBoundingClientRect) return { x: 0, y: 0, width: 0, height: 0 }; try { t = e.getBoundingClientRect(), i = (function (e) { let t; const n = { left: -1, top: -1 }; return t = (e = e || document).documentElement || e.body.parentNode || e.body, n.left = Math.round(typeof window.pageXOffset === 'number' ? window.pageXOffset : t.scrollLeft), n.top = Math.round(typeof window.pageYOffset === 'number' ? window.pageYOffset : t.scrollTop), n }(document)) } catch (e) { return { x: 0, y: 0, width: 0, height: 0 } } return n = { x: t.left + i.left, y: t.top + i.top, width: t.right - t.left, height: t.bottom - t.top }, c.isIE && (n.x -= document.documentElement.clientLeft, n.y -= document.documentElement.clientTop, r = (function () { let e; let t; let n; let r = 1; if (document.body.getBoundingClientRect) { try { e = document.body.getBoundingClientRect() } catch (e) { return r }t = e.right - e.left, n = document.body.offsetWidth, r = Math.round(t / n * 100) / 100 } return r }()), r !== 1 && (n.x = Math.round(n.x / r), n.y = Math.round(n.y / r), n.width = Math.round(n.width / r), n.height = Math.round(n.height / r))), n } function k () { let e = c.getOrientationAngle(); return c.isLandscapeZeroDegrees && (Math.abs(e) === 180 || Math.abs(e) === 0 ? e = 90 : Math.abs(e) !== 90 && Math.abs(e) !== 270 || (e = 0)), e } function L (n) { let r; return t = (function (t) { let n, r, i, a, o; if (t) return t; for (o in t = {}, a = (e.getCoreConfig() || {}).modules) if (a.hasOwnProperty(o) && a[o].events) for (n = 0, r = a[o].events.length; n < r; n += 1)(i = a[o].events[n]).state && (t[i.name] = i.state); return t }(t)), t[n.type] && (r = c.getValue(n, t[n.type], null)), r } function M (e) { let t, n, r; this.data = e.data || null, this.delegateTarget = e.delegateTarget || null, (e.gesture || e.originalEvent && e.originalEvent.gesture) && (this.gesture = e.gesture || e.originalEvent.gesture, this.gesture.idType = new C(this.gesture, this.gesture.target).idType), t = _(e = (function (e) { let t; let n; let r = e || window.event; const i = document.documentElement; const a = document.body; let o = !1; let s = null; if (T(r) && (r = r.originalEvent), void 0 !== e && void 0 !== r.target || (r.target = r.srcElement || window.window, r.timeStamp = Number(new Date()), r.pageX !== null && void 0 !== r.pageX || (r.pageX = r.clientX + (i && i.scrollLeft || a && a.scrollLeft || 0) - (i && i.clientLeft || a && a.clientLeft || 0), r.pageY = r.clientY + (i && i.scrollTop || a && a.scrollTop || 0) - (i && i.clientTop || a && a.clientTop || 0)), r.preventDefault = function () { this.returnValue = !1 }, r.stopPropagation = function () { this.cancelBubble = !0 }), r.type === 'click') { for (t = r.composedPath ? r.composedPath() : [], n = 0; n < t.length; n += 1) if (c.getTagName(t[n]) === 'button') { o = !0, s = t[n]; break } if (o) return { originalEvent: r, target: s, srcElement: s, type: r.type, pageX: r.pageX, pageY: r.pageY } } return r }(e))), this.custom = !1, this.nativeEvent = !0 === this.custom ? null : e, this.position = new x(t.x, t.y), this.target = new C(e, e.target), this.orientation = k(), (r = L(e)) && (this.target.state = r), this.timestamp = (new Date()).getTime(), n = (function (e, t) { let n; const r = { type: null, subType: null }; if (!e) return r; switch (n = e.type) { case 'focusin':n = 'focus'; break; case 'focusout':n = 'blur' } return r.type = n, r }(e, this.target)), this.type = n.type, this.subType = n.subType } function D (e, t, n) { let r; let i; let a; let o = []; return this instanceof D ? e && e.nodeType ? (e.nodeType === 3 && (e = e.parentElement), r = (a = u(e, !1, t, n))[0], o = a.length && (r.length === 1 || r.length === 2 && r[1] === 'h') ? u(e, !0, t) : c.clone(a), this.xpath = w(a), this.xpathList = a, this.fullXpath = w(o), this.fullXpathList = o, i = o[o.length - 1], this.isShadowHost = !!i && i[i.length - 1] === 'h', this.applyPrefix = function (e) { let t, n; e instanceof D && e.fullXpathList.length && (n = e.fullXpathList[e.fullXpathList.length - 1], t = this.fullXpathList.shift(), c.isEqual(t[0], n[0]) ? (this.fullXpathList = e.fullXpathList.concat(this.fullXpathList), this.fullXpath = w(this.fullXpathList), (t = this.xpathList.shift()).length !== 1 ? (this.xpathList = e.xpathList.concat(this.xpathList), this.xpath = w(this.xpathList)) : this.xpathList.unshift(t)) : this.fullXpathList.unshift(t)) }, this.compare = function (e) { return e instanceof D ? this.fullXpathList.length - e.fullXpathList.length : 0 }, this.isSame = function (e) { let t = !1; return e instanceof D ? (this.compare(e) === 0 && (t = this.fullXpath === e.fullXpath), t) : t }, void (this.containedIn = function (e, t) { let n, r, i, a; if (!(e instanceof D)) return !1; if (e.fullXpathList.length > this.fullXpathList.length) return !1; for (n = 0, i = e.fullXpathList.length; n < i; n += 1) if (!c.isEqual(e.fullXpathList[n], this.fullXpathList[n])) return !1; if (!t) for (r = n, i = this.fullXpathList.length; r < i; r += 1) if ((a = this.fullXpathList[r])[a.length - 1] === 'h') return !1; return !0 })) : (this.fullXpath = '', this.xpath = '', this.fullXpathList = [], void (this.xpathList = [])) : null } return l = { nobr: !0 }, u = function (t, n, r, i) { let a; let o; let s; let u; const d = document.documentElement; let f = null; let h = null; let p = null; const g = []; let m = !0; const v = e._getLocalTop(); let w = ''; let b = !1; if (!t || !t.nodeType) return g; if (t.nodeType === 11) { if (!(t = t.host)) return g; b = !0 } for (;m;) if (m = !1, (w = c.getTagName(t)) !== 'window') if (w && !b && l[w])t = t.parentNode, m = !0; else { for (o = y(t, i); t && (t.nodeType === 1 || t.nodeType === 9) && t !== document && (n || !o); o = y(t)) if (p = t.parentNode) { if (!(f = p.firstChild)) { g.push(['XPath Error(1)']), t = null; break } for (a = 0; f; f = f.nextSibling) if (f.nodeType === 1 && c.getTagName(f) === w) { if (f === t) { s = [w, a], b && (s.push('h'), b = !1), g[g.length] = s; break }a += 1 }p.nodeType === 11 ? (t = p.host, b = !0) : t = p, w = c.getTagName(t) } else { if (!(h = c.getWindow(t)) || r) return s = [w, 0], g[g.length] = s, g.reverse(); if (h === v) return g.reverse(); t = h.frameElement, w = c.getTagName(t), p = t.parentNode }o && !n && (s = [o], b && (s.push('h'), b = !1), g[g.length] = s, c.isIFrameDescendant(t) ? (m = !0, t = c.getWindow(t).frameElement) : r || d.contains(t) || t.getRootNode && (u = t.getRootNode()) && (t = u.host, b = !0, m = !0)), i = void 0 } return g.reverse() }, f.xpath = function (e, t) { let n; let r; let i; let a; let o; let s; let u; let l; let d = null; let f = !1; if (!e) return null; if (n = h.parse(e), r = t = t || document, !n) return null; for (a = 0, u = n.length; a < u && r; a += 1) { if (f = (d = n[a]).length > 1 && d[d.length - 1] === 'h', d.length === 1 || d.length === 2 && f)r = t.getElementById ? t.getElementById(d[0]) : t.querySelector ? t.querySelector('#' + d[0]) : null; else { for (o = 0, s = -1, l = r.childNodes.length; o < l; o += 1) if (r.childNodes[o].nodeType === 1 && c.getTagName(r.childNodes[o]) === d[0].toLowerCase() && (s += 1) === d[1]) { r = r.childNodes[o]; break } if (s !== d[1]) return null } if (!r) return null; if (f && a < u - 1) { if (!r.shadowRoot) return null; t = r = r.shadowRoot }((i = c.getTagName(r)) === 'frame' || i === 'iframe') && a < u - 1 && (t = r = c.getIFrameWindow(r).document) } return r !== t && r ? r : null }, C.HTML_ID = -1, C.XPATH_ID = -2, C.ATTRIBUTE_ID = -3, C.prototype.examineID = function (e, t) { let n; let r; const i = { id: '', idType: 0, xPath: '', name: '' }; let o = a.length; const s = document.documentElement; if (!e) return i; i.xPath = b(e, !1, !1, t), i.name = e.name; try { if (r = typeof s.contains !== 'function' || s.contains(e), (t || r) && (!c.getWindow(e) || !c.isIFrameDescendant(e))) if (y(e))i.id = e.id, i.idType = C.HTML_ID; else if (a.length && e.attributes) for (;o;)o -= 1, void 0 !== (n = e.attributes[a[o]]) && (i.id = a[o] + '=' + (n.value || n), i.idType = C.ATTRIBUTE_ID) } catch (e) {} return i.id || (i.id = i.xPath, i.id !== 'null' && (i.idType = C.XPATH_ID)), i }, C.prototype.examineState = function (e) { return c.getTargetState(e) }, C.prototype.examinePosition = function (e, t) { const n = _(e); const r = O(t); return r.x = n.x || n.y ? Math.round(Math.abs(n.x - r.x)) : r.width / 2, r.y = n.x || n.y ? Math.round(Math.abs(n.y - r.y)) : r.height / 2, r.relXY = c.calculateRelativeXY(r), r }, D.prototype = {}, { init: function () { p || (v(), n && n.subscribe('configupdated', v), p = !0) }, destroy: function () { n && n.unsubscribe('configupdated', v), p = !1 }, WebEvent: M, ElementData: C, Xpath: D, processDOMEvent: function (t) { e.isInitialized() && e._publishEvent(new M(t)) }, getNormalizedOrientation: k, getXPathFromNode: function (e, t, n, r, i) { return b(t, n, r, i) }, getNodeFromID: function (e, t, n) { let r; let i; const a = '-1'; const o = '-2'; const s = '-3'; let u = null; return e && t ? (r = n || window.document, (t = t.toString()) === a ? r.getElementById ? u = r.getElementById(e) : r.querySelector && (u = r.querySelector('#' + e)) : t === s ? (i = e.split('='), r.querySelector && (u = r.querySelector('[' + i[0] + '="' + i[1] + '"]'))) : t === o && (u = f.xpath(e, r)), u) : u }, queryDom: f } }), TLT.addService('browser', function (e) { 'use strict'; let t; const n = e.utils; const r = e.getService('config'); const i = e.getService('browserBase'); let a = null; let o = null; const s = r ? r.getServiceConfig('browser') : {}; const u = n.getValue(s, 'useCapture', !0); const l = n.getValue(s, 'usePassive', !0); let c = !1; const d = { NO_QUERY_SELECTOR: 'NOQUERYSELECTOR' }; const f = { list2Array: function (e) { let t; const n = e.length; const r = []; if (void 0 === e.length) return [e]; for (t = 0; t < n; t += 1)r[t] = e[t]; return r }, find: function (e, t, n) { return n = n || 'css', this.list2Array(this[n](e, t)) }, css: function (e, t) { return (t = t || document).querySelectorAll(e) } }; const h = (t = new n.WeakMap(), { add: function (e) { let n; const r = t.get(e) || [(n = e, function (e) { const t = new i.WebEvent(e); e.type === 'resize' || e.type === 'hashchange' ? setTimeout(function () { n(t) }, 5) : n(t) }), 0]; return r[1] += 1, t.set(e, r), r[0] }, find: function (e) { const n = t.get(e); return n ? n[0] : null }, remove: function (e) { const n = t.get(e); n && (n[1] -= 1, n[1] <= 0 && t.remove(e)) } }); function p (e) { const t = { capture: u, passive: l }; return n.isIE ? u : n.mixin(t, e) } function g () { if (f.xpath = i.queryDom.xpath, document.querySelectorAll || e.fail('querySelectorAll does not exist!', d.NO_QUERY_SELECTOR), typeof document.addEventListener === 'function')a = function (e, t, n, r) { r = p(r), e.addEventListener(t, n, r) }, o = function (e, t, n, r) { r = p(r), e.removeEventListener(t, n, r) }; else { if (void 0 === document.attachEvent) throw new Error('Unsupported browser'); a = function (e, t, n) { e.attachEvent('on' + t, n) }, o = function (e, t, n) { e.detachEvent('on' + t, n) } }c = !0 } return { init: function () { c || g() }, destroy: function () { c = !1 }, getServiceName: function () { return 'W3C' }, query: function (e, t, n) { try { return f.find(e, t, n)[0] || null } catch (e) { return [] } }, queryAll: function (e, t, n) { try { return f.find(e, t, n) } catch (e) { return [] } }, matches: function (e, t) { let n = !1; try { t && e && (t.matches ? n = t.matches(e) : t.msMatchesSelector && (n = t.msMatchesSelector(e))) } catch (e) {} return n }, subscribe: function (e, t, n, r) { const i = h.add(n); a(t, e, i, r) }, unsubscribe: function (e, t, n, r) { const i = h.find(n); if (i) { try { o(t, e, i, r) } catch (e) {}h.remove(n) } } } }), TLT.addService('ajax', function (e) { 'use strict'; let t; const n = e.utils; let r = !1; let i = !1; let a = !1; function o (e) { let t; const n = (function (e) { let t = ''; let n = '?'; for (t in e)e.hasOwnProperty(t) && (n += encodeURIComponent(t) + '=' + encodeURIComponent(e[t]) + '&'); return n.slice(0, -1) }(e.headers)); return t = typeof e.data === 'string' ? e.data : e.data ? new Uint8Array(e.data) : '', navigator.sendBeacon(e.url + n, t) } function s (e) { let r; let i; let a = t(); let o = [['X-Requested-With', 'XMLHttpRequest']]; let s = 0; const u = typeof e.async !== 'boolean' || e.async; let l = ''; let c = null; for (e.headers && (o = o.concat(function (e) { let t = ''; const n = []; for (t in e)e.hasOwnProperty(t) && n.push([t, e[t]]); return n }(e.headers))), e.contentType && o.push(['Content-Type', e.contentType]), a.open(e.type.toUpperCase(), e.url, u), r = 0, i = o.length; r < i; r += 1)(l = o[r])[0] && l[1] && a.setRequestHeader(l[0], l[1]); e.error && (e.error = (function (e) { if (typeof e === 'function') return function (t) { let r; let i; let a = !1; if (t) { if (!(r = t.target)) return e(t); (i = r.status) >= 200 && i < 300 && (a = !0), e({ headers: n.extractResponseHeaders(r.getAllResponseHeaders()), responseText: r.responseText, statusCode: i, statusText: r.statusText, id: r.id, success: a }) } } }(e.error)), a.addEventListener('error', e.error)), a.onreadystatechange = c = function () { a.readyState === 4 && (a.onreadystatechange = c = function () {}, e.timeout && window.clearTimeout(s), e.oncomplete({ id: e.id, headers: n.extractResponseHeaders(a.getAllResponseHeaders()), responseText: a.responseText || null, statusCode: a.status, statusText: a.statusText, success: a.status >= 200 && a.status < 300 }), a = null) }, a.send(e.data || null), c(), e.timeout && (s = window.setTimeout(function () { a && (a.onreadystatechange = function () {}, a.readyState !== 4 && (a.abort(), typeof e.error === 'function' && e.error({ id: e.id, statusCode: a.status, statusText: 'timeout', success: !1 })), e.oncomplete({ id: e.id, headers: n.extractResponseHeaders(a.getAllResponseHeaders()), responseText: a.responseText || null, statusCode: a.status, statusText: 'timeout', success: !1 }), a = null) }, e.timeout)) } return { init: function () { let o; a || (o = e.getServiceConfig('queue'), t = void 0 !== window.XMLHttpRequest ? function () { return new XMLHttpRequest() } : function () { return new ActiveXObject('Microsoft.XMLHTTP') }, o && (r = n.getValue(o, 'useBeacon', !0) && typeof navigator.sendBeacon === 'function', i = n.getValue(o, 'useFetch', !0) && typeof window.fetch === 'function'), a = !0) }, destroy: function () { a = !1 }, sendRequest: function (e) { let t = !0; e.type = e.type || 'POST', !e.isUnloading && e.async || !r || (t = !1, o(e) || (t = !0)), t && (e.async && i && !e.timeout ? (function (e) { const t = e.headers || {}; const n = e.id || 0; const r = { method: e.type, headers: t, body: e.data, mode: e.isCrossOrigin ? 'cors' : 'same-origin', credentials: e.isCrossOrigin ? 'omit' : 'same-origin', keepalive: !e.isCrossOrigin && e.isUnloading, cache: 'no-store' }; const i = e.oncomplete || function () {}; t['X-Requested-With'] = 'fetch', window.fetch(e.url, r).then(function (e) { const t = { success: e.ok, statusCode: e.status, statusText: e.statusText, id: n }; t.success ? e.text().then(function (e) { try { t.data = JSON.parse(e) } catch (n) { t.data = e }i(t) }).catch(function (e) { t.statusCode = 1, t.statusText = e.message, i(t) }) : i(t) }).catch(function (e) { const t = { success: !1, statusCode: 2, statusText: e.message, id: n }; i(t) }) }(e)) : s(e)) } } }), TLT.addService('domCapture', function (e) { 'use strict'; let t; let n; let r; let i; let a; let o; let s; let u = e.getService('config'); const l = e.getService('browserBase'); const c = e.getService('browser'); const d = { maxMutations: 100, maxLength: 1e6, captureShadowDOM: !1, captureDynamicStyles: !1, captureHREFStyles: !1, captureFrames: !1, removeScripts: !0, removeComments: !0, captureStyle: !0 }; const f = { childList: !0, attributes: !0, attributeOldValue: !0, characterData: !0, subtree: !0 }; let h = void 0 !== window.MutationObserver; let p = f; const g = []; const m = []; const v = []; let y = []; let w = []; let b = []; let T = 0; let S = 100; let _ = !1; let x = !1; let E = !1; let C = function () {}; let O = function () {}; const k = e._publishEvent; let L = !1; const M = e.utils; const D = Object.getOwnPropertyDescriptor(Document.prototype, 'styleSheets'); const I = Object.getOwnPropertyDescriptor(Document.prototype, 'adoptedStyleSheets'); const P = {}; const R = {}; const A = {}; function N (e) { let t, n; if (e) for (t = 0, n = e.length; t < n; t += 1) delete e[t].oldValue; return e } function z (e, t) { let n; let r; let i = -1; if (!e || !t) return i; for (n = 0, r = e.length; n < r; n += 1) if (e[n].name === t) { i = n; break } return i } function V (e, t) { let n, r, i, a; for (n = 0, r = e.length, a = !1; n < r; n += 1) if ((i = e[n]).name === t.name) { i.oldValue === t.value ? e.splice(n, 1) : i.value = t.value, a = !0; break } return a || e.push(t), e } function F (e, t) { let n; let r; let i; let a; let o; let s; let u; let l = 0; for (e.removedNodes = t.removedNodes.length, e.addedNodes = M.convertToArray(t.addedNodes), n = 0, a = y.length; n < a; n += 1) if (s = y[n], e.isSame(s)) { if (e.removedNodes) for (r = 0; r < t.removedNodes.length; r += 1)(i = s.addedNodes.indexOf(t.removedNodes[r])) !== -1 && (s.addedNodes.splice(i, 1), e.removedNodes -= 1); if (s.removedNodes += e.removedNodes, s.addedNodes.concat(e.addedNodes), !s.removedNodes && !s.addedNodes.length) { for (u = !1, r = 0; r < y.length; r += 1) if (s !== y[r] && y[r].containedIn(s)) { u = !0; break }u || (y.splice(n, 1), l = -1) }o = !0; break } return o || (y.push(e), l = 1), l } function H (e, t) { let n; let r; let i; let a; let o; let s = !1; for (n = 0, i = y.length; !s && n < i; n += 1) if (o = y[n], e.containedIn(o)) for (a = o.addedNodes, r = 0; r < a.length; r += 1) if (a[r].contains && a[r].contains(t)) { s = !0; break } return s } function U (e, n) { let r; let i; let a; let o; let s; let u = null; let c = 0; if ((a = n.attributeName) === 'checked' || a === 'selected') { if (u = l.ElementData.prototype.examineID(n.target), t.isPrivacyMatched(u)) return c; u = null } if (a === 'value' && ((u = l.ElementData.prototype.examineID(n.target)).currState = M.getTargetState(n.target) || {}, u.currState.value ? t.applyPrivacyToTarget(u) : u = null), e.attributes = [{ name: a, oldValue: n.oldValue, value: u ? u.currState.value : n.target.getAttribute(a) }], (o = e.attributes[0]).oldValue === o.value) return c; for (r = 0, i = b.length, s = !1; r < i; r += 1) if (u = b[r], e.isSame(u)) { u.attributes = V(u.attributes, o), u.attributes.length ? H(e, n.target) && (b.splice(r, 1), c = -1) : (b.splice(r, 1), c = -1), s = !0; break } return s || H(e, n.target) || (b.push(e), c = 1), c } function X () { return new window.MutationObserver(function (t) { t && (!(function (e) { let t, n, r, i, a; if (e && e.length) if (_)T += e.length; else { for (t = 0, n = e.length; t < n && T < S; t += 1) if (i = e[t], (a = new l.Xpath(i.target)) && (r = a.fullXpathList).length && r[0][0] === 'html') switch (i.type) { case 'characterData':case 'childList':T += F(a, i); break; case 'attributes':T += U(a, i); break; default:M.clog('Unknown mutation type: ' + i.type) }T >= S && (_ = !0, T += n - t) } }(t)), M.clog('Processed [' + t.length + '] mutation records.'), e.invokeMutationCallbacks(t)) }) } function j (e) { const t = i.call(this, e); return r && t && r.observe(t, p), t } function q (e, t) { return this.updateOwner(), this.insertRuleOriginal(e, t) } function B (e) { this.deleteRuleOriginal(e), this.updateOwner() } function Y (e) { this.replaceSyncOriginal(e), this.updateOwner() } function W (e) { this.replaceOriginal(e), this.updateOwner() } function K () { if (this.ownersReference) for (let e = Object.keys(this.ownersReference), t = 0; t < e.length; t += 1) { const n = e[t]; P[n] || (w.push(n), P[n] = !0) } } function Q (e) { this.ownersReference || (this.ownersReference = {}), this.ownersReference[e] = !0, P[e] = !0 } function J (e) { this.ownersReference && delete this.ownersReference[e] } function G (e) { e.domId = Math.random().toString(16).slice(2), R[e.domId] = e, P[e.domId] = !0; let t = [].concat.apply([], e.adoptedStyleSheets); if (t = t.concat.apply(t, e.styleSheets)) for (let n = 0; n < t.length; n += 1) { const r = t[n]; r.ownersReference || (r.ownersReference = {}), r.ownersReference[e.domId] = !0 } } function Z (e) { const t = Object.getOwnPropertyDescriptor(e.Document.prototype, 'adoptedStyleSheets'); const n = Object.getOwnPropertyDescriptor(e.Document.prototype, 'styleSheets'); return Object.defineProperty(e.Document.prototype, 'adoptedStyleSheets', { set: function (e) { let n, r; if (this.domId || G(this), (r = this.adoptedStyleSheets).length > 0) for (n = 0; n < r.length; n += 1)r[n].removeOwnership(this.domId); for (n = 0; n < e.length; n += 1)e[n].publishOwnership(this.domId); return t.set.call(this, e) } }), Object.defineProperty(e.Document.prototype, 'styleSheets', { get: function () { let e, t; for (t = n.get.call(this), this.domId || G(this), e = 0; e < t.length; e += 1)t[e].publishOwnership(this.domId); return t } }), e.CSSStyleSheet.prototype.insertRuleOriginal = e.CSSStyleSheet.prototype.insertRule, e.CSSStyleSheet.prototype.deleteRuleOriginal = e.CSSStyleSheet.prototype.deleteRule, e.CSSStyleSheet.prototype.insertRule = q, e.CSSStyleSheet.prototype.deleteRule = B, e.CSSStyleSheet.prototype.replaceSyncOriginal = e.CSSStyleSheet.prototype.replaceSync, e.CSSStyleSheet.prototype.replaceOriginal = e.CSSStyleSheet.prototype.replace, e.CSSStyleSheet.prototype.replaceSync = Y, e.CSSStyleSheet.prototype.replace = W, e.CSSStyleSheet.prototype.publishOwnership = Q, e.CSSStyleSheet.prototype.removeOwnership = J, void (e.CSSStyleSheet.prototype.updateOwner = K) } function $ (a) { let l; let c; let m; let y; let w; let b; const T = u.getCoreConfig(); if (u.subscribe('configupdated', O), t = e.getService('message'), (n = a).options = M.mixin({}, d, n.options), h = h && M.getValue(n, 'diffEnabled', !0), S = M.getValue(n.options, 'maxMutations', 100), h && (p = M.getValue(n, 'diffObserverConfig', f), r = X(), g.push(window)), (b = n.options.captureShadowDOM && Element.prototype.attachShadow) && window.ShadyDOM && window.ShadyDOM.inUse && (n.options.captureShadowDOM = !1, b = !1), b) for (m in T.modules) if (T.modules.hasOwnProperty(m)) for (l = 0, c = (w = T.modules[m].events || []).length; l < c; l += 1)w[l].attachToShadows && (y = w[l].name, M.indexOf(v, y) === -1 && v.push(y)); n.options.captureDynamicStyles && document.adoptedStyleSheets && (Z(window), b && (o = Object.getOwnPropertyDescriptor(ShadowRoot.prototype, 'adoptedStyleSheets'), s = Object.getOwnPropertyDescriptor(ShadowRoot.prototype, 'styleSheets'), Object.defineProperty(ShadowRoot.prototype, 'adoptedStyleSheets', { set: function (e) { let t, n; if (this.domId || G(this), (n = this.adoptedStyleSheets).length > 0) for (t = 0; t < n.length; t += 1)n[t].removeOwnership(this.domId); for (t = 0; t < e.length; t += 1)e[t].publishOwnership(this.domId); return o.set.call(this, e) } }), Object.defineProperty(ShadowRoot.prototype, 'styleSheets', { get: function () { let e, t; for (t = s.get.call(this), this.domId || G(this), e = 0; e < t.length; e += 1)t[e].publishOwnership(this.domId); return t } })), G(document)), r && (r.observe(window.document, p), !i && M.getValue(n, 'options.captureShadowDOM', !1) && (i = Element.prototype.attachShadow, Element.prototype.attachShadow = j), L = !0), E = !0 } function ee (e, t, n) { let r; let i; let a; let o; let s; const u = []; if (!e || !t) return u; if (n && n.length === 2 && (i = n[0], a = n[1]), (o = e.querySelectorAll(t)) && o.length) for (r = o.length - 1; r >= 0; r -= 1)s = o[r], i ? s[i] === a && u.push(s) : u.push(s); return u } function te (e, t, n) { let r, i, a; for (r = (a = ee(e, t, n)).length - 1; r >= 0; r -= 1)(i = a[r]).parentNode.removeChild(i); return e } function ne (e, t) { let n, r; for (n = 0; e.hasChildNodes() && n < e.childNodes.length; n += 1)(r = e.childNodes[n]).nodeType === t ? (e.removeChild(r), n -= 1) : r.hasChildNodes() && ne(r, t); return e } function re (e, t) { let n = null; if (e) switch (e.nodeType || -1) { case 11:n = e.innerHTML; break; case 9:n = e.documentElement ? e.documentElement.outerHTML : ''; break; case 1:n = t ? e.innerHTML : e.outerHTML; break; default:n = null } return n } function ie (e) { let t, n, r; for (e.TLTListeners = e.TLTListeners || {}, t = 0, n = v.length; t < n; t += 1)r = v[t], e.TLTListeners[r] || (c.subscribe(r, e, k), e.TLTListeners[r] = !0) } function ae (e, t, n, i) { let a; let o; let s; let u; let c; let d; const f = { shadows: [] }; if (!e || !i && !e.children) return f; for (a = 0, o = (c = i ? [e] : e.children).length; a < o; a += 1) { if ((u = c[a]).shadowRoot && (d = new l.Xpath(u), s = C(u.ownerDocument, u.shadowRoot, '', n), f.shadows.push({ root: s.root, originalSize: s.originalSize, xpath: d.xpath }), f.shadows = f.shadows.concat(s.shadows), ie(u.shadowRoot), h)) try { r.observe(u.shadowRoot, p), u.shadowRoot.TLTListeners.mutation = !0, M.indexOf(m, u) === -1 && m.push(u) } catch (e) { M.clog('Failed to observe shadow root.', e, u) }s = ae(u, null, n), f.shadows = f.shadows.concat(s.shadows) } return f } function oe (e) { let t; let n; let r; let i; let a = []; if (!e || !e.children) return a; for (t = 0, n = (i = e.children).length; t < n; t += 1)(r = i[t]).shadowRoot && (r.shadowRoot.TLTListeners || a.push([r, r.shadowRoot]), a = a.concat(oe(r.shadowRoot))), a = a.concat(oe(r)); return a } function se (e, t) { let n, r, i, a, o; if (e && t && t.captureShadowDOM) { for (n = 0, r = (o = oe(e)).length, i = []; n < r; n += 1)a = ae(o[n][0], 0, t, !0), i = i.concat(a.shadows); return i } } function ue (t, n) { let r, i; return (r = C(t, t, null, n)) || (r = {}), r.charset = t.characterSet || t.charset, i = M.getOriginAndPath(t.location), r.host = i.origin, r.url = e.normalizeUrl('', i.path, 12), r } function le (e) { let t; let n; let r; let i; let a; let o; let s; let u; let c; let d; let f; let h; const p = { fullDOM: !1, diffs: [], attributeDiffs: {} }; const g = new RegExp('^data:image/(.*?);base64'); for ((function (e) { let t, n, r; if (e && e.length) for (e = e.sort(function (e, t) { return e.compare(t) }), t = 0; t < e.length; t += 1) for (r = e[t], n = t + 1; n < e.length; n += 0)e[n].containedIn(r) ? e.splice(n, 1) : n += 1 }(y)), (function () { let e, t, n, r; for (e = 0, n = y.length; e < n && b.length; e += 1) for (r = y[e], t = 0; t < b.length; t += 1)b[t].containedIn(r) && (b.splice(t, 1), t -= 1) }()), u = e.captureShadowDOM, e.captureShadowDOM = !1, t = 0, n = y.length; t < n; t += 1) if (f = y[t], (d = l.getNodeFromID(f.xpath, -2)) && (!f.isShadowHost || (d = d.shadowRoot).TLTListeners)) { if (d === window.document.body || d === window.document.documentElement) return e.captureShadowDOM = u, ue(window.document, e); delete (r = C(window.document, d, f, e)).originalSize, r.shadows && r.shadows.length === 0 && delete r.shadows, r.frames && r.frames.length === 0 && delete r.frames, r.xpath = f.xpath, p.diffs.push(r) } for (t = 0; t < w.length; t += 1)i = w[t], s = ce(a = R[i]), (o = new l.Xpath(a)) && o.xpath !== 'null' ? (o = o.xpath.slice(0, -1), o += ',["' + i + '"]]') : o = '[["' + i + '"]]', r = { root: s, xpath: o }, P[i] = !1, p.diffs.push(r); function m (e, t) { e && e.name && (p.attributeDiffs[r.xpath][e.name] = { value: e.value }) } function v (t) { let n, r, i; for (n = 0, i = t.length; n < i; n += 1) if ((r = t[n]).name === 'src' && g.test(r.value) && r.value.length > e.discardBase64) { r.value = '', t.push({ name: 'removedByUIC', value: !0 }); break } return t } for (t = 0, n = b.length; t < n; t += 1)z((f = b[t]).attributes, 'id') > -1 && (d = l.getNodeFromID(f.fullXpath, -2)) && (f.xpath = f.fullXpath), h = N(f.attributes), e.hasOwnProperty('discardBase64') && ((d = l.getNodeFromID(f.xpath, -2)) || (d = l.getNodeFromID(f.fullXpath, -2)), d && d.tagName.toLowerCase() === 'img' && h && (h = v(h))), r = { xpath: f.xpath, attributes: h }, p.diffs.push(r), p.attributeDiffs[r.xpath] = {}, M.forEach(r.attributes, m); return e.captureShadowDOM = u, (c = se(window.document, e)) && c.length && (p.shadows = c), p } function ce (e) { let t; let r; let i; let a; let o; let s; let u; const l = n.options.captureHREFStyles; if (!P[e.domId]) return A[e.domId]; if ((a = (a = [].concat.apply([], e.adoptedStyleSheets)).concat.apply(a, e.styleSheets)) && a.length > 0) { for (t = [], s = 0; s < a.length; s += 1) if (o = a[s], !(!l && !e.isDocumentFromIframe && o.href || o.ownerNode && o.ownerNode.textContent)) { try { i = o.cssRules } catch (e) { continue } for (u = 0; u < i.length; u += 1)t.push(i[u].cssText) }t.length > 0 && (r = '<style id="' + e.domId + '">' + t.join(' ') + '</style>', A[e.domId] = r) } return P[e.domId] = !1, r } return a = function (e) { let t = null; return (function (e) { let t = !1; if (e && typeof e === 'object') switch (e.nodeType || -1) { case 9:case 1:t = !0; break; default:t = !1 } return t }(e)) && !(t = e.cloneNode(!0)) && e.documentElement && (t = e.documentElement.cloneNode(!0)), t }, C = function (r, i, o, s) { let u; let l; let c; let d; let f; let h; let p; let g = !0; let m = {}; const v = n.options.captureDynamicStyles; if (!r || !i) return m; if ((l = re(i)) && (m.originalSize = l.length), !(u = a(i)) && i.host)g = !1, (h = document.createElement('div')).id = 'srph-' + Date.now(), h.innerHTML = re(i), u = h; else if (!u) return m; return u && (s.removeScripts && (te(u, 'script'), te(u, 'noscript')), s.keepImports || te(u, 'link', ['rel', 'import']), s.removeComments && ne(u, 8), s.captureStyle ? s.useACS && (function (e, t) { let n, r, i, a, o, s, u, l, c; if (e && t && t.querySelectorAll) for (u = e.querySelectorAll('style'), l = t.querySelectorAll('style'), n = 0, c = u.length; n < c; n += 1) if ((s = u[n]).sheet) { for (r = 0, a = (i = s.sheet.cssRules).length, o = []; r < a; r += 1)o.push(i[r].cssText); o.length && (l[n].innerHTML = o.join('\n')) } }(i, u)) : te(u, 'style'), s.hasOwnProperty('discardBase64') && (function (e, t) { let n; let r; const i = ee(e, 'img'); const a = new RegExp('^data:image/(.*?);base64'); for (n = 0; n < i.length; n++)r = i[n], a.test(r.src) && r.src.length > t && (r.src = '', r.setAttribute('removedByUIC', !0)) }(u, s.discardBase64)), (function (e, t) { let n, r, i, a, o, s, u; if (e && t && (r = e.querySelectorAll('select'), a = t.querySelectorAll('select'), r)) for (o = 0, u = r.length; o < u; o += 1) for (n = r[o], i = a[o], s = 0; s < n.options.length; s += 1)s === n.selectedIndex || n.options[s].selected ? i.options[s].setAttribute('selected', 'selected') : i.options[s].removeAttribute('selected') }(i, u)), (function (e, t) { let n, r, i, a, o, s; if (t && (a = e.querySelectorAll('input'), o = t.querySelectorAll('input'))) for (n = 0, s = o.length; n < s; n += 1) switch (r = a[n], (i = o[n]).type) { case 'checkbox':case 'radio':r.checked ? i.setAttribute('checked', 'checked') : i.removeAttribute('checked'); break; default:i.setAttribute('value', r.value), i.getAttribute('type') || i.setAttribute('type', 'text') } }(i, u)), (function (e, t) { let n, r, i, a, o, s; if (e && t && (a = e.querySelectorAll('textarea'), s = t.querySelectorAll('textarea'), a && s)) for (n = 0, r = a.length; n < r; n += 1)i = a[n], (o = s[n]).setAttribute('value', i.value), o.value = o.textContent = i.value }(i, u)), u = t.applyPrivacyToNode(u, o, r), s.captureFrames && (c = (function (t, n, r) { let i; let a; let o; let s; let u; let l; let c; let d; let f; let h; let p; let g; let m; const v = ['iframe', 'frame']; const y = { frames: [] }; for (a = 0; a < v.length; a += 1) if (s = v[a], p = t.querySelectorAll(s), g = n.querySelectorAll(s), p) for (i = 0, o = p.length; i < o; i += 1) try { u = p[i], (l = M.getIFrameWindow(u)) && l.document && (r.captureAboutBlankFrames || l.location.href !== 'about:blank') && ((c = l.document).isDocumentFromIframe || (Z(l), c.isDocumentFromIframe = !0), d = C(c, c, '', r), f = 'tlt-' + M.getSerialNumber(), g[i].setAttribute('tltid', f), d.tltid = f, g[i].removeAttribute('srcdoc'), m = M.getOriginAndPath(c.location), d.host = m.origin, d.url = e.normalizeUrl('', m.path, 12), d.charset = c.characterSet || c.charset, (h = g[i].getAttribute('src')) || (h = l.location.href, g[i].setAttribute('src', h)), d.root || (d.root = '<html></html>'), y.frames = y.frames.concat(d.frames), delete d.frames, y.frames.push(d)) } catch (e) {} return y }(i, u, s)))), s.captureShadowDOM && (d = ae(i, 0, s)), c && (m = M.mixin(m, c)), d && (m = M.mixin(m, d)), f = ((function (e) { let t; let n; let r = null; if (!e) return r; switch (e.nodeType) { case 1:(t = e.ownerDocument) && t.documentElement === e && (n = t.doctype); break; case 9:n = e.doctype } return n && (r = '<!DOCTYPE ' + n.name + (n.publicId ? ' PUBLIC "' + n.publicId + '"' : '') + (!n.publicId && n.systemId ? ' SYSTEM' : '') + (n.systemId ? ' "' + n.systemId + '"' : '') + '>'), r }(i)) || '') + re(u || i, !g), m.root = t.applyPrivacyPatterns(f), v && document.adoptedStyleSheets && (i instanceof Document || i instanceof ShadowRoot || i.isDocumentFromIframe || i.nodeName === 'BODY' && i.ownerDocument.isDocumentFromIframe) && (i.nodeName === 'BODY' && (i = i.ownerDocument), i.domId || G(i), (p = ce(i)) && (i instanceof ShadowRoot ? m.root += p : m.root = m.root.replace('</body>', p + '</body>'))), m }, O = function () { $((u = e.getService('config')).getServiceConfig('domCapture') || {}) }, { init: function () { u = e.getService('config'), E || $(u.getServiceConfig('domCapture') || {}) }, destroy: function () { u.unsubscribe('configupdated', O), r && (r.disconnect(), r = null), i && Element.prototype.attachShadow === j && (Element.prototype.attachShadow = i, i = null), E = !1, I && Object.defineProperty(Document.prototype, 'adoptedStyleSheets', I), D && Object.defineProperty(Document.prototype, 'styleSheets', D), o && Object.defineProperty(ShadowRoot.prototype, 'adoptedStyleSheets', o), s && Object.defineProperty(ShadowRoot.prototype, 'styleSheets', s), CSSStyleSheet.prototype.insertRuleOriginal && (CSSStyleSheet.prototype.insertRule = CSSStyleSheet.prototype.insertRuleOriginal), CSSStyleSheet.prototype.deleteRuleOriginal && (CSSStyleSheet.prototype.deleteRule = CSSStyleSheet.prototype.deleteRuleOriginal), CSSStyleSheet.prototype.replaceSyncOriginal && (CSSStyleSheet.prototype.replaceSync = CSSStyleSheet.prototype.replaceSyncOriginal), CSSStyleSheet.prototype.replaceOriginal && (CSSStyleSheet.prototype.replace = CSSStyleSheet.prototype.replaceOriginal), CSSStyleSheet.prototype.publishOwnership && delete CSSStyleSheet.prototype.publishOwnership, CSSStyleSheet.prototype.removeOwnership && delete CSSStyleSheet.prototype.removeOwnership, CSSStyleSheet.prototype.updateOwner && delete CSSStyleSheet.prototype.updateOwner }, observeWindow: function (e) { e && (M.getValue(n, 'options.captureFrames', !1) || e === window) && M.indexOf(g, e) === -1 && (g.push(e), r && L && r.observe(e.document, p)) }, captureDOM: function (e, t) { let i; let a; let o; let s = null; let u = 0; if (!E || M.isIE && document.documentMode < 10) return s; if (t = M.mixin({}, n.options, t), e = e || window.document, !x || !h || _ || t.forceFullDOM) { if (r && r.disconnect(), (s = ue(e, t)).fullDOM = !0, s.forced = !(!_ && !t.forceFullDOM), x = !0, r) for (i = 0, a = g.length; i < a; i += 1) { o = g[i]; try { r.observe(o.document, p) } catch (e) { g.splice(i, 1), a = g.length, i -= 1 } } } else (s = le(t)).fullDOM = !s.diffs; return h && (s.mutationCount = T), y = [], b = [], w = [], T = 0, _ = !1, t.maxLength && (u = (function (e) { let t; let n; let r; let i; let a; let o; let s; let u; let l = 0; if (!e) return l; if (e.root) { if (l += e.root.length, e.frames) for (t = 0, r = (s = e.frames).length; t < r; t += 1)s[t].root && (l += s[t].root.length) } else if (e.diffs) for (t = 0, r = e.diffs.length; t < r; t += 1) if (l += (o = e.diffs[t]).xpath.length, o.root)l += o.root.length; else if (o.attributes) for (n = 0, i = o.attributes.length; n < i; n += 1)l += (a = o.attributes[n]).name.length, a.value && (l += a.value.length); if (e.shadows) for (t = 0, r = (u = e.shadows).length; t < r; t += 1)u[t].root && (l += u[t].root.length); return l }(s)), u > t.maxLength && (s = { errorCode: 101, error: 'Captured length (' + u + ') exceeded limit (' + t.maxLength + ').' })), s } } }), TLT.addService('encoder', function (e) { 'use strict'; let t = {}; let n = null; let r = null; let i = !1; function a (e) { t = e, n.subscribe('configupdated', r), i = !0 } return r = function () { a((n = e.getService('config')).getServiceConfig('encoder') || {}) }, { init: function () { n = e.getService('config'), i || a(n.getServiceConfig('encoder') || {}) }, destroy: function () { n.unsubscribe('configupdated', r), i = !1 }, encode: function (n, r) { let i; let a; const o = { data: null, encoding: null, error: null }; if (typeof n !== 'string' && !n || !r) return o.error = 'Invalid ' + (n ? 'type' : 'data') + ' parameter.', o; if (i = (function (n) { let r = null; return n ? ((r = t[n]) && typeof r.encode === 'string' && (r.encode = e.utils.access(r.encode)), r) : r }(r)), !i) return o.error = 'Specified encoder (' + r + ') not found.', o; if (typeof i.encode !== 'function') return o.error = 'Configured encoder (' + r + ") 'encode' method is not a function.", o; try { a = i.encode(n) } catch (e) { return o.error = 'Exception ' + (e.name ? e.name + ' - ' : '') + (e.message || e), o } return a && e.utils.getValue(a, 'buffer', null) !== null ? (o.data = a.buffer, o.encoding = i.defaultEncoding, o) : (o.error = 'Encoder (' + r + ') returned an invalid result.', o) } } }), TLT.addService('message', function (e) { 'use strict'; let t; let n; let r; const i = e.utils; const a = e.getTabId(); const o = []; let s = 0; let u = 0; const l = e.getStartTime(); const c = window.performance && performance.timeOrigin && performance.timeOrigin < l ? Math.round(performance.timeOrigin) : l; const d = Date.now() - c + 10; const f = (new Date()).getTimezoneOffset(); const h = e.getService('browserBase'); const p = e.getService('browser'); let g = e.getService('config'); let m = g.getCoreConfig(); let v = g.getServiceConfig('message') || {}; const y = e.normalizeUrl('', window.location.href); const w = window.location.hostname; let b = v.hasOwnProperty('privacy') ? v.privacy : []; const T = {}; const S = 'x'; const _ = 'X'; const x = '9'; const E = '@'; const C = parseFloat((window.devicePixelRatio || 1).toFixed(2)); const O = window.screen || {}; const k = O.width || 0; const L = O.height || 0; const M = h.getNormalizedOrientation(); const D = i.isiOS && Math.abs(M) === 90 ? L : k; const I = i.isiOS && Math.abs(M) === 90 ? k : L; const P = window.screen ? window.screen.height - window.screen.availHeight : 0; const R = window.innerWidth || document.documentElement.clientWidth; const A = window.innerHeight || document.documentElement.clientHeight; let N = !1; const z = {}; let V = !1; function F () { const e = Date.now() - c; let t = window.performance && performance.now ? Math.round(performance.now()) : e; return e - t > d && (t = e), t } function H (e) { let t = ''; if (delete e.timestamp, this.type = e.type, this.offset = F(), e.type === 2 && e.screenview.type === 'LOAD' ? (o.push(F()), this.screenviewOffset = 0) : o.length ? (this.screenviewOffset = F() - o[o.length - 1], e.type === 2 && e.screenview.type === 'UNLOAD' && o.pop()) : this.screenviewOffset = 0, this.type) for (t in this.count = u += 1, this.fromWeb = !0, e)e.hasOwnProperty(t) && (this[t] = e[t]) } function U (e, t, n) { let r = T.PVC_MASK_BASIC; return typeof t !== 'string' ? t : (e ? e.maskType === T.PVC_MASK_EMPTY.maskType ? r = T.PVC_MASK_EMPTY : e.maskType === T.PVC_MASK_BASIC.maskType ? r = T.PVC_MASK_BASIC : e.maskType === T.PVC_MASK_TYPE.maskType ? r = T.PVC_MASK_TYPE : e.maskType === T.PVC_MASK_CUSTOM.maskType && typeof (r = typeof e.maskFunction === 'string' ? i.access(e.maskFunction) : e.maskFunction) !== 'function' && (r = T.PVC_MASK_BASIC) : r = T.PVC_MASK_BASIC, r(t, n)) } function X (e, t) { let n; if (e && t) for (n in t)t.hasOwnProperty(n) && (n === 'value' ? t[n] = U(e, t[n]) : delete t[n]) } function j (e, t) { return i.matchTarget(e, t) !== -1 } function q (e) { let t, n, i; if (!e) return ''; for (t = 0, n = r.length; t < n; t += 1)(i = r[t]).cRegex.lastIndex = 0, e = e.replace(i.cRegex, i.replacement); return e } function B (e, t) { let n; let r = null; if (!(e && e.maskAttributes && t && t.attributes)) return r; if (typeof e.maskAttributes === 'function') try { r = e.maskAttributes(t.id, t.attributes) } catch (e) {} else for (n in r = t.attributes, t.attributes)t.attributes.hasOwnProperty(n) && (r[n] = U(e, t.attributes[n])); return r } function Y (e) { let t; let n; let r; let a; let o; let s; let u = !1; if (!e || !e.currState && !e.prevState && !e.attributes || !e.id) return e; for (o = e.prevState, s = e.currState, t = 0, n = b.length; t < n; t += 1) if (a = b[t], r = i.getValue(a, 'exclude', !1), j(a.targets, e) !== r) { o && o.hasOwnProperty('value') && X(a, o), s && s.hasOwnProperty('value') && X(a, s), a.maskAttributes && e.attributes && (e.attributes = B(a, e)), u = !0; break } return u || (o && o.value && (o.value = q(o.value)), s && s.value && (s.value = q(s.value))), e } function W (e) { return e && e.target ? (Y(e.target), e) : e } function K (e, t) { let n, r, a, o; if (t && e) if (e.value ? (a = U(t, e.value, e), e.setAttribute('value', a), e.value = a) : t.maskType === T.PVC_MASK_CUSTOM.maskType && U(t, '', e), e.checked && e.removeAttribute('checked'), i.getTagName(e) === 'select') for (e.selectedIndex = -1, n = 0, r = e.options.length; n < r; n += 1)(o = e.options[n]).removeAttribute('selected'), o.selected = !1; else i.getTagName(e) === 'textarea' && (e.textContent = e.value) } function Q () { let t, n, a, o, s, u, l; for (g = e.getService('config'), v = g.getServiceConfig('message') || {}, m = g.getCoreConfig(), b = v.privacy || [], r = v.privacyPatterns || [], V = i.getValue(v, 'shadowDOMCacheEnabled', !0), t = 0, o = b.length; t < o; t += 1) for (n = 0, l = (u = (a = b[t]).targets).length; n < l; n += 1) typeof (s = u[n]) === 'object' && (typeof s.idType === 'string' && (s.idType = +s.idType), typeof s.id === 'object' && (s.cRegex = new RegExp(s.id.regex, s.id.flags))); for (t = r.length - 1; t >= 0; t -= 1) typeof (a = r[t]).pattern === 'object' ? a.cRegex = new RegExp(a.pattern.regex, a.pattern.flags) : r.splice(t, 1) } return T.PVC_MASK_EMPTY = function (e) { return '' }, T.PVC_MASK_BASIC = function (e) { return typeof e !== 'string' ? '' : e.length ? 'XXXXX' : '' }, T.PVC_MASK_TYPE = function (e) { let t; let n; let r; let a = ''; if (typeof e !== 'string') return a; for (n = 0, r = (t = e.split('')).length; n < r; n += 1)i.isNumeric(t[n]) ? a += x : i.isUpperCase(t[n]) ? a += _ : i.isLowerCase(t[n]) ? a += S : a += E; return a }, T.PVC_MASK_EMPTY.maskType = 1, T.PVC_MASK_BASIC.maskType = 2, T.PVC_MASK_TYPE.maskType = 3, T.PVC_MASK_CUSTOM = { maskType: 4 }, { init: function () { if (!N) { g.subscribe && g.subscribe('configupdated', Q), Q(), N = !0; try { t = sessionStorage.getItem('tl.TR'), n = sessionStorage.getItem('tl.PU'), sessionStorage.removeItem('tl.TR'), sessionStorage.removeItem('tl.PU') } catch (e) { t = null } } }, destroy: function () { g.unsubscribe('configupdated', Q), N = !1 }, applyPrivacyToNode: function (e, t, n) { let r; let a; let o; let s; let u; let l; let c; let d; let f; let g; let m; let v; let y; let w = []; const T = []; if (!e || !n) return null; for (r = 0, c = b.length; r < c; r += 1) for (d = b[r], (u = i.getValue(d, 'exclude', !1)) && (l = d), a = 0, y = (v = d.targets).length; a < y; a += 1) if (typeof (m = v[a]) === 'string') if (e.id && /srph-\d{13}/.test(e.id) || !p.matches(m, e) || (u ? w.push(e) : K(e, d)), f = p.queryAll(m, e), u)w = w.concat(f); else for (o = 0, g = f.length; o < g; o += 1)K(s = f[o], d); else if (typeof m.id === 'string') switch (m.idType) { case -1:case -3:s = h.getNodeFromID(m.id, m.idType, e), u ? w.push(s) : K(s, d); break; case -2:T.push({ ruleIndex: r, targetIndex: a, exclude: u }) } else T.push({ ruleIndex: r, targetIndex: a, exclude: u }); return (function (e, t, n, r, a, o) { let s; let u; let l; let c; let d; let f; let g; let m; let v; let y; let w; let T = []; if (!e.length && !a.length && !o) return []; if (!(w = p.queryAll('input, select, textarea', t)) || !w.length) return []; for (s = 0, c = a.length; s < c; s += 1)(u = w.indexOf(a[s])) !== -1 && w.splice(u, 1); if (e.length) for (s = 0, c = w.length, T = []; s < c; s += 1)w[s].value && ((f = h.ElementData.prototype.examineID(w[s], !0)).idType === -2 && ((g = new h.Xpath(w[s], !0)).applyPrefix(n), f.id = g.xpath), T.push({ id: f.id, idType: f.idType, element: w[s] })); for (s = 0, c = e.length; s < c; s += 1) if (v = b[e[s].ruleIndex], m = i.getValue(v, 'exclude', !1), typeof (y = v.targets[e[s].targetIndex]).id === 'string' && y.idType === -2) for (u = 0; u < T.length; u += 1)T[u].idType === y.idType && T[u].id === y.id && (m ? (l = w.indexOf(d), w.splice(l, 1)) : K(d = T[u].element, v)); else for (u = 0; u < T.length; u += 1)y.cRegex.lastIndex = 0, T[u].idType === y.idType && y.cRegex.test(T[u].id) && (d = T[u].element, m ? (l = w.indexOf(d), w.splice(l, 1)) : K(d, v)); if (o) for (s = 0, c = w.length; s < c; s += 1)K(w[s], o) }(T, e, t, 0, w, l)), e }, applyPrivacyToMessage: W, applyPrivacyToTarget: Y, applyPrivacyPatterns: q, isPrivacyMatched: function (e) { let t; let n; let r = !1; if (!e) return r; for (t = 0, n = b.length; t < n; t += 1) if (j(b[t].targets, e)) { r = !0; break } return r }, createMessage: function (e) { if (void 0 === e.type) throw new TypeError('Invalid queueEvent given!'); return e.type === 12 && V && (function (e) { let t; let n; let r; let i; let a; const o = e.dcid; const s = e.shadows || []; const u = e.fullDOM; if (s.length !== 0 && u) { for (r in z)z.hasOwnProperty(r) && (z[r].age += 1); for (t = 0, n = s.length; t < n; t += 1)i = s[t], (a = z[i.xpath]) && a.root === i.root ? (a.hitCount += 1, a.age -= 1, i.cacheDCID = a.dcid, delete i.root) : z[i.xpath] = { root: i.root, dcid: o, hitCount: 0, age: 0 }; for (r in z)z.hasOwnProperty(r) && (a = z[r]).age > a.hitCount + 1 && delete z[r] } }(e.domCapture)), W(new H(e)) }, wrapMessages: function (r) { const o = { messageVersion: '13.0.0.0', serialNumber: s += 1, sessions: [{ id: e.getPageId(), tabId: a, startTime: c, timezoneOffset: f, messages: r, clientEnvironment: { webEnvironment: { libVersion: '6.4.8', buildNote: m.buildNote || '', domain: w, page: y, referrer: document.referrer, mouseMovement: e.isMousemovementDetected(), screen: { devicePixelRatio: C, deviceWidth: D, deviceHeight: I, deviceToolbarHeight: P, width: R, height: A, orientation: M } } } }] }; const u = o.sessions[0].clientEnvironment.webEnvironment; return u.screen.orientationMode = i.getOrientationMode(u.screen.orientation), t && (u.priorPage = { page: n, terminationReason: t }), o }, getCurrentOffset: F } }), TLT.addService('serializer', function (e) { 'use strict'; let t = e.getService('config'); let n = {}; let r = {}; const i = { json: void 0 !== window.JSON ? { serialize: window.JSON.stringify, parse: window.JSON.parse } : {} }; let a = null; let o = !1; function s (t, n, r) { let i, a, o; for (i = 0, a = (t = t || []).length; i < a; i += 1) if (typeof (o = t[i]) === 'string' && (o = e.utils.access(o)), typeof o === 'function') { n[r] = o; break } } function u (u) { let l, c; for (l in u)u.hasOwnProperty(l) && (s(u[l].stringifiers, n, l), s(u[l].parsers, r, l)); n.json = n.json || i.json.serialize, r.json = r.json || i.json.parse, typeof n.json === 'function' && typeof r.json === 'function' || e.fail("JSON parser and/or serializer not provided in the UIC config. Can't continue."), typeof n.json !== 'function' || typeof r.json !== 'function' ? c = !0 : (c = void 0 === r.json('{"foo": "bar"}') || r.json('{"foo": "bar"}').foo !== 'bar', c = (c = (c = void 0 === r.json('[1, 2]') || (c = c || r.json('[1, 2]')[0] !== 1) || r.json('[1,2]')[1] !== 2) || n.json({ foo: 'bar' }) !== '{"foo":"bar"}') || n.json([1, 2]) !== '[1,2]'), c && e.fail('JSON stringification and parsing are not working as expected'), t && t.subscribe('configupdated', a), o = !0 } return a = function () { u((t = e.getService('config')).getServiceConfig('serializer')) }, { init: function () { o || u(t ? t.getServiceConfig('serializer') : {}) }, destroy: function () { n = {}, r = {}, t && t.unsubscribe('configupdated', a), o = !1 }, parse: function (e, t) { return r[t = t || 'json'](e) }, serialize: function (e, t) { return n[t = t || 'json'](e) } } }), TLT.addModule('TLCookie', function (e) { 'use strict'; let t; let n; let r; let i = {}; let a = []; let o = 0; let s = !0; let u = !1; let l = 'WCXSID'; let c = 'TLTSID'; let d = 'CoreID6'; let f = null; const h = e.utils; function p () { const e = '123456789'; return h.getRandomString(1, e) + h.getRandomString(31, e + '0') } function g () { if (!f && window.cmRetrieveUserID) try { window.cmRetrieveUserID(function (e) { f = e }) } catch (e) { f = null } } function m (e) { let t, n, r, i; if (localStorage && e) return (r = localStorage.getItem(e)) && (n = r.split('|'), t = parseInt(n[0], 10), Date.now() > t ? localStorage.removeItem(e) : i = n[1]), i } function v (e, t) { let n; if (localStorage && e) return t = t || p(), n = Date.now() + o, localStorage.setItem(e, n + '|' + t), m(e) } function y () { return a } function w (f) { if (a = [], s = h.getValue(f, 'sessionIDUsesCookie', !0), u = h.getValue(f, 'sessionIDUsesStorage', !1), f.tlAppKey && (r = f.tlAppKey, a.push({ name: 'X-Tealeaf-SaaS-AppKey', value: r })), f.visitorCookieName && (d = f.visitorCookieName), f.wcxCookieName && (l = f.wcxCookieName), (t = h.getCookieValue(l)) && a.push({ name: 'X-WCXSID', value: t }), f.sessionizationCookieName && (c = f.sessionizationCookieName), u) { o = h.getValue(f, 'sessionIDStorageTTL', 6e5); try { n = m(c) } catch (e) { u = !1 } } if (!n && s && (n = h.getCookieValue(c)), !n) if (t)c = l, n = t; else { if (u) try { n = v(c) } catch (e) { u = !1 }!n && s && (g = p(), w = !!i.secureTLTSID, b = i.samesite, h.setCookie(c, g, void 0, void 0, void 0, w, b), n = h.getCookieValue(c)) } let g, w, b; e.setSessionCookieInfo(c, n), n || (n = 'Check7UIC7Cookie7Configuration77'), a.push({ name: 'X-Tealeaf-SaaS-TLTSID', value: n }), a.length && TLT.registerBridgeCallbacks([{ enabled: !0, cbType: 'addRequestHeaders', cbFunction: y }]) } function b (e) { let t; let n; let r; let a = !1; const o = i.appCookieWhitelist; if (!o || !o.length) return a; for (t = 0, n = o.length; t < n && !a; t += 1)(r = o[t]).regex ? (r.cRegex || (r.cRegex = new RegExp(r.regex, r.flags)), r.cRegex.lastIndex = 0, a = r.cRegex.test(e)) : a = r === e; return a } return { init: function () { w(i = e.getConfig() || {}), g() }, destroy: function () { u && v(c, n), window.setTimeout(function () { TLT.registerBridgeCallbacks([{ enabled: !1, cbType: 'addRequestHeaders', cbFunction: y }]) }) }, onevent: function (t) { if (t.type === 'screenview_load')h.getValue(i, 'appCookieWhitelist.length', 0) && (g(), (function () { let t; let n; let r; let i; const a = {}; const o = document.cookie; let s = ''; let u = ''; if (!o) return; let l = (i = o.split('; ')).length; for (l > 100 && (l = 100), t = 0; t < l; t += 1) { if ((n = (r = i[t]).indexOf('=')) >= 0) try { s = decodeURIComponent(r.substr(0, n)) } catch (e) { s = r.substr(0, n) } if (u = r.substr(n + 1), b(s)) try { a[s] = decodeURIComponent(u) } catch (e) { a[s] = u } }f && !a[d] && (a[d] = f), e.post({ type: 14, cookies: a }) }())) } } }), TLT.addModule('dataLayer', function (e) { 'use strict'; let t; let n; let r; let i; let a; let o = !1; const s = e.utils; function u (e, t) { let n; let r; let i; let a = -1; if (!e || !t) return a; for (n = 0, r = t.length; n < r && a === -1; n += 1) switch (typeof (i = t[n])) { case 'string':e === i && (a = n); break; case 'object':i.cRegex || (i.cRegex = new RegExp(i.regex, i.flags)), i.cRegex.lastIndex = 0, i.cRegex.test(e) && (a = n) } return a } function l (e, t) { let n; let i; const a = {}; if (!e) return null; if (t) { if ((t += 1) > 5) return 'Serialization error: Exceeds nesting limit (5).' } else t = 1; for (n in e) if (Object.prototype.hasOwnProperty.call(e, n) && !(u(n, void 0 || r) >= 0)) switch (typeof (i = e[n])) { case 'object':if (i instanceof Node)i.nodeName ? (a[n] = i.nodeName.toLowerCase(), i.id && (a[n] += '#' + i.id)) : a[n] = 'DOMNode: unknown'; else if (i instanceof Window)a[n] = 'DOMWindow: ' + i.location.href; else try { JSON.stringify(i), a[n] = l(i, t) } catch (e) { a[n] = 'Serialization error: ' + e.message } break; case 'function':case 'undefined':break; default:a[n] = i } return a } function c (n) { const r = { type: 19, dataLayer: {} }; o && (n = n || (function () { let e = null; if (!t.dataObject) return e; switch (typeof t.dataObject) { case 'object':e = t.dataObject; break; case 'function':try { e = t.dataObject() } catch (e) {} } return e }())) && (r.dataLayer = l(n), e.post(r), a && (clearTimeout(a), a = null)) } return { init: function () { t = e.getConfig(), r = t.propertyBlocklist || [], i = t.screenviewBlocklist || [], n = s.getValue(t, 'logDelay', 500), typeof t.dataObject === 'string' && (t.dataObject = s.access(t.dataObject)), a = null, o = !0 }, destroy: function () { t = null, a && (clearTimeout(a), a = null), o = !1 }, onevent: function (e) { let t; if (typeof e === 'object' && e.type) switch (e.type) { case 'load':a = null; break; case 'screenview_load':u(e.name, t = t || i) >= 0 || a || (a = setTimeout(c, n)); break; case 'logDataLayer':e.data && typeof e.data !== 'object' || c(e.data); break; case 'unload':a && c() } }, onmessage: function (e) {} } }), TLT && typeof TLT.addModule === 'function' && TLT.addModule('overstat', function (e) { 'use strict'; const t = e.utils; const n = {}; const r = { updateInterval: 250, hoverThreshold: 1e3, hoverThresholdMax: 12e4, gridCellMaxX: 10, gridCellMaxY: 10, gridCellMinWidth: 20, gridCellMinHeight: 20 }; const i = 50; function a (t) { const n = (e.getConfig() || {})[t]; return typeof n === 'number' ? n : r[t] } function o (e) { return e && !e.nodeType && e.element && (e = e.element), e } function s (e) { return !(e = o(e)) || e === document.body || e === document.html || e === document } function u (e) { return (e = o(e)) ? e.parentNode : null } function l (e) { return (e = o(e)) ? e.offsetParent || e.parentElement || u(e) : null } function c (e) { const t = (function (e) { return (e = o(e)) && e.tagName ? e.tagName.toUpperCase() : '' }(e)); return (function (e) { return (e = o(e)) && e.nodeType || -1 }(e)) !== 1 || t === 'TR' || t === 'TBODY' || t === 'THEAD' } function d (r, s, u, l) { let c; this.xPath = r !== null ? (c = r) ? c.xPath ? c.xPath : (c = o(c), e.getXPathFromNode(c)) : '' : '', this.domNode = r, this.hoverDuration = 0, this.hoverUpdateTime = 0, this.gridX = Math.max(s, 0), this.gridY = Math.max(u, 0), this.parentKey = '', this.updateTimer = -1, this.disposed = !1, this.childKeys = {}, this.webEvent = l, this.getKey = function () { return this.xPath + ':' + this.gridX + ',' + this.gridY }, this.update = function () { const e = (new Date()).getTime(); const t = this.getKey(); this.hoverUpdateTime !== 0 && (this.hoverDuration += e - this.hoverUpdateTime), this.hoverUpdateTime = e, clearTimeout(this.updateTimer), this.updateTimer = setTimeout(function () { !(function (e, t) { const r = n[e]; if (r && r[t])r[t]() }(t, 'update')) }, a('updateInterval')) }, this.dispose = function (e) { if (clearTimeout(this.updateTimer), delete n[this.getKey()], this.disposed = !0, e) { const t = this.clone(); n[t.getKey()] = t, t.update() } }, this.process = function (r) { if (clearTimeout(this.updateTimer), this.disposed) return !1; let o; let s; let u; let l; let c; let d; let f; let h = !1; let p = this; let g = 0; if (this.hoverDuration >= a('hoverThreshold')) { for (this.hoverDuration = Math.min(this.hoverDuration, a('hoverThresholdMax')), h = !0, o = this, s = { hoverToClick: !!r }, u = t.getValue(o, 'webEvent.target', {}), l = t.getValue(u, 'element.tagName') || '', c = l.toLowerCase() === 'input' ? t.getValue(u, 'element.type') : '', d = t.getTlType(u), (f = { type: 9, event: { hoverDuration: o.hoverDuration, hoverToClick: t.getValue(s, 'hoverToClick') }, target: { id: u.id || '', idType: u.idType || '', name: u.name || '', tlType: d, type: l, subType: c, position: { width: t.getValue(u, 'element.offsetWidth', 0), height: t.getValue(u, 'element.offsetHeight', 0), relXY: o.relXY } } }).target.id && (u.accessibility && (f.target.accessibility = u.accessibility), u.attributes && (f.target.attributes = u.attributes), e.post(f)); void 0 !== p && g++ < i;)p.dispose(r), p = n[p.parentKey]; g >= i && t.clog('Overstat process() hit iterations limit') } else this.dispose(r); return h }, this.clone = function () { const e = new d(this.domNode, this.gridX, this.gridY); return e.parentKey = this.parentKey, e } } function f (e, n, r) { const a = (function (e) { if (e && e.position) return { x: e.position.x, y: e.position.y }; for (var n = (e = o(e)) && e.getBoundingClientRect ? e.getBoundingClientRect() : null, r = n ? n.left : e ? e.offsetLeft : 0, a = n ? n.top : e ? e.offsetHeight : 0, u = r, c = a, d = 0, f = 0, h = l(e), p = 0; h && p++ < i && !s(h);)d = h.offsetLeft - (h.scrollLeft || 0), f = h.offsetTop - (h.scrollTop || 0), d === u && f === c || (r += d, a += f, u = d, c = f), h = l(h); return p >= i && t.clog('Overstat calculateNodeOffset() hit iterations limit'), isNaN(r) && (r = 0), isNaN(a) && (a = 0), { x: r, y: a } }(e = o(e))); let u = n - a.x; let c = r - a.y; return isFinite(u) || (u = 0), isFinite(c) || (c = 0), { x: u, y: c } } function h (e, t, n) { let r; let i; const s = (e = o(e)).getBoundingClientRect ? e.getBoundingClientRect() : null; const u = s ? s.width : e.offsetWidth; const l = s ? s.height : e.offsetHeight; const c = u && u > 0 ? Math.max(u / a('gridCellMaxX'), a('gridCellMinWidth')) : a('gridCellMinWidth'); const d = l && l > 0 ? Math.max(l / a('gridCellMaxY'), a('gridCellMinHeight')) : a('gridCellMinHeight'); let f = Math.min(Math.floor(t / c), a('gridCellMaxX')); let h = Math.min(Math.floor(n / d), a('gridCellMaxY')); const p = u > 0 ? t / u : 0; const g = l > 0 ? n / l : 0; return isFinite(f) || (f = 0), isFinite(h) || (h = 0), r = p, i = g, { x: f, y: h, relXY: (r = Math.floor(1e4 * Math.min(Math.max(r, 0), 1)) / 1e4) + ',' + Math.floor(1e4 * Math.min(Math.max(i, 0), 1)) / 1e4 } } function p (e) { let r = e; const a = {}; let o = null; let s = !1; let u = 0; for (a[e.getKey()] = !0; void 0 !== r && u++ < i && (a[r.parentKey] = !0, r.parentKey !== '' && r.parentKey !== r.getKey());)u >= i && t.clog('Overstat cleanupHoverEvents() hit iterations limit'), r = n[r.parentKey]; for (o in n)n.hasOwnProperty(o) && !a[o] && (r = n[o]) && (s ? r.dispose() : s = r.process()) } function g (e, r, i) { return r || (r = e.target), s(r) || t.isiOS || t.isAndroid ? null : (c(r) ? u = g(e, l(r), i) : ((u = new d(r, (o = h(r, (a = f(r, e.position.x, e.position.y)).x, a.y)).x, o.y, e)).relXY = o.relXY, m = u.getKey(), n[m] ? u = n[m] : n[m] = u, u.update(), i || ((w = l(r)) && (y = g(e, w, !0)) !== null && (v = y.getKey(), (m = u.getKey()) !== v && (u.parentKey = v)), p(u))), u); let a, o, u, m, v, y, w } function m (e) { (function (e, n) { let r = 0; if (!n || n === e) return !1; for (n = u(n); !s(n) && r++ < i;) { if (n === e) return !0; n = u(n) } return r >= i && t.clog('Overstat isChildOf() hit iterations limit'), !1 })((e = (function (e) { return e.nativeEvent && (e = e.nativeEvent), e }(e))).target, e.relatedTarget) || (function (e, t) { let r = null; let i = null; let a = !1; for (i in n)n.hasOwnProperty(i) && (r = n[i]) && r.domNode === e && r.getKey() !== t && (a ? r.dispose() : a = r.process()) }(e.target)) } function v (r) { if (t.getValue(r, 'target.id')) switch (r.type) { case 'mousemove':g(r); break; case 'mouseout':m(r); break; case 'click':!(function (e) { let t = null; let r = null; let i = !1; for (r in n)n.hasOwnProperty(r) && (t = n[r]) && (i ? t.dispose() : i = t.process(!0)) }()); break; case 'submit':e.performFormCompletion(!0) } } return { init: function () {}, destroy: function () { let e; for (e in n)n.hasOwnProperty(e) && (n[e].dispose(), delete n[e]) }, onevent: function (e) { typeof e === 'object' && e.type && v(e) }, onmessage: function (e) {}, createHoverEvent: function (e, t, n, r) { return new d(e, t, n, r) }, cleanupHoverEvents: p, eventMap: n } }), TLT && typeof TLT.addModule === 'function' && TLT.addModule('performance', function (e) { 'use strict'; let t; let n; let r; const i = { loadReceived: !1, unloadReceived: !1, perfEventSent: !1 }; let a = null; let o = null; let s = {}; let u = 0; const l = e.utils; const c = window.location.protocol === 'https:'; let d = []; let f = 0; const h = { enabled: !1, resourceTypes: [], blacklist: [] }; function p (n, r) { let o; let s; let c; let d; let f; let h; let p; let g; let m; const v = { type: 7, performance: {} }; if (n && !i.perfEventSent) { if (m = (h = n.performance || {}).timing, f = h.navigation, m) { if (!m.loadEventStart && !r) return; v.performance.timing = (function (e) { let t; const n = {}; let r = ''; let i = 0; if (!e || typeof e !== 'object' || !e.navigationStart) return {}; for (r in t = e.navigationStart, e)(Object.prototype.hasOwnProperty.call(e, r) || typeof e[r] === 'number') && (i = e[r], n[r] = typeof i === 'number' && i && r !== 'navigationStart' ? i - t : i); return n }(m)), v.performance.timing.renderTime = (function (e) { let t; let n; let r = 0; return e && (t = e.responseEnd > 0 && e.responseEnd < e.domLoading ? e.responseEnd : e.domLoading, n = e.loadEventStart, l.isNumeric(t) && l.isNumeric(n) && n > t && (r = n - t)), r }(m)) } else { if (!t.calculateRenderTime) return; v.performance.timing = { renderTime: u, calculated: !0 } } if (d = v.performance.timing, t.renderTimeThreshold && d.renderTime > t.renderTimeThreshold && (d.invalidRenderTime = d.renderTime, delete d.renderTime), h.getEntriesByType) for (o = 0, s = (p = h.getEntriesByType('paint')).length; o < s; o += 1)(g = p[o]).startTime > 0 && (d[g.name] = Math.round(g.startTime)); if (!d['first-paint'] && d.msFirstPaint && (d['first-paint'] = d.msFirstPaint, delete d.msFirstPaint), f) { switch (f.type) { case 0:c = 'NAVIGATE'; break; case 1:c = 'RELOAD'; break; case 2:c = 'BACKFORWARD'; break; default:c = 'UNKNOWN' }v.performance.navigation = { type: c, redirectCount: f.redirectCount } }e.post(v), i.perfEventSent = !0, a && (clearInterval(a), a = null) } } function g (t) { let n; let i; let a; let o; let s; let u; const l = r.blacklist; if (t && t.name && (i = t.name, a = t.initiatorType, c && i.indexOf('http:') === 0 && d.push(i), !(r.hasOwnProperty('maxAlerts') && f >= r.maxAlerts || r.hasOwnProperty('threshold') && t.duration < r.threshold || t.transferSize && t.transferSize < t.encodedBodySize || t.responseStart === t.responseEnd || r.resourceTypes.length > 0 && r.resourceTypes.indexOf(a) === -1))) { for (s = !1, n = 0; n < l.length; n += 1) switch (typeof (o = l[n])) { case 'object':o.cRegex || (o.cRegex = new RegExp(o.regex, o.flags)), o.cRegex.lastIndex = 0, o.cRegex.test(i) && (s = !0); break; case 'string':i.indexOf(o) !== -1 && (s = !0) }s || (f += 1, u = { urlNormalized: e.normalizeUrl(i, 17), url: i, initiator: a, duration: Math.round(t.duration), responseEnd: Math.round(t.responseEnd) }, void 0 !== t.transferSize && (u.transferSize = t.transferSize, t.duration && (u.bps = Math.round(t.transferSize / t.duration * 1e3))), e.post({ type: 17, resourceData: u })) } } function m () { s = {}, o && (clearTimeout(o), o = null) } function v () { const t = { type: 20, pageExperience: l.clone(s) }; (s.fid || s.lcp || s.cls) && (t.pageExperience.https = window.location.protocol === 'https:', e.post(t), m()) } function y (e) { if (e && e.name) { switch (e.name) { case 'FID':s.fid = Math.round(e.value); break; case 'LCP':s.lcp = Math.round(e.value); break; case 'CLS':s.cls = Number(e.value.toFixed(2)) } void 0 !== s.fid && void 0 !== s.lcp && void 0 !== s.cls && v() } } return { init: function () { let n; t = e.getConfig(), r = l.mixin({}, h, t.performanceAlert), t && l.getValue(t, 'pageExperience.enabled', !0) && (t.pageExperience = t.pageExperience || {}, !(n = t.pageExperience).api && window.webVitals && (n.api = { getCLS: webVitals.getCLS, getLCP: webVitals.getLCP, getFID: webVitals.getFID }), n.api ? n.enabled = !0 : n.enabled = !1) }, destroy: function () { let r, i, o; v(), a && (clearInterval(a), a = null, p(window, !0)), n && n.disconnect(), c && (o = (i = { type: 20, violations: {} }).violations, (r = d) && r.length && (o.total = r.length, r.splice(10), o.urls = r, e.post(i)), d = []), t = null }, onevent: function (s) { let c, d; if (typeof s === 'object' && s.type) switch (s.type) { case 'load':i.loadReceived = !0, (function (t) { const n = e.getStartTime(); t.timestamp > n && !u && (u = t.timestamp - n) }(s)), i.perfEventSent || a || (a = setInterval(function () { e.isInitialized() && p(window) }, l.getValue(t, 'delay', 2e3))), r.enabled && typeof window.PerformanceObserver === 'function' && (n = new window.PerformanceObserver(function (e, t) { l.forEach(e.getEntries(), g) }), d = window.performance.getEntriesByType('resource'), setTimeout(function () { l.forEach(d, g) }), n.observe({ entryTypes: ['resource'] })); break; case 'screenview_load':t && t.pageExperience && t.pageExperience.enabled && (m(), (c = t.pageExperience.api).getCLS(y), c.getLCP(y), c.getFID(y), o = setTimeout(v, 3e5)), i.perfEventSent || p(window); break; case 'screenview_unload':default:break; case 'unload':i.unloadReceived = !0, v(), i.perfEventSent || p(window) } }, onmessage: function (e) {} } }), TLT.addModule('replay', function (e) { 'use strict'; let t; const n = e.utils; let r = 0; const i = {}; let a = null; let o = []; let s = !0; let u = null; let l = null; let c = null; const d = (new Date()).getTime(); let f = null; const h = 'root'; let p = null; let g = null; let m = null; let v = null; let y = { inFocus: !1 }; let w = null; let b = e.getConfig() || {}; const T = n.getValue(b, 'viewPortWidthHeightLimit', 1e4); let S = 1; let _ = 1; const x = {}; const E = n.getValue(b, 'mousemove') || {}; const C = E.sampleRate; const O = E.ignoreRadius; let k = null; const L = []; const M = []; let D = {}; let I = 0; const P = 1e3; let R = 0; let A = []; const N = []; let z = document.visibilityState === 'visible'; function V (e) { let t = !1; let n = null; if (typeof e !== 'object' || !e.type) return t; switch (e.type.toLowerCase()) { case 'input':n = '|' + (e.subType || '') + '|', t = '|button|image|submit|reset|'.indexOf(n.toLowerCase()) !== -1; break; case 'select':case 'textarea':t = !1; break; default:t = !0 } return t } function F (e) { let t = e.type; const n = e.target; if ((t = typeof t === 'string' ? t.toLowerCase() : 'unknown') === 'blur' && (t = 'focusout'), t === 'change') if (n.type === 'INPUT') switch (n.subType) { case 'text':case 'date':case 'time':t = n.subType + 'Change'; break; default:t = 'valueChange' } else t = n.type === 'TEXTAREA' ? 'textChange' : 'valueChange'; return t } function H (e, t, n) { let r; if (document.querySelector(e)) return !0; for (r = 0; r < t.length; r++) if (t[r].querySelector(e)) return !0; for (r = 0; r < n.length; r++) if (n[r].querySelector(e)) return !0; return !1 } function U (t, r, i) { let a, o, s, u, l, c, d, f, h; for (a = 0; a < N.length; a++)o = (d = N[a]).delayUntil.selector, s = n.getValue(d.delayUntil, 'exists', !0), u = d.delayUntil.dualSnapshot || !1, l = H(o, r, i), c = d.lastStatus || !1, f = d.config || {}, h = d.timerId, (!0 === s && !0 === l && !1 === c || !1 === s && !1 === l && !0 === c || !0 === u && !0 === l && !1 === c || !0 === u && !1 === l && !0 === c) && (e.performDOMCapture(document, f), u && !1 !== l || (N.splice(a--, 1), N.length === 0 && TLT.registerMutationCallback(U, !1), h && clearTimeout(h))), d.lastStatus = l } function X (t, r, i) { let a; let o = null; return t ? ((r = r || {}).eventOn = s, s = !1, i ? (o = 'dcid-' + n.getSerialNumber() + '.' + (new Date()).getTime() + 's', typeof i === 'object' ? (r.dcid = o, a = { config: r, delayUntil: i, lastStatus: !1 }, N.push(a), TLT.registerMutationCallback(U, !0), void 0 !== i.timeout && i.timeout >= 0 && (a.timerId = window.setTimeout(function () { !(function (t) { let n, r; for (n = 0; n < N.length; n += 1)(r = N[n].config || {}).dcid === t && (r.timeoutExpired = !0, e.performDOMCapture(document, r), N.splice(n--, 1), N.length === 0 && TLT.registerMutationCallback(U, !1)) }(o)) }, i.timeout))) : window.setTimeout(function () { r.dcid = o, e.performDOMCapture(t, r) }, i)) : (delete r.dcid, o = e.performDOMCapture(t, r)), o) : o } function j (t, r, i) { let a; let o; let s; let u; let l; let c; let d; let f; let p = !1; const g = {}; let m = null; let v = 0; if (!t || !r && !i) return m; if (!r && t !== 'load' && t !== 'unload') return m; if (b = e.getConfig() || {}, !n.getValue(b, 'domCapture.enabled', !1) || n.isLegacyIE) return m; if (function (t, n) { let r, i, a, o; for (r = 0, i = t.length; r < i; r += 1) switch (a = t[r], o = n && n.indexOf('#') === 0 ? location.pathname + n : void 0 === n || n === h ? location.pathname + location.hash : n, o = e.normalizeUrl(o, 2), typeof a) { case 'object':if (a.cRegex || (a.cRegex = new RegExp(a.regex, a.flags)), a.cRegex.lastIndex = 0, a.cRegex.test(o)) return !0; break; case 'string':if (a === o) return !0 } return !1 }(n.getValue(b, 'domCapture.screenviewBlacklist', []), i)) return m; for (a = 0, l = (u = n.getValue(b, 'domCapture.triggers') || []).length; !p && a < l; a += 1) { if ((s = u[a]).event === t) if (t === 'load' || t === 'unload') if (s.screenviews) for (o = 0, f = (d = s.screenviews).length; !p && o < f; o += 1) switch (typeof (c = d[o])) { case 'object':c.cRegex || (c.cRegex = new RegExp(c.regex, c.flags)), c.cRegex.lastIndex = 0, p = c.cRegex.test(i); break; case 'string':p = c === i } else p = !0; else p = !s.targets || n.matchTarget(s.targets, r) !== -1; s.event === 'change' && s.delayUntil && (A = A.concat(s.targets)) } return p && (v = s.delay || s.delayUntil || (s.event === 'load' ? 7 : 0), g.forceFullDOM = !!s.fullDOMCapture, (m = X(window.document, g, v)) && (function () { let t; let n = !1; if (E.enabled && !window.hasOwnProperty('ontouchstart') && L.length !== 0)I >= P && (n = !0), t = { type: 18, mousemove: { elements: M.slice(0), data: L.slice(0), config: { ignoreRadius: E.ignoreRadius, sampleRate: E.sampleRate }, limitReached: n, maxInactivity: R } }, e.post(t), M.length = 0, L.length = 0, D = {}, R = 0 }())), m } function q (e) { let t; let r; const i = n.getValue(e, 'webEvent.target', {}); const a = i.type; const o = i.subType || ''; const s = n.getTlType(i); const u = (function (e) { const t = []; for (e = e.parentNode; e;)t.push(e), e = e.parentNode; return t }(n.getValue(i, 'element'))); const l = n.getValue(e, 'webEvent.subType', null); return t = { timestamp: n.getValue(e, 'webEvent.timestamp', 0), type: 4, target: { id: i.id || '', idType: i.idType, name: i.name, tlType: s, type: a, position: { width: n.getValue(i, 'size.width'), height: n.getValue(i, 'size.height') }, currState: e.currState || null }, event: { tlEvent: F(n.getValue(e, 'webEvent')), type: n.getValue(e, 'webEvent.type', 'UNKNOWN') } }, i.accessibility && (t.target.accessibility = i.accessibility), i.attributes && (t.target.attributes = i.attributes), o && (t.target.subType = o), typeof e.dwell === 'number' && e.dwell > 0 && (t.target.dwell = e.dwell), typeof e.visitedCount === 'number' && (t.target.visitedCount = e.visitedCount), void 0 !== e.prevState && (t.prevState = e.prevState), l && (t.event.subType = l), r = (function (e) { return n.some(e, function (e) { const t = n.getTagName(e); return t === 'a' || t === 'button' ? e : null }) }(u)), t.target.isParentLink = !!r, r && (r.href && (t.target.currState = t.target.currState || {}, t.target.currState.href = t.target.currState.href || r.href), r.value && (t.target.currState = t.target.currState || {}, t.target.currState.value = t.target.currState.value || r.value), (r.innerText || r.textContent) && (t.target.currState = t.target.currState || {}, t.target.currState.innerText = n.trim(t.target.currState.innerText || r.innerText || r.textContent))), n.isUndefOrNull(t.target.currState) && delete t.target.currState, n.isUndefOrNull(t.target.name) && delete t.target.name, t } function B (t) { e.post(t) } function Y (t) { let n; let r; let i; let a; let o; const s = t.length; const u = { mouseout: !0, mouseover: !0 }; const l = []; for (n = 0; n < s; n += 1) if (i = t[n]) if (u[i.event.type])l.push(i); else { for (r = n + 1; r < s && t[r] && u[t[r].event.type]; r += 1);r < s && (a = t[r]) && i.target.id === a.target.id && i.event.type !== a.event.type && (i.event.type === 'click' && (o = i, i = a, a = o), a.event.type === 'click' ? (i.target.position = a.target.position, n += 1) : a.event.type === 'blur' && (i.target.dwell = a.target.dwell, i.target.visitedCount = a.target.visitedCount, i.focusInOffset = a.focusInOffset, i.target.position = a.target.position, n += 1), t[r] = null, t[n] = i), l.push(t[n]) } for (i = l.shift(); i; i = l.shift())e.post(i); t.splice(0, t.length) } function W (e, t) { o.push(q({ webEvent: e, id: t, currState: n.getValue(e, 'target.state') })) } function K (e, t, r) { let a; let s; let u; let l = !1; e && o.length !== 0 && (t = t || (i[e] ? i[e].webEvent : {})) && ((u = t.type === 'blur' || t.type === 'change' ? n.getValue(t, 'target.state', {}) : t.target && n.getTargetState(t.target.element) || {}) && u.disabled && (r = !0), s = o[o.length - 1], i[e] ? (s.focusInOffset = i[e].focusInOffset, s.target.visitedCount = i[e].visitedCount, i[e].focus && (i[e].dwell = Number(new Date()) - i[e].focus, s.target.dwell = i[e].dwell), i[e].processedChange || !i[e].prevState || r || n.isEqual(i[e].prevState, u) || (t.type = 'change', s.event.type = t.type, s.event.tlEvent = F(t), s.target.prevState = i[e].prevState, s.target.currState = u)) : i[e] = {}, s.event.type === 'click' ? V(s.target) || (s.target.currState = u, l = !0) : s.event.type === 'focus' && (l = !0), l && !r && (s.event.type = 'blur', s.event.tlEvent = 'focusout'), s.dcid || (a = j(s.event.type, t.target)) && (s.dcid = a), r || (y.inFocus = !1), i[e].prevState = u ? n.mixin({}, u) : u, Y(o)) } function Q (e, t) { const r = o.length; const a = r ? o[r - 1] : null; y.inFocus && y.target.id === e ? a && a.target.id === e || (W(t, e), i[e].processedChange = !1, i[e].processedClick = !1) : (y.inFocus && K(y.target.id, y), (y = t).inFocus = !0, i[e] || (i[e] = {}), i[e].focus = y.dwellStart = Number(new Date()), i[e].focusInOffset = p ? y.dwellStart - Number(p) : -1, t.type === 'focus' ? i[e].prevState = n.getValue(t, 'target.state') : t.type !== 'click' || i[e].prevState || (i[e].prevState = n.getValue(t, 'target.state'), !i[e].prevState || t.target.subType !== 'checkbox' && t.target.subType !== 'radio' || (i[e].prevState.checked = !i[e].prevState.checked)), i[e].visitedCount = i[e].visitedCount + 1 || 1, i[e].webEvent = t, i[e].processedChange = !1, i[e].processedClick = !1, W(t, e)) } function J (e, t) { let r, a; t.target.type === 'select' && w && w.target.id === e ? w = null : (Q(e, t), (r = o[o.length - 1]).event.type === 'focus' && (r.event.type = 'click', r.event.tlEvent = F(t)), (a = t.nativeEvent) && (!window.MouseEvent || !(a instanceof MouseEvent && a.detail === 0) || window.PointerEvent && a instanceof PointerEvent && a.pointerType !== '') && (r.target.position.relXY = n.getValue(t, 'target.position.relXY')), i[e].processedChange || (i[e].webEvent = t), i[e].processedClick = !0, V(t.target) && K(e, t, !0), w = t) } function G (e, t) { const r = e; if (n.getValue(t, 'target.element.disabled', !1)) switch (t.type) { case 'pointerdown':c = r; break; case 'pointerup':r === c && (t.type = 'click', J(e, t)), c = null } } function Z () { let e; u && ((e = u.clientState).viewPortHeight > 0 && e.viewPortHeight < T && e.viewPortWidth > 0 && e.viewPortWidth < T && B(u), l = u, u = null, g = v || g, m = null), Z.timeoutId = 0 } function $ (e) { let t = null; if (!n.isOperaMini) return u = (function (e) { let t; const r = document.documentElement || {}; const i = document.body || {}; const a = window.screen; const o = a.width; const s = a.height; const u = n.getValue(e, 'orientation', 0); const c = n.isiOS && Math.abs(u) === 90 ? s : o; const d = { type: 1, clientState: { pageWidth: Math.max(i.clientWidth || 0, r.offsetWidth || 0, r.scrollWidth || 0), pageHeight: Math.max(i.clientHeight || 0, r.offsetHeight || 0, r.scrollHeight || 0), viewPortWidth: window.innerWidth || r.clientWidth, viewPortHeight: window.innerHeight || r.clientHeight, viewPortX: Math.round(window.pageXOffset || (r || i).scrollLeft || 0), viewPortY: Math.round(window.pageYOffset || (r || i).scrollTop || 0), deviceOrientation: u, event: n.getValue(e, 'type') } }; const f = d.clientState; return l = l || d, f.event === 'unload' && f.viewPortHeight === f.pageHeight && f.viewPortWidth === f.pageWidth && l.clientState.viewPortHeight < f.viewPortHeight && (f.viewPortHeight = l.clientState.viewPortHeight, f.viewPortWidth = l.clientState.viewPortWidth), f.viewPortY + f.viewPortHeight > f.pageHeight && (f.viewPortY = f.pageHeight - f.viewPortHeight), f.viewPortY < 0 && (f.viewPortY = 0), t = f.viewPortWidth ? c / f.viewPortWidth : 1, f.deviceScale = t.toFixed(3), f.viewTime = 0, g && m && (f.viewTime = m.getTime() - g.getTime()), e.type === 'scroll' && (f.viewPortXStart = l.clientState.viewPortX, f.viewPortYStart = l.clientState.viewPortY), d }(e)), e.type === 'scroll' || e.type === 'resize' ? (Z.timeoutId && window.clearTimeout(Z.timeoutId), Z.timeoutId = window.setTimeout(Z, n.getValue(b, 'scrollTimeout', 2e3))) : e.type === 'touchstart' || e.type === 'load' ? u && (_ = parseFloat(u.clientState.deviceScale)) : e.type === 'touchend' && u && (S = parseFloat(u.clientState.deviceScale), Z()), e.type !== 'load' && e.type !== 'unload' || (e.type === 'unload' && d && ((t = n.clone(u)).clientState.event = 'attention', t.clientState.viewTime = (new Date()).getTime() - d), Z(), t && (u = t, Z())), u } function ee (e) { let t; const r = {}; const i = n.getValue(e, 'nativeEvent.rotation', 0) || n.getValue(e, 'nativeEvent.touches[0].webkitRotationAngle', 0); let a = null; const o = { type: 4, event: { type: 'touchend' }, target: { id: n.getValue(e, 'target.id'), idType: n.getValue(e, 'target.idType') } }; n.getValue(e, 'nativeEvent.changedTouches.length', 0) + n.getValue(e, 'nativeEvent.touches.length', 0) === 2 && ($(e), (a = { rotation: i ? i.toFixed(2) : 0, scale: S ? S.toFixed(2) : 1 }).pinch = (t = S - _, isNaN(t) ? 'INVALID' : t < 0 ? 'CLOSE' : t > 0 ? 'OPEN' : 'NONE'), r.scale = _ ? _.toFixed(2) : 1, o.target.prevState = r, o.target.currState = a, B(o)) } return { init: function () { o = [] }, destroy: function () { K(a), o = [], Z.timeoutId && (window.clearTimeout(Z.timeoutId), Z.timeoutId = 0) }, onevent: function (s) { let u; let l; let c; let d; let y; let w = null; let T = null; if (typeof s === 'object' && s.type) { if (!(function (e, t) { let r; let i; const a = ['type', 'name', 'target.id']; let o = null; let s = !0; let u = 0; let l = 0; let c = 0; if (!e || !t || typeof e !== 'object' || typeof t !== 'object') return !1; for (r = 0, i = a.length; s && r < i; r += 1) if (o = a[r], n.getValue(e, o) !== n.getValue(t, o)) { s = !1; break } return s && (l = n.getValue(e, 'timestamp'), c = n.getValue(t, 'timestamp'), isNaN(l) && isNaN(c) || (u = Math.abs(n.getValue(e, 'timestamp') - n.getValue(t, 'timestamp')), (isNaN(u) || u > 10) && (s = !1))), s }(s, f))) { switch (f = s, u = n.getValue(s, 'target.id'), i[u] || (i[u] = {}), (function (e, t) { let r; let a = !1; const s = o.length; const u = s ? o[s - 1] : null; u && ((r = u.target.id) !== e && u.target.tltype !== 'selectList' && (t.type !== 'focus' && t.type !== 'click' && t.type !== 'change' && t.type !== 'blur' && t.type !== 'unload' || (K(r), a = !0)), r === e && (t.type === 'click' && i[e].processedClick || t.type === 'change' && i[e].processedChange || t.type === 'pointerup' && i[e].processedClick && n.getValue(t.target, 'state.disabled', !1)) && (K(r, null, !0), a = !0)) }(u, s)), s.type) { case 'hashchange':break; case 'focus':Q(u, s); break; case 'blur':K(u, s); break; case 'pointerdown':case 'pointerup':G(u, s); break; case 'click':J(u, s); break; case 'change':!(function (e, t) { let r; Q(e, t), (r = o[o.length - 1]).event.type = 'change', r.event.tlEvent = F(t), r.target.currState = t.target.state, i[e].prevState && (r.target.prevState = i[e].prevState, typeof r.target.currState.checked === 'boolean' && (r.target.prevState.checked = !r.target.currState.checked)), i[e].webEvent = t, i[e].processedChange = !0, n.matchTarget(A, t.target) !== -1 && K(e, t) }(u, s)); break; case 'orientationchange':!(function (e) { const t = e.orientation; B({ type: 4, event: { type: 'orientationchange' }, target: { prevState: { orientation: r, orientationMode: n.getOrientationMode(r) }, currState: { orientation: t, orientationMode: n.getOrientationMode(t) } } }), r = t }(s)); break; case 'touchstart':!(function (e) { n.getValue(e, 'nativeEvent.touches.length', 0) === 2 && $(e) }(s)); break; case 'touchend':ee(s); break; case 'loadWithFrames':TLT.logScreenviewLoad('rootWithFrames'); break; case 'load':r = s.orientation, g = new Date(), (typeof n.getOrientationAngle() !== 'number' || n.isAndroid) && (c = window.screen.width > window.screen.height ? 90 : 0, l = n.getOrientationAngle(), Math.abs(l) === c || l === 180 && c === 0 || l === 270 && c === 90 || (n.isLandscapeZeroDegrees = !0, Math.abs(l) === 180 || Math.abs(l) === 0 ? r = 90 : Math.abs(l) !== 90 && Math.abs(l) !== 270 || (r = 0))), setTimeout(function () { e.isInitialized() && $(s) }, 100), t = n.getValue(b, 'forceRootScreenview', !1) ? h : e.normalizeUrl(location.hash, 2) || h, TLT.logScreenviewLoad(t); break; case 'screenview_load':p = new Date(), (function () { let e; for (e in i)i.hasOwnProperty(e) && (i[e].visitedCount = 0) }()), w = j('load', null, s.name); break; case 'screenview_unload':w = j('unload', null, s.name); break; case 'resize':case 'scroll':m || (m = new Date()), v = new Date(), $(s); break; case 'unload':for (d in x)x.hasOwnProperty(d) && (y = x[d].exception).repeats > 1 && (T = { type: 6, exception: y }, e.post(T)); o && Y(o), m = new Date(), $(s), t !== h && e.normalizeUrl(location.hash, 2) !== t || TLT.logScreenviewUnload(t); break; case 'mousemove':!(function (t) { let r; let i; let a; let o; let s; let u; let l = 0; if (E.enabled && !window.hasOwnProperty('ontouchstart') && !(I >= P)) { if (r = { element: { id: t.target.id, idType: t.target.idType }, x: t.position.x, y: t.position.y, offset: e.getCurrentOffset() }, k !== null) { if (l = r.offset - k.offset, C && l < C) return; if (s = Math.abs(r.x - k.x), u = Math.abs(r.y - k.y), O && (s > u ? s : u) < O) return; l > R && (R = l) }i = JSON.stringify(r.element), void 0 === (a = D[i]) && (M.push(r.element), a = M.length - 1, D[i] = a), o = n.getValue(t, 'target.position.relXY').split(','), L.push([a, o[0], o[1], r.offset]), I += 1, k = r } }(s)); break; case 'error':!(function (t) { let r; let i = null; const a = n.getValue(t, 'nativeEvent.message'); let o = n.getValue(t, 'nativeEvent.filename', ''); const s = n.getValue(t, 'nativeEvent.lineno', -1); const u = n.getValue(t, 'nativeEvent.error'); typeof a === 'string' && (o && (o = e.normalizeUrl(o, 6)), r = u && u.stack ? u.stack.toString() : (a + ' ' + o + ' ' + s).toString(), x[r] ? x[r].exception.repeats = x[r].exception.repeats + 1 : (i = { type: 6, exception: { description: a, url: o, line: s } }, e.post(i), x[r] = { exception: { description: a, url: o, line: s, repeats: 1 } }), 1) }(s)); break; case 'visibilitychange':!(function (e) { let t; const n = document.visibilityState === 'visible'; const r = { type: 4, event: { type: 'visibilitychange' }, target: { prevState: { visible: z }, currState: { visible: n } } }; (t = j(e.type, e.target)) && (r.dcid = t), B(r), z = n }(s)); break; default:!(function (e) { let t; const r = { type: 4, event: { tlEvent: F(e), type: e.type }, target: { id: n.getValue(e, 'target.id'), idType: n.getValue(e, 'target.idType'), currState: n.getValue(e, 'target.state') } }; (t = j(e.type, e.target)) && (r.dcid = t), B(r) }(s)) } return a = u, w }f = s } }, onmessage: function () {} } });

/**
 * Copyright (c) 2023 Acoustic, L.P. All rights reserved.
 *
 * NOTICE: This file contains material that is confidential and proprietary to
 * Acoustic, L.P. and/or other developers. No license is granted under any intellectual or
 * industrial property rights of Acoustic, L.P. except as may be provided in an agreement with
 * Acoustic, L.P. Any unauthorized copying or distribution of content from this file is
 * prohibited.
 *
 */

// Tealeaf configuration for SDK 6.4.8
(function () {
  'use strict'
  let config
  const TLT = window.TLT
  const isWebkit = /WebKit/i.test(navigator.userAgent)

  if (TLT.utils.isLegacyIE) {
    if (console) {
      console.warn('This version of the UIC does not support Internet Explorer 8.')
      console.info('Applications requiring Internet Explorer 8 (or below) support should use UIC 5.2.0')
    }
    TLT.terminationReason = 'Unsupported browser'
    return
  }

  config =
    {
      core: {
        buildNote: '2023_Car_New',
        blockedElements: [],
        modules: {
          overstat: {
            events: [
              { name: 'click', recurseFrames: true },
              { name: 'mousemove', recurseFrames: true },
              { name: 'mouseout', recurseFrames: true },
              { name: 'submit', recurseFrames: true }
            ]
          },
          performance: {
            events: [
              { name: 'load', target: window },
              { name: 'unload', target: window }
            ]
          },
          replay: {
            events: [
              { name: 'change', attachToShadows: true, recurseFrames: true },
              { name: 'click', recurseFrames: true },
              { name: 'dblclick', recurseFrames: true },
              { name: 'contextmenu', recurseFrames: true },
              { name: 'pointerdown', recurseFrames: true },
              { name: 'pointerup', recurseFrames: true },
              { name: 'hashchange', target: window },
              { name: 'focus', recurseFrames: true },
              { name: 'blur', recurseFrames: true },
              { name: 'load', target: window },
              { name: 'unload', target: window },
              { name: 'resize', target: window },
              { name: 'scroll', target: window },
              { name: 'mousemove', recurseFrames: true },
              { name: 'orientationchange', target: window },
              { name: 'touchend' },
              { name: 'touchstart' },
              { name: 'error', target: window },
              { name: 'visibilitychange' }
            ]
          },
          dataLayer: {
            enabled: false,
            events: [
              { name: 'load', target: window },
              { name: 'unload', target: window }
            ]
          },
          TLCookie: {
            enabled: true
          }
        },

        normalization: {
          urlFunction: function (urlOrPath, messageType) {
            return urlOrPath
          }
        },

        sessionDataEnabled: false,
        sessionData: {
          sessionValueNeedsHashing: true,
          sessionQueryName: 'sessionID',
          sessionQueryDelim: ';',
          sessionCookieName: 'jsessionid'
        },
        screenviewAutoDetect: true,
        framesBlacklist: [
          // "#iframe1"
        ]
      },
      services: {
        queue: {
          asyncReqOnUnload: isWebkit,
          useBeacon: true,
          queues: [
            {
              qid: 'DEFAULT',
              endpoint: 'https://lib-us-2.brilliantcollector.com/collector/collectorPost',
              maxEvents: 50,
              timerInterval: 300000,
              maxSize: 300000,
              checkEndpoint: false,
              endpointCheckTimeout: 3000
            }
          ]
        },
        message: {
          privacy: [
            {
              targets: [
                'input[type=password]',
                'input[type=hidden]'
              ],
              maskType: 3
            },
            {
              // UserInput遮罩:只留第一個字.
              targets: [
                { id: { regex: '.*Name.*', flags: 'g' }, idType: -1 }
              ],
              maskType: 4,
              maskFunction: function (val) {
                const n = val.length
                const firstLetter = val.charAt(0)
                if (firstLetter.trim() === '') {
                  return firstLetter + val.substring(1).replace(/./g, 'O')
                }
                let maskedStr = ''
                for (let i = 0; i <= n - 2; i++) { maskedStr += 'O' }
                const maskedVal = firstLetter.concat(maskedStr)
                return maskedVal
              }
            },
            {
              // UserInput遮罩:遮罩後4碼.
              targets: [
                { id: { regex: '.*BirthDay.*', flags: 'g' }, idType: -1 },
                { id: { regex: '.*MobilePhone.*', flags: 'g' }, idType: -1 },
                { id: { regex: 'BeneficiaryTel.*', flags: 'g' }, idType: -1 }
              ],
              maskType: 4,
              maskFunction: function (val) {
                const n = val.length
                if (n > 0) {
                  var maskedVal = val.slice(0, -4)
                  maskedVal += '****'
                } else { maskedVal = '' }
                return maskedVal
              }
            },
            {
              // UserInput遮罩:遮罩後5碼.
              targets: [
                { id: 'CustomerId', idType: -1 },
                { id: 'AssuredId', idType: -1 },
                { id: 'EngineId', idType: -1 },
                { id: 'Account', idType: -1 },
                { id: 'VehicleEngineId', idType: -1 },
                { id: 'VehicleId', idType: -1 },
                { id: { regex: 'ApplicantId.*', flags: 'g' }, idType: -1 },
                { id: { regex: 'DriverID.*', flags: 'g' }, idType: -1 }
              ],
              maskType: 4,
              maskFunction: function (val) {
                const n = val.length
                if (n > 0) {
                  var maskedVal = val.slice(0, -5)
                  maskedVal += '*****'
                } else { maskedVal = '' }
                return maskedVal
              }
            },
            {
              // UserInput遮罩:遮罩＠之後.
              targets: [
                { id: { regex: '.*Email.*', flags: 'g' }, idType: -1 }
              ],
              maskType: 4,
              maskFunction: function (val) {
                const n = val.length
                const p = val.indexOf('@')
                const m = n - p
                const strPrefix = (m <= 0) ? '' : val.substr(0, p + 1)
                let strMask = ''
                let maskedVal = ''
                if (n > 0 && p > 0) {
                  for (let i = 0; i < m - 1; i++) {
                    strMask += '*'
                  }
                  maskedVal = strPrefix.concat(strMask)
                } else { for (let j = 0; j < n; j++) { maskedVal += 'X' } }
                return maskedVal
              }
            },
            {
              // UserInput遮罩:全遮罩.
              targets: [
                { id: 'TagId_2', idType: -1 },
                { id: 'AccountNumber', idType: -1 },
                { id: 'CardNumber', idType: -1 },
                { id: 'ExpDate_Month', idType: -1 },
                { id: 'ExpDate_Year', idType: -1 },
                { id: 'Cvv', idType: -1 },
                { id: 'VehicleTagId_2', idType: -1 },
                { id: 'VerificationCode', idType: -1 },
                { id: 'otpBackCode', idType: -1 },
                { id: 'cc-number', idType: -1 },
                { id: 'cc-exp', idType: -1 },
                { id: 'cc-ccv', idType: -1 },
                { id: { regex: '.*Address.*', flags: 'g' }, idType: -1 }
              ],
              maskType: 4,
              maskFunction: function (val) {
                const n = val.length
                let maskedStr = ''
                if (n >= 0) {
                  for (let i = 0; i < n; i++) {
                    maskedStr += '*'
                  }
                  const maskedVal = maskedStr
                  return maskedVal
                }
              }
            }
          ],
          privacyPatterns: [
            {
              // WebResponse遮罩-只留第一個字.new (新改寫，避免新安東京網頁輸出時第一字元自帶空白)
              pattern: { regex: 'class="[^"]*tlf_r_f1[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const newVal = group1.replace(/\s/, '')
                const n = newVal.length
                const firstLetter = newVal.substring(0, 1)
                let maskedStr = ''
                for (let i = 0; i <= n - 2; i++) {
                  maskedStr += 'O'
                }
                const maskedVal = firstLetter.concat(maskedStr)
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩後4碼.new
              pattern: { regex: 'class="[^"]*tlf_n_l4[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                if (n > 0) {
                  var maskedVal = group1.slice(0, -4)
                  maskedVal += '****'
                } else { maskedVal = '' }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩後5碼.new
              pattern: { regex: 'class="[^"]*tlf_n_l5[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                if (n > 0) {
                  var maskedVal = group1.slice(0, -5)
                  maskedVal += '*****'
                } else { maskedVal = '' }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩＠之後.new
              pattern: { regex: 'class="[^"]*tlf_n_at1[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                const p = group1.indexOf('@')
                const m = n - p
                const strPrefix = (m <= 0) ? '' : group1.substr(0, p + 1)
                let strMask = ''
                let maskedVal = ''
                if (n > 0 && p > 0) {
                  for (let i = 0; i < m - 1; i++) { strMask += '*' }
                  maskedVal = strPrefix.concat(strMask)
                } else { for (let j = 0; j < n; j++) { maskedVal += 'X' } }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩＠之後.new
              pattern: { regex: 'class="text-blue tlf_n_at1">(.*?)<\/a>', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                const p = group1.indexOf('@')
                const m = n - p
                const strPrefix = (m <= 0) ? '' : group1.substr(0, p + 1)
                let strMask = ''
                let maskedVal = ''
                if (n > 0 && p > 0) {
                  for (let i = 0; i < m - 1; i++) { strMask += '*' }
                  maskedVal = strPrefix.concat(strMask)
                } else { for (let j = 0; j < n; j++) { maskedVal += 'X' } }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-全遮罩.new
              pattern: { regex: 'class="[^"]*tlf_n_all[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                let maskedStr = ''
                if (n >= 0) {
                  for (let i = 0; i < n; i++) {
                    maskedStr += '*'
                  }
                  var maskedVal = maskedStr
                }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩後6碼 生日格式  ex:民國90年05月11日 .new
              pattern: { regex: 'class="[^"]*tlf_n_l6[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                let maskedVal = ''
                let starmarks = ''
                if (group1.includes('民國')) {
                  const tmpStr = '年XX月XX日'
                  const spltStr = group1.split('年')
                  maskedVal = spltStr[0] + tmpStr
                } else {
                  maskedVal = group1.substring(0, n - 6)
                  for (let i = 0; i <= 6; i++) { starmarks += '*' }
                  maskedVal = maskedVal + starmarks
                }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            },
            {
              // WebResponse遮罩-遮罩dash之後.
              pattern: { regex: 'class="[^"]*tlf_n_dash1[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                // console.log('Start');
                let maskedVal = ''
                let starmarks = ''
                const gp1Strs = group1.split('-')
                if (typeof gp1Strs[1] !== 'undefined') {
                  for (let i = 0; i <= gp1Strs[1].length; i++) {
                    starmarks += '*'
                  }
                  maskedVal = gp1Strs[0] + starmarks
                } else { maskedVal = '********' }
                const retVal = fullmatch.replace(group1, maskedVal)
                // console.log(retVal);
                return retVal
              }
            },
            {
              // Match class type 1 保留前6碼 = 第7碼開始遮.
              pattern: { regex: 'class="[^"]*tlf_r_f6[^"]*"[^>]*>(.*?)<', flags: 'g' },
              replacement: function (fullmatch, group1) {
                const n = group1.length
                let maskedVal = ''
                if (n > 5) {
                  maskedVal = group1.slice(0, 6)
                  for (let i = 0; i < n - 6; i++) {
                    maskedVal += '*'
                  }
                } else { maskedVal = '********' }
                const retVal = fullmatch.replace(group1, maskedVal)
                return retVal
              }
            }
          ]
        },
        encoder: {
          gzip: {
            encode: 'window.pako.gzip',
            defaultEncoding: 'gzip'
          }
        },
        domCapture: {
          diffEnabled: true,
          options: {
            maxMutations: 100,
   					maxLength: 3000000,
            captureStyle: true,
            captureFrames: true,
            captureShadowDOM: false
          }
        },
        browser: {
          normalizeTargetToParentLink: true
        }
      },
      modules: {
        overstat: {
          hoverThreshold: 1000
        },
        performance: {
          calculateRenderTime: true,
          renderTimeThreshold: 600000
        },
        replay: {
          domCapture: {
            enabled: true,
            triggers: [
              {
                event: 'click',
                fullDOMCapture: true,
                delay: 250
              },
              {
                event: 'change',
                fullDOMCapture: true,
                delay: 250
              },
              {
                event: 'load',
                fullDOMCapture: true,
                delay: 500
              },
              {
                event: 'unload',
                fullDOMCapture: true,
                delay: 200
              },
              {
                event: 'visibilitychange'
              }
            ]
          },
          mousemove: {
            enabled: true,
            sampleRate: 200,
            ignoreRadius: 10
          }
        },
        dataLayer: {
          dataObject: ''
        },
        TLCookie: {
          appCookieWhitelist: [
            { regex: '.*' }
          ],
          // 1041bee811a1433ebea38bc464dfe01b --- TMNEWA UAT
          // e04ab66722bd4d3c82fef34e5e121823 --- TMNI
          tlAppKey: '1041bee811a1433ebea38bc464dfe01b'
        }
      }
    }

  TLT.init(config)
}())
